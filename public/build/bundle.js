
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function (moment) {
    'use strict';

    moment = moment && Object.prototype.hasOwnProperty.call(moment, 'default') ? moment['default'] : moment;

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? undefined : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.23.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.23.0 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[14]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[13]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, remove it before we run the matching
    			if (prefix) {
    				if (typeof prefix == "string" && path.startsWith(prefix)) {
    					path = path.substr(prefix.length) || "/";
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Router", $$slots, []);

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		previousScrollState,
    		lastLoc,
    		componentObj,
    		RouteItem,
    		routesList,
    		dispatch,
    		dispatchNextTick,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // List of nodes to update
    const nodes = [];

    // Current location
    let location$1;

    // Function that updates all nodes marking the active ones
    function checkActive(el) {
        // Repeat this for each class
        (el.className || '').split(' ').forEach((cls) => {
            if (!cls) {
                return
            }
            // Remove the active class firsts
            el.node.classList.remove(cls);

            // If the pattern matches, then set the active class
            if (el.pattern.test(location$1)) {
                el.node.classList.add(cls);
            }
        });
    }

    // Listen to changes in the location
    loc.subscribe((value) => {
        // Update the location
        location$1 = value.location + (value.querystring ? '?' + value.querystring : '');

        // Update all nodes
        nodes.map(checkActive);
    });

    /**
     * @typedef {Object} ActiveOptions
     * @property {string|RegExp} [path] - Path expression that makes the link active when matched (must start with '/' or '*'); default is the link's href
     * @property {string} [className] - CSS class to apply to the element when active; default value is "active"
     */

    /**
     * Svelte Action for automatically adding the "active" class to elements (links, or any other DOM element) when the current location matches a certain path.
     * 
     * @param {HTMLElement} node - The target node (automatically set by Svelte)
     * @param {ActiveOptions|string|RegExp} [opts] - Can be an object of type ActiveOptions, or a string (or regular expressions) representing ActiveOptions.path.
     * @returns {{destroy: function(): void}} Destroy function
     */
    function active(node, opts) {
        // Check options
        if (opts && (typeof opts == 'string' || (typeof opts == 'object' && opts instanceof RegExp))) {
            // Interpret strings and regular expressions as opts.path
            opts = {
                path: opts
            };
        }
        else {
            // Ensure opts is a dictionary
            opts = opts || {};
        }

        // Path defaults to link target
        if (!opts.path && node.hasAttribute('href')) {
            opts.path = node.getAttribute('href');
            if (opts.path && opts.path.length > 1 && opts.path.charAt(0) == '#') {
                opts.path = opts.path.substring(1);
            }
        }

        // Default class name
        if (!opts.className) {
            opts.className = 'active';
        }

        // If path is a string, it must start with '/' or '*'
        if (!opts.path || 
            typeof opts.path == 'string' && (opts.path.length < 1 || (opts.path.charAt(0) != '/' && opts.path.charAt(0) != '*'))
        ) {
            throw Error('Invalid value for "path" argument')
        }

        // If path is not a regular expression already, make it
        const {pattern} = typeof opts.path == 'string' ?
            regexparam(opts.path) :
            {pattern: opts.path};

        // Add the node to the list
        const el = {
            node,
            className: opts.className,
            pattern
        };
        nodes.push(el);

        // Trigger the action right away
        checkActive(el);

        return {
            // When the element is destroyed, remove it from the list
            destroy() {
                nodes.splice(nodes.indexOf(el), 1);
            }
        }
    }

    /**
     * Bring session into the valid state by calling the authorization endpoint
     * and asking for a access_token.
     * Executes a POST on the endpoint url expecting username, and password as json
     * @param {Session} session to be opened
     * @param {string} endpoint authorization url
     * @param {string} username id of the user
     * @param {string} password user credentials
     * @return {string} error message in case of failure or undefined on success
     */
    async function login(session, endpoint, username, password) {
      try {
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            username,
            password
          })
        });
        if (response.ok) {
          const data = await response.json();
          session.update({ username, access_token: data.access_token });
          session.save();
        } else {
          session.update({ username });
          return handleFailedResponse(response);
        }
      } catch (e) {
        session.update({ username });
        throw e;
      }
    }

    /**
     * Extract error description from response
     * @param {FetchResponse} response
     * @return {string}
     */
    async function handleFailedResponse(response) {
      const wa = response.headers.get("WWW-Authenticate");

      if (wa) {
        const o = Object.fromEntries(
          wa.split(/\s*,\s*/).map(entry => entry.split(/=/))
        );
        if (o.error_description) {
          return o.error_description;
        }
      }

      let message = response.statusText;

      const ct = response.headers.get("Content-Type").replace(/;.*/, "");

      switch (ct) {
        case "text/plain":
          message += "\n" + (await response.text());
          break;
        case "text/html":
          const root = document.createElement("html");
          root.innerHTML = await response.text();

          for (const tag of ["title", "h1", "h2"]) {
            for (const item of root.getElementsByTagName(tag)) {
              const text = item.innerText;
              if (text) {
                return text;
              }
            }
          }
          break;
      }

      return message;
    }

    /**
     * Data as preserved in the backing store
     * @typedef {Object} SessionData
     * @property {string} username user name (id)
     * @property {string} access_token JWT token
     */

    /**
     * User session
     * To create as session backed by browser local storage
     * ```js
     * let session = new Session(localStorage);
     * ```
     * or by browser session storage
     * ```js
     * let session = new Session(sessionStorage);
     * ```
     * @param {SessionData} data
     * @property {Set<string>} entitlements
     * @property {Set<Object>} subscriptions store subscriptions
     * @property {Date} expirationDate
     * @property {string} access_token token itself
     * @property {SessionData} store backing store to use for save same as data param
     */
    class Session {
      constructor(data) {
        let expirationTimer;

        Object.defineProperties(this, {
          store: {
            value: data
          },
          subscriptions: {
            value: new Set()
          },
          entitlements: {
            value: new Set()
          },
          expirationDate: {
            value: new Date(0)
          },
          expirationTimer: {
            get: () => expirationTimer,
            set: v => (expirationTimer = v)
          }
        });

        this.update(data);
      }

      /**
       * Invalidate session data
       */
      clear() {
        this.entitlements.clear();
        this.expirationDate.setTime(0);
        this.username = undefined;
        this.access_token = undefined;
        if (this.expirationTimer) {
          clearTimeout(this.expirationTimer);
          this.expirationTimer = undefined;
        }
      }

      update(data) {
        this.clear();

        if (data !== undefined) {
          this.username = data.username !== "undefined" ? data.username : undefined;
          this.access_token = data.access_token;

          const decoded = decode(data.access_token);

          if (decoded) {
            this.expirationDate.setUTCSeconds(decoded.exp);

            const expiresInMilliSeconds =
              this.expirationDate.valueOf() - Date.now();

            if(expiresInMilliSeconds > 0) {
              if(decoded.entitlements) {
                decoded.entitlements.split(/,/).forEach(e => this.entitlements.add(e));
              }

              this.expirationTimer = setTimeout(() => {
                this.clear();
                this.fire();
              }, expiresInMilliSeconds);
            }
          }
        }

        this.fire();
      }

      /**
       * Persist into the backing store
       */
      save() {
        if (this.username === undefined) {
          delete this.store.access_token;
          delete this.store.username;
        } else {
          this.store.access_token = this.access_token;
          this.store.username = this.username;
        }
      }

      /**
       * http header suitable for fetch
       * @return {Object} header The http header.
       * @return {string} header.Authorization The Bearer access token.
       */
      get authorizationHeader() {
        return { Authorization: "Bearer " + this.access_token };
      }

      /**
       * As long as the expirationTimer is running we must be valid
       * @return {boolean} true if session is valid (not expired)
       */
      get isValid() {
        return this.expirationTimer !== undefined;
      }

      /**
       * Remove all tokens from the session and the backing store
       */
      invalidate() {
        this.update();
        this.save();
      }

      /**
       * Check presence of an entilement.
       * @param {string} name of the entitlement
       * @return {boolean} true if the named entitlement is present
       */ 
      hasEntitlement(name) {
        return this.entitlements.has(name);
      }

      fire() {
        this.subscriptions.forEach(subscription => subscription(this));
      }

      /**
       * Fired when the session changes
       * @param {Function} subscription
       */
      subscribe(subscription) {
        subscription(this);
        this.subscriptions.add(subscription);
        return () => this.subscriptions.delete(subscription);
      }
    }

    function decode(token) {
      return token === undefined || token === "undefined"
        ? undefined
        : JSON.parse(atob(token.split(".")[1]));
    }

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** Error thrown when an HTTP request fails. */
    var HttpError = /** @class */ (function (_super) {
        __extends(HttpError, _super);
        /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.
         *
         * @param {string} errorMessage A descriptive error message.
         * @param {number} statusCode The HTTP status code represented by this error.
         */
        function HttpError(errorMessage, statusCode) {
            var _newTarget = this.constructor;
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            _this.statusCode = statusCode;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return HttpError;
    }(Error));
    /** Error thrown when a timeout elapses. */
    var TimeoutError = /** @class */ (function (_super) {
        __extends(TimeoutError, _super);
        /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.
         *
         * @param {string} errorMessage A descriptive error message.
         */
        function TimeoutError(errorMessage) {
            var _newTarget = this.constructor;
            if (errorMessage === void 0) { errorMessage = "A timeout occurred."; }
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return TimeoutError;
    }(Error));
    /** Error thrown when an action is aborted. */
    var AbortError = /** @class */ (function (_super) {
        __extends(AbortError, _super);
        /** Constructs a new instance of {@link AbortError}.
         *
         * @param {string} errorMessage A descriptive error message.
         */
        function AbortError(errorMessage) {
            var _newTarget = this.constructor;
            if (errorMessage === void 0) { errorMessage = "An abort occurred."; }
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return AbortError;
    }(Error));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    /** Represents an HTTP response. */
    var HttpResponse = /** @class */ (function () {
        function HttpResponse(statusCode, statusText, content) {
            this.statusCode = statusCode;
            this.statusText = statusText;
            this.content = content;
        }
        return HttpResponse;
    }());
    /** Abstraction over an HTTP client.
     *
     * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
     */
    var HttpClient = /** @class */ (function () {
        function HttpClient() {
        }
        HttpClient.prototype.get = function (url, options) {
            return this.send(__assign({}, options, { method: "GET", url: url }));
        };
        HttpClient.prototype.post = function (url, options) {
            return this.send(__assign({}, options, { method: "POST", url: url }));
        };
        HttpClient.prototype.delete = function (url, options) {
            return this.send(__assign({}, options, { method: "DELETE", url: url }));
        };
        /** Gets all cookies that apply to the specified URL.
         *
         * @param url The URL that the cookies are valid for.
         * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
         */
        // @ts-ignore
        HttpClient.prototype.getCookieString = function (url) {
            return "";
        };
        return HttpClient;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.
    /** Indicates the severity of a log message.
     *
     * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
     */
    var LogLevel;
    (function (LogLevel) {
        /** Log level for very low severity diagnostic messages. */
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        /** Log level for low severity diagnostic messages. */
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        /** Log level for informational diagnostic messages. */
        LogLevel[LogLevel["Information"] = 2] = "Information";
        /** Log level for diagnostic messages that indicate a non-fatal problem. */
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        /** Log level for diagnostic messages that indicate a failure in the current operation. */
        LogLevel[LogLevel["Error"] = 4] = "Error";
        /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */
        LogLevel[LogLevel["Critical"] = 5] = "Critical";
        /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */
        LogLevel[LogLevel["None"] = 6] = "None";
    })(LogLevel || (LogLevel = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    /** A logger that does nothing when log messages are sent to it. */
    var NullLogger = /** @class */ (function () {
        function NullLogger() {
        }
        /** @inheritDoc */
        // tslint:disable-next-line
        NullLogger.prototype.log = function (_logLevel, _message) {
        };
        /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */
        NullLogger.instance = new NullLogger();
        return NullLogger;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var Arg = /** @class */ (function () {
        function Arg() {
        }
        Arg.isRequired = function (val, name) {
            if (val === null || val === undefined) {
                throw new Error("The '" + name + "' argument is required.");
            }
        };
        Arg.isIn = function (val, values, name) {
            // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
            if (!(val in values)) {
                throw new Error("Unknown " + name + " value: " + val + ".");
            }
        };
        return Arg;
    }());
    /** @private */
    var Platform = /** @class */ (function () {
        function Platform() {
        }
        Object.defineProperty(Platform, "isBrowser", {
            get: function () {
                return typeof window === "object";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Platform, "isWebWorker", {
            get: function () {
                return typeof self === "object" && "importScripts" in self;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Platform, "isNode", {
            get: function () {
                return !this.isBrowser && !this.isWebWorker;
            },
            enumerable: true,
            configurable: true
        });
        return Platform;
    }());
    /** @private */
    function getDataDetail(data, includeContent) {
        var detail = "";
        if (isArrayBuffer(data)) {
            detail = "Binary data of length " + data.byteLength;
            if (includeContent) {
                detail += ". Content: '" + formatArrayBuffer(data) + "'";
            }
        }
        else if (typeof data === "string") {
            detail = "String data of length " + data.length;
            if (includeContent) {
                detail += ". Content: '" + data + "'";
            }
        }
        return detail;
    }
    /** @private */
    function formatArrayBuffer(data) {
        var view = new Uint8Array(data);
        // Uint8Array.map only supports returning another Uint8Array?
        var str = "";
        view.forEach(function (num) {
            var pad = num < 16 ? "0" : "";
            str += "0x" + pad + num.toString(16) + " ";
        });
        // Trim of trailing space.
        return str.substr(0, str.length - 1);
    }
    // Also in signalr-protocol-msgpack/Utils.ts
    /** @private */
    function isArrayBuffer(val) {
        return val && typeof ArrayBuffer !== "undefined" &&
            (val instanceof ArrayBuffer ||
                // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
                (val.constructor && val.constructor.name === "ArrayBuffer"));
    }
    /** @private */
    function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, token, responseType, response;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, accessTokenFactory()];
                    case 1:
                        token = _b.sent();
                        if (token) {
                            headers = (_a = {},
                                _a["Authorization"] = "Bearer " + token,
                                _a);
                        }
                        _b.label = 2;
                    case 2:
                        logger.log(LogLevel.Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
                        responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
                        return [4 /*yield*/, httpClient.post(url, {
                                content: content,
                                headers: headers,
                                responseType: responseType,
                            })];
                    case 3:
                        response = _b.sent();
                        logger.log(LogLevel.Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
                        return [2 /*return*/];
                }
            });
        });
    }
    /** @private */
    function createLogger(logger) {
        if (logger === undefined) {
            return new ConsoleLogger(LogLevel.Information);
        }
        if (logger === null) {
            return NullLogger.instance;
        }
        if (logger.log) {
            return logger;
        }
        return new ConsoleLogger(logger);
    }
    /** @private */
    var SubjectSubscription = /** @class */ (function () {
        function SubjectSubscription(subject, observer) {
            this.subject = subject;
            this.observer = observer;
        }
        SubjectSubscription.prototype.dispose = function () {
            var index = this.subject.observers.indexOf(this.observer);
            if (index > -1) {
                this.subject.observers.splice(index, 1);
            }
            if (this.subject.observers.length === 0 && this.subject.cancelCallback) {
                this.subject.cancelCallback().catch(function (_) { });
            }
        };
        return SubjectSubscription;
    }());
    /** @private */
    var ConsoleLogger = /** @class */ (function () {
        function ConsoleLogger(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
            this.outputConsole = console;
        }
        ConsoleLogger.prototype.log = function (logLevel, message) {
            if (logLevel >= this.minimumLogLevel) {
                switch (logLevel) {
                    case LogLevel.Critical:
                    case LogLevel.Error:
                        this.outputConsole.error("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    case LogLevel.Warning:
                        this.outputConsole.warn("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    case LogLevel.Information:
                        this.outputConsole.info("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    default:
                        // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
                        this.outputConsole.log("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                }
            }
        };
        return ConsoleLogger;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var requestModule;
    if (typeof XMLHttpRequest === "undefined") {
        // In order to ignore the dynamic require in webpack builds we need to do this magic
        // @ts-ignore: TS doesn't know about these names
        var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        requestModule = requireFunc("request");
    }
    /** @private */
    var NodeHttpClient = /** @class */ (function (_super) {
        __extends$1(NodeHttpClient, _super);
        function NodeHttpClient(logger) {
            var _this = _super.call(this) || this;
            if (typeof requestModule === "undefined") {
                throw new Error("The 'request' module could not be loaded.");
            }
            _this.logger = logger;
            _this.cookieJar = requestModule.jar();
            _this.request = requestModule.defaults({ jar: _this.cookieJar });
            return _this;
        }
        NodeHttpClient.prototype.send = function (httpRequest) {
            var _this = this;
            // Check that abort was not signaled before calling send
            if (httpRequest.abortSignal) {
                if (httpRequest.abortSignal.aborted) {
                    return Promise.reject(new AbortError());
                }
            }
            return new Promise(function (resolve, reject) {
                var requestBody;
                if (isArrayBuffer(httpRequest.content)) {
                    requestBody = Buffer.from(httpRequest.content);
                }
                else {
                    requestBody = httpRequest.content || "";
                }
                var currentRequest = _this.request(httpRequest.url, {
                    body: requestBody,
                    // If binary is expected 'null' should be used, otherwise for text 'utf8'
                    encoding: httpRequest.responseType === "arraybuffer" ? null : "utf8",
                    headers: __assign$1({ 
                        // Tell auth middleware to 401 instead of redirecting
                        "X-Requested-With": "XMLHttpRequest" }, httpRequest.headers),
                    method: httpRequest.method,
                    timeout: httpRequest.timeout,
                }, function (error, response, body) {
                    if (httpRequest.abortSignal) {
                        httpRequest.abortSignal.onabort = null;
                    }
                    if (error) {
                        if (error.code === "ETIMEDOUT") {
                            _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
                            reject(new TimeoutError());
                        }
                        _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + error);
                        reject(error);
                        return;
                    }
                    if (response.statusCode >= 200 && response.statusCode < 300) {
                        resolve(new HttpResponse(response.statusCode, response.statusMessage || "", body));
                    }
                    else {
                        reject(new HttpError(response.statusMessage || "", response.statusCode || 0));
                    }
                });
                if (httpRequest.abortSignal) {
                    httpRequest.abortSignal.onabort = function () {
                        currentRequest.abort();
                        reject(new AbortError());
                    };
                }
            });
        };
        NodeHttpClient.prototype.getCookieString = function (url) {
            return this.cookieJar.getCookieString(url);
        };
        return NodeHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var XhrHttpClient = /** @class */ (function (_super) {
        __extends$2(XhrHttpClient, _super);
        function XhrHttpClient(logger) {
            var _this = _super.call(this) || this;
            _this.logger = logger;
            return _this;
        }
        /** @inheritDoc */
        XhrHttpClient.prototype.send = function (request) {
            var _this = this;
            // Check that abort was not signaled before calling send
            if (request.abortSignal && request.abortSignal.aborted) {
                return Promise.reject(new AbortError());
            }
            if (!request.method) {
                return Promise.reject(new Error("No method defined."));
            }
            if (!request.url) {
                return Promise.reject(new Error("No url defined."));
            }
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open(request.method, request.url, true);
                xhr.withCredentials = true;
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                // Explicitly setting the Content-Type header for React Native on Android platform.
                xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
                var headers = request.headers;
                if (headers) {
                    Object.keys(headers)
                        .forEach(function (header) {
                        xhr.setRequestHeader(header, headers[header]);
                    });
                }
                if (request.responseType) {
                    xhr.responseType = request.responseType;
                }
                if (request.abortSignal) {
                    request.abortSignal.onabort = function () {
                        xhr.abort();
                        reject(new AbortError());
                    };
                }
                if (request.timeout) {
                    xhr.timeout = request.timeout;
                }
                xhr.onload = function () {
                    if (request.abortSignal) {
                        request.abortSignal.onabort = null;
                    }
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
                    }
                    else {
                        reject(new HttpError(xhr.statusText, xhr.status));
                    }
                };
                xhr.onerror = function () {
                    _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + xhr.status + ": " + xhr.statusText + ".");
                    reject(new HttpError(xhr.statusText, xhr.status));
                };
                xhr.ontimeout = function () {
                    _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
                    reject(new TimeoutError());
                };
                xhr.send(request.content || "");
            });
        };
        return XhrHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** Default implementation of {@link @microsoft/signalr.HttpClient}. */
    var DefaultHttpClient = /** @class */ (function (_super) {
        __extends$3(DefaultHttpClient, _super);
        /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */
        function DefaultHttpClient(logger) {
            var _this = _super.call(this) || this;
            if (typeof XMLHttpRequest !== "undefined") {
                _this.httpClient = new XhrHttpClient(logger);
            }
            else {
                _this.httpClient = new NodeHttpClient(logger);
            }
            return _this;
        }
        /** @inheritDoc */
        DefaultHttpClient.prototype.send = function (request) {
            // Check that abort was not signaled before calling send
            if (request.abortSignal && request.abortSignal.aborted) {
                return Promise.reject(new AbortError());
            }
            if (!request.method) {
                return Promise.reject(new Error("No method defined."));
            }
            if (!request.url) {
                return Promise.reject(new Error("No url defined."));
            }
            return this.httpClient.send(request);
        };
        DefaultHttpClient.prototype.getCookieString = function (url) {
            return this.httpClient.getCookieString(url);
        };
        return DefaultHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Not exported from index
    /** @private */
    var TextMessageFormat = /** @class */ (function () {
        function TextMessageFormat() {
        }
        TextMessageFormat.write = function (output) {
            return "" + output + TextMessageFormat.RecordSeparator;
        };
        TextMessageFormat.parse = function (input) {
            if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
                throw new Error("Message is incomplete.");
            }
            var messages = input.split(TextMessageFormat.RecordSeparator);
            messages.pop();
            return messages;
        };
        TextMessageFormat.RecordSeparatorCode = 0x1e;
        TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);
        return TextMessageFormat;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    /** @private */
    var HandshakeProtocol = /** @class */ (function () {
        function HandshakeProtocol() {
        }
        // Handshake request is always JSON
        HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {
            return TextMessageFormat.write(JSON.stringify(handshakeRequest));
        };
        HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {
            var responseMessage;
            var messageData;
            var remainingData;
            if (isArrayBuffer(data) || (typeof Buffer !== "undefined" && data instanceof Buffer)) {
                // Format is binary but still need to read JSON text from handshake response
                var binaryData = new Uint8Array(data);
                var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
                if (separatorIndex === -1) {
                    throw new Error("Message is incomplete.");
                }
                // content before separator is handshake response
                // optional content after is additional messages
                var responseLength = separatorIndex + 1;
                messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
                remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;
            }
            else {
                var textData = data;
                var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
                if (separatorIndex === -1) {
                    throw new Error("Message is incomplete.");
                }
                // content before separator is handshake response
                // optional content after is additional messages
                var responseLength = separatorIndex + 1;
                messageData = textData.substring(0, responseLength);
                remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;
            }
            // At this point we should have just the single handshake message
            var messages = TextMessageFormat.parse(messageData);
            var response = JSON.parse(messages[0]);
            if (response.type) {
                throw new Error("Expected a handshake response from the server.");
            }
            responseMessage = response;
            // multiple messages could have arrived with handshake
            // return additional data to be parsed as usual, or null if all parsed
            return [remainingData, responseMessage];
        };
        return HandshakeProtocol;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    /** Defines the type of a Hub Message. */
    var MessageType;
    (function (MessageType) {
        /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */
        MessageType[MessageType["Invocation"] = 1] = "Invocation";
        /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */
        MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
        /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */
        MessageType[MessageType["Completion"] = 3] = "Completion";
        /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */
        MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
        /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */
        MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
        /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */
        MessageType[MessageType["Ping"] = 6] = "Ping";
        /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */
        MessageType[MessageType["Close"] = 7] = "Close";
    })(MessageType || (MessageType = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    /** Stream implementation to stream items to the server. */
    var Subject = /** @class */ (function () {
        function Subject() {
            this.observers = [];
        }
        Subject.prototype.next = function (item) {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                observer.next(item);
            }
        };
        Subject.prototype.error = function (err) {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                if (observer.error) {
                    observer.error(err);
                }
            }
        };
        Subject.prototype.complete = function () {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                if (observer.complete) {
                    observer.complete();
                }
            }
        };
        Subject.prototype.subscribe = function (observer) {
            this.observers.push(observer);
            return new SubjectSubscription(this, observer);
        };
        return Subject;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
    var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
    /** Describes the current state of the {@link HubConnection} to the server. */
    var HubConnectionState;
    (function (HubConnectionState) {
        /** The hub connection is disconnected. */
        HubConnectionState["Disconnected"] = "Disconnected";
        /** The hub connection is connecting. */
        HubConnectionState["Connecting"] = "Connecting";
        /** The hub connection is connected. */
        HubConnectionState["Connected"] = "Connected";
        /** The hub connection is disconnecting. */
        HubConnectionState["Disconnecting"] = "Disconnecting";
        /** The hub connection is reconnecting. */
        HubConnectionState["Reconnecting"] = "Reconnecting";
    })(HubConnectionState || (HubConnectionState = {}));
    /** Represents a connection to a SignalR Hub. */
    var HubConnection = /** @class */ (function () {
        function HubConnection(connection, logger, protocol, reconnectPolicy) {
            var _this = this;
            Arg.isRequired(connection, "connection");
            Arg.isRequired(logger, "logger");
            Arg.isRequired(protocol, "protocol");
            this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
            this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
            this.logger = logger;
            this.protocol = protocol;
            this.connection = connection;
            this.reconnectPolicy = reconnectPolicy;
            this.handshakeProtocol = new HandshakeProtocol();
            this.connection.onreceive = function (data) { return _this.processIncomingData(data); };
            this.connection.onclose = function (error) { return _this.connectionClosed(error); };
            this.callbacks = {};
            this.methods = {};
            this.closedCallbacks = [];
            this.reconnectingCallbacks = [];
            this.reconnectedCallbacks = [];
            this.invocationId = 0;
            this.receivedHandshakeResponse = false;
            this.connectionState = HubConnectionState.Disconnected;
            this.connectionStarted = false;
            this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });
        }
        /** @internal */
        // Using a public static factory method means we can have a private constructor and an _internal_
        // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
        // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
        // public parameter-less constructor.
        HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {
            return new HubConnection(connection, logger, protocol, reconnectPolicy);
        };
        Object.defineProperty(HubConnection.prototype, "state", {
            /** Indicates the state of the {@link HubConnection} to the server. */
            get: function () {
                return this.connectionState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HubConnection.prototype, "connectionId", {
            /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either
             *  in the disconnected state or if the negotiation step was skipped.
             */
            get: function () {
                return this.connection ? (this.connection.connectionId || null) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HubConnection.prototype, "baseUrl", {
            /** Indicates the url of the {@link HubConnection} to the server. */
            get: function () {
                return this.connection.baseUrl || "";
            },
            /**
             * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or
             * Reconnecting states.
             * @param {string} url The url to connect to.
             */
            set: function (url) {
                if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {
                    throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
                }
                if (!url) {
                    throw new Error("The HubConnection url must be a valid url.");
                }
                this.connection.baseUrl = url;
            },
            enumerable: true,
            configurable: true
        });
        /** Starts the connection.
         *
         * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
         */
        HubConnection.prototype.start = function () {
            this.startPromise = this.startWithStateTransitions();
            return this.startPromise;
        };
        HubConnection.prototype.startWithStateTransitions = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var e_1;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.connectionState !== HubConnectionState.Disconnected) {
                                return [2 /*return*/, Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."))];
                            }
                            this.connectionState = HubConnectionState.Connecting;
                            this.logger.log(LogLevel.Debug, "Starting HubConnection.");
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.startInternal()];
                        case 2:
                            _a.sent();
                            this.connectionState = HubConnectionState.Connected;
                            this.connectionStarted = true;
                            this.logger.log(LogLevel.Debug, "HubConnection connected successfully.");
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            this.connectionState = HubConnectionState.Disconnected;
                            this.logger.log(LogLevel.Debug, "HubConnection failed to start successfully because of error '" + e_1 + "'.");
                            return [2 /*return*/, Promise.reject(e_1)];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.startInternal = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var handshakePromise, handshakeRequest, e_2;
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.stopDuringStartError = undefined;
                            this.receivedHandshakeResponse = false;
                            handshakePromise = new Promise(function (resolve, reject) {
                                _this.handshakeResolver = resolve;
                                _this.handshakeRejecter = reject;
                            });
                            return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 5, , 7]);
                            handshakeRequest = {
                                protocol: this.protocol.name,
                                version: this.protocol.version,
                            };
                            this.logger.log(LogLevel.Debug, "Sending handshake request.");
                            return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];
                        case 3:
                            _a.sent();
                            this.logger.log(LogLevel.Information, "Using HubProtocol '" + this.protocol.name + "'.");
                            // defensively cleanup timeout in case we receive a message from the server before we finish start
                            this.cleanupTimeout();
                            this.resetTimeoutPeriod();
                            this.resetKeepAliveInterval();
                            return [4 /*yield*/, handshakePromise];
                        case 4:
                            _a.sent();
                            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise
                            // being rejected on close, because this continuation can run after both the handshake completed successfully
                            // and the connection was closed.
                            if (this.stopDuringStartError) {
                                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state
                                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise
                                // will cause the calling continuation to get scheduled to run later.
                                throw this.stopDuringStartError;
                            }
                            return [3 /*break*/, 7];
                        case 5:
                            e_2 = _a.sent();
                            this.logger.log(LogLevel.Debug, "Hub handshake failed with error '" + e_2 + "' during start(). Stopping HubConnection.");
                            this.cleanupTimeout();
                            this.cleanupPingTimer();
                            // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
                            return [4 /*yield*/, this.connection.stop(e_2)];
                        case 6:
                            // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
                            _a.sent();
                            throw e_2;
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        /** Stops the connection.
         *
         * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
         */
        HubConnection.prototype.stop = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var startPromise, e_3;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            startPromise = this.startPromise;
                            this.stopPromise = this.stopInternal();
                            return [4 /*yield*/, this.stopPromise];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            // Awaiting undefined continues immediately
                            return [4 /*yield*/, startPromise];
                        case 3:
                            // Awaiting undefined continues immediately
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            e_3 = _a.sent();
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.stopInternal = function (error) {
            if (this.connectionState === HubConnectionState.Disconnected) {
                this.logger.log(LogLevel.Debug, "Call to HubConnection.stop(" + error + ") ignored because it is already in the disconnected state.");
                return Promise.resolve();
            }
            if (this.connectionState === HubConnectionState.Disconnecting) {
                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
                return this.stopPromise;
            }
            this.connectionState = HubConnectionState.Disconnecting;
            this.logger.log(LogLevel.Debug, "Stopping HubConnection.");
            if (this.reconnectDelayHandle) {
                // We're in a reconnect delay which means the underlying connection is currently already stopped.
                // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and
                // fire the onclose callbacks.
                this.logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
                clearTimeout(this.reconnectDelayHandle);
                this.reconnectDelayHandle = undefined;
                this.completeClose();
                return Promise.resolve();
            }
            this.cleanupTimeout();
            this.cleanupPingTimer();
            this.stopDuringStartError = error || new Error("The connection was stopped before the hub handshake could complete.");
            // HttpConnection.stop() should not complete until after either HttpConnection.start() fails
            // or the onclose callback is invoked. The onclose callback will transition the HubConnection
            // to the disconnected state if need be before HttpConnection.stop() completes.
            return this.connection.stop(error);
        };
        /** Invokes a streaming hub method on the server using the specified name and arguments.
         *
         * @typeparam T The type of the items returned by the server.
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
         */
        HubConnection.prototype.stream = function (methodName) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);
            var promiseQueue;
            var subject = new Subject();
            subject.cancelCallback = function () {
                var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);
                delete _this.callbacks[invocationDescriptor.invocationId];
                return promiseQueue.then(function () {
                    return _this.sendWithProtocol(cancelInvocation);
                });
            };
            this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
                if (error) {
                    subject.error(error);
                    return;
                }
                else if (invocationEvent) {
                    // invocationEvent will not be null when an error is not passed to the callback
                    if (invocationEvent.type === MessageType.Completion) {
                        if (invocationEvent.error) {
                            subject.error(new Error(invocationEvent.error));
                        }
                        else {
                            subject.complete();
                        }
                    }
                    else {
                        subject.next((invocationEvent.item));
                    }
                }
            };
            promiseQueue = this.sendWithProtocol(invocationDescriptor)
                .catch(function (e) {
                subject.error(e);
                delete _this.callbacks[invocationDescriptor.invocationId];
            });
            this.launchStreams(streams, promiseQueue);
            return subject;
        };
        HubConnection.prototype.sendMessage = function (message) {
            this.resetKeepAliveInterval();
            return this.connection.send(message);
        };
        /**
         * Sends a js object to the server.
         * @param message The js object to serialize and send.
         */
        HubConnection.prototype.sendWithProtocol = function (message) {
            return this.sendMessage(this.protocol.writeMessage(message));
        };
        /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
         *
         * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
         * be processing the invocation.
         *
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
         */
        HubConnection.prototype.send = function (methodName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));
            this.launchStreams(streams, sendPromise);
            return sendPromise;
        };
        /** Invokes a hub method on the server using the specified name and arguments.
         *
         * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
         * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
         * resolving the Promise.
         *
         * @typeparam T The expected return type.
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
         */
        HubConnection.prototype.invoke = function (methodName) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);
            var p = new Promise(function (resolve, reject) {
                // invocationId will always have a value for a non-blocking invocation
                _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
                    if (error) {
                        reject(error);
                        return;
                    }
                    else if (invocationEvent) {
                        // invocationEvent will not be null when an error is not passed to the callback
                        if (invocationEvent.type === MessageType.Completion) {
                            if (invocationEvent.error) {
                                reject(new Error(invocationEvent.error));
                            }
                            else {
                                resolve(invocationEvent.result);
                            }
                        }
                        else {
                            reject(new Error("Unexpected message type: " + invocationEvent.type));
                        }
                    }
                };
                var promiseQueue = _this.sendWithProtocol(invocationDescriptor)
                    .catch(function (e) {
                    reject(e);
                    // invocationId will always have a value for a non-blocking invocation
                    delete _this.callbacks[invocationDescriptor.invocationId];
                });
                _this.launchStreams(streams, promiseQueue);
            });
            return p;
        };
        /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.
         *
         * @param {string} methodName The name of the hub method to define.
         * @param {Function} newMethod The handler that will be raised when the hub method is invoked.
         */
        HubConnection.prototype.on = function (methodName, newMethod) {
            if (!methodName || !newMethod) {
                return;
            }
            methodName = methodName.toLowerCase();
            if (!this.methods[methodName]) {
                this.methods[methodName] = [];
            }
            // Preventing adding the same handler multiple times.
            if (this.methods[methodName].indexOf(newMethod) !== -1) {
                return;
            }
            this.methods[methodName].push(newMethod);
        };
        HubConnection.prototype.off = function (methodName, method) {
            if (!methodName) {
                return;
            }
            methodName = methodName.toLowerCase();
            var handlers = this.methods[methodName];
            if (!handlers) {
                return;
            }
            if (method) {
                var removeIdx = handlers.indexOf(method);
                if (removeIdx !== -1) {
                    handlers.splice(removeIdx, 1);
                    if (handlers.length === 0) {
                        delete this.methods[methodName];
                    }
                }
            }
            else {
                delete this.methods[methodName];
            }
        };
        /** Registers a handler that will be invoked when the connection is closed.
         *
         * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
         */
        HubConnection.prototype.onclose = function (callback) {
            if (callback) {
                this.closedCallbacks.push(callback);
            }
        };
        /** Registers a handler that will be invoked when the connection starts reconnecting.
         *
         * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).
         */
        HubConnection.prototype.onreconnecting = function (callback) {
            if (callback) {
                this.reconnectingCallbacks.push(callback);
            }
        };
        /** Registers a handler that will be invoked when the connection successfully reconnects.
         *
         * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.
         */
        HubConnection.prototype.onreconnected = function (callback) {
            if (callback) {
                this.reconnectedCallbacks.push(callback);
            }
        };
        HubConnection.prototype.processIncomingData = function (data) {
            this.cleanupTimeout();
            if (!this.receivedHandshakeResponse) {
                data = this.processHandshakeResponse(data);
                this.receivedHandshakeResponse = true;
            }
            // Data may have all been read when processing handshake response
            if (data) {
                // Parse the messages
                var messages = this.protocol.parseMessages(data, this.logger);
                for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                    var message = messages_1[_i];
                    switch (message.type) {
                        case MessageType.Invocation:
                            this.invokeClientMethod(message);
                            break;
                        case MessageType.StreamItem:
                        case MessageType.Completion:
                            var callback = this.callbacks[message.invocationId];
                            if (callback) {
                                if (message.type === MessageType.Completion) {
                                    delete this.callbacks[message.invocationId];
                                }
                                callback(message);
                            }
                            break;
                        case MessageType.Ping:
                            // Don't care about pings
                            break;
                        case MessageType.Close:
                            this.logger.log(LogLevel.Information, "Close message received from server.");
                            var error = message.error ? new Error("Server returned an error on close: " + message.error) : undefined;
                            if (message.allowReconnect === true) {
                                // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,
                                // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.
                                // tslint:disable-next-line:no-floating-promises
                                this.connection.stop(error);
                            }
                            else {
                                // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.
                                this.stopPromise = this.stopInternal(error);
                            }
                            break;
                        default:
                            this.logger.log(LogLevel.Warning, "Invalid message type: " + message.type + ".");
                            break;
                    }
                }
            }
            this.resetTimeoutPeriod();
        };
        HubConnection.prototype.processHandshakeResponse = function (data) {
            var _a;
            var responseMessage;
            var remainingData;
            try {
                _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
            }
            catch (e) {
                var message = "Error parsing handshake response: " + e;
                this.logger.log(LogLevel.Error, message);
                var error = new Error(message);
                this.handshakeRejecter(error);
                throw error;
            }
            if (responseMessage.error) {
                var message = "Server returned handshake error: " + responseMessage.error;
                this.logger.log(LogLevel.Error, message);
                var error = new Error(message);
                this.handshakeRejecter(error);
                throw error;
            }
            else {
                this.logger.log(LogLevel.Debug, "Server handshake complete.");
            }
            this.handshakeResolver();
            return remainingData;
        };
        HubConnection.prototype.resetKeepAliveInterval = function () {
            var _this = this;
            this.cleanupPingTimer();
            this.pingServerHandle = setTimeout(function () { return __awaiter$1(_this, void 0, void 0, function () {
                var _a;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _a = _b.sent();
                            // We don't care about the error. It should be seen elsewhere in the client.
                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering
                            this.cleanupPingTimer();
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); }, this.keepAliveIntervalInMilliseconds);
        };
        HubConnection.prototype.resetTimeoutPeriod = function () {
            var _this = this;
            if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
                // Set the timeout timer
                this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);
            }
        };
        HubConnection.prototype.serverTimeout = function () {
            // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
            // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        };
        HubConnection.prototype.invokeClientMethod = function (invocationMessage) {
            var _this = this;
            var methods = this.methods[invocationMessage.target.toLowerCase()];
            if (methods) {
                try {
                    methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "A callback for the method " + invocationMessage.target.toLowerCase() + " threw error '" + e + "'.");
                }
                if (invocationMessage.invocationId) {
                    // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.
                    var message = "Server requested a response, which is not supported in this version of the client.";
                    this.logger.log(LogLevel.Error, message);
                    // We don't want to wait on the stop itself.
                    this.stopPromise = this.stopInternal(new Error(message));
                }
            }
            else {
                this.logger.log(LogLevel.Warning, "No client method with the name '" + invocationMessage.target + "' found.");
            }
        };
        HubConnection.prototype.connectionClosed = function (error) {
            this.logger.log(LogLevel.Debug, "HubConnection.connectionClosed(" + error + ") called while in state " + this.connectionState + ".");
            // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.
            this.stopDuringStartError = this.stopDuringStartError || error || new Error("The underlying connection was closed before the hub handshake could complete.");
            // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.
            // If it has already completed, this should just noop.
            if (this.handshakeResolver) {
                this.handshakeResolver();
            }
            this.cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
            this.cleanupTimeout();
            this.cleanupPingTimer();
            if (this.connectionState === HubConnectionState.Disconnecting) {
                this.completeClose(error);
            }
            else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {
                // tslint:disable-next-line:no-floating-promises
                this.reconnect(error);
            }
            else if (this.connectionState === HubConnectionState.Connected) {
                this.completeClose(error);
            }
            // If none of the above if conditions were true were called the HubConnection must be in either:
            // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.
            // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt
            //    and potentially continue the reconnect() loop.
            // 3. The Disconnected state in which case we're already done.
        };
        HubConnection.prototype.completeClose = function (error) {
            var _this = this;
            if (this.connectionStarted) {
                this.connectionState = HubConnectionState.Disconnected;
                this.connectionStarted = false;
                try {
                    this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "An onclose callback called with error '" + error + "' threw error '" + e + "'.");
                }
            }
        };
        HubConnection.prototype.reconnect = function (error) {
            return __awaiter$1(this, void 0, void 0, function () {
                var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            reconnectStartTime = Date.now();
                            previousReconnectAttempts = 0;
                            retryError = error !== undefined ? error : new Error("Attempting to reconnect due to a unknown error.");
                            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);
                            if (nextRetryDelay === null) {
                                this.logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
                                this.completeClose(error);
                                return [2 /*return*/];
                            }
                            this.connectionState = HubConnectionState.Reconnecting;
                            if (error) {
                                this.logger.log(LogLevel.Information, "Connection reconnecting because of error '" + error + "'.");
                            }
                            else {
                                this.logger.log(LogLevel.Information, "Connection reconnecting.");
                            }
                            if (this.onreconnecting) {
                                try {
                                    this.reconnectingCallbacks.forEach(function (c) { return c.apply(_this, [error]); });
                                }
                                catch (e) {
                                    this.logger.log(LogLevel.Error, "An onreconnecting callback called with error '" + error + "' threw error '" + e + "'.");
                                }
                                // Exit early if an onreconnecting callback called connection.stop().
                                if (this.connectionState !== HubConnectionState.Reconnecting) {
                                    this.logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                                    return [2 /*return*/];
                                }
                            }
                            _a.label = 1;
                        case 1:
                            if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];
                            this.logger.log(LogLevel.Information, "Reconnect attempt number " + previousReconnectAttempts + " will start in " + nextRetryDelay + " ms.");
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);
                                })];
                        case 2:
                            _a.sent();
                            this.reconnectDelayHandle = undefined;
                            if (this.connectionState !== HubConnectionState.Reconnecting) {
                                this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                                return [2 /*return*/];
                            }
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, this.startInternal()];
                        case 4:
                            _a.sent();
                            this.connectionState = HubConnectionState.Connected;
                            this.logger.log(LogLevel.Information, "HubConnection reconnected successfully.");
                            if (this.onreconnected) {
                                try {
                                    this.reconnectedCallbacks.forEach(function (c) { return c.apply(_this, [_this.connection.connectionId]); });
                                }
                                catch (e) {
                                    this.logger.log(LogLevel.Error, "An onreconnected callback called with connectionId '" + this.connection.connectionId + "; threw error '" + e + "'.");
                                }
                            }
                            return [2 /*return*/];
                        case 5:
                            e_4 = _a.sent();
                            this.logger.log(LogLevel.Information, "Reconnect attempt failed because of error '" + e_4 + "'.");
                            if (this.connectionState !== HubConnectionState.Reconnecting) {
                                this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect attempt. Done reconnecting.");
                                return [2 /*return*/];
                            }
                            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());
                            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
                            return [3 /*break*/, 6];
                        case 6: return [3 /*break*/, 1];
                        case 7:
                            this.logger.log(LogLevel.Information, "Reconnect retries have been exhausted after " + (Date.now() - reconnectStartTime) + " ms and " + previousReconnectAttempts + " failed attempts. Connection disconnecting.");
                            this.completeClose();
                            return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {
            try {
                return this.reconnectPolicy.nextRetryDelayInMilliseconds({
                    elapsedMilliseconds: elapsedMilliseconds,
                    previousRetryCount: previousRetryCount,
                    retryReason: retryReason,
                });
            }
            catch (e) {
                this.logger.log(LogLevel.Error, "IRetryPolicy.nextRetryDelayInMilliseconds(" + previousRetryCount + ", " + elapsedMilliseconds + ") threw error '" + e + "'.");
                return null;
            }
        };
        HubConnection.prototype.cancelCallbacksWithError = function (error) {
            var callbacks = this.callbacks;
            this.callbacks = {};
            Object.keys(callbacks)
                .forEach(function (key) {
                var callback = callbacks[key];
                callback(null, error);
            });
        };
        HubConnection.prototype.cleanupPingTimer = function () {
            if (this.pingServerHandle) {
                clearTimeout(this.pingServerHandle);
            }
        };
        HubConnection.prototype.cleanupTimeout = function () {
            if (this.timeoutHandle) {
                clearTimeout(this.timeoutHandle);
            }
        };
        HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {
            if (nonblocking) {
                return {
                    arguments: args,
                    streamIds: streamIds,
                    target: methodName,
                    type: MessageType.Invocation,
                };
            }
            else {
                var invocationId = this.invocationId;
                this.invocationId++;
                return {
                    arguments: args,
                    invocationId: invocationId.toString(),
                    streamIds: streamIds,
                    target: methodName,
                    type: MessageType.Invocation,
                };
            }
        };
        HubConnection.prototype.launchStreams = function (streams, promiseQueue) {
            var _this = this;
            if (streams.length === 0) {
                return;
            }
            // Synchronize stream data so they arrive in-order on the server
            if (!promiseQueue) {
                promiseQueue = Promise.resolve();
            }
            var _loop_1 = function (streamId) {
                streams[streamId].subscribe({
                    complete: function () {
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId)); });
                    },
                    error: function (err) {
                        var message;
                        if (err instanceof Error) {
                            message = err.message;
                        }
                        else if (err && err.toString) {
                            message = err.toString();
                        }
                        else {
                            message = "Unknown error";
                        }
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message)); });
                    },
                    next: function (item) {
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item)); });
                    },
                });
            };
            // We want to iterate over the keys, since the keys are the stream ids
            // tslint:disable-next-line:forin
            for (var streamId in streams) {
                _loop_1(streamId);
            }
        };
        HubConnection.prototype.replaceStreamingParams = function (args) {
            var streams = [];
            var streamIds = [];
            for (var i = 0; i < args.length; i++) {
                var argument = args[i];
                if (this.isObservable(argument)) {
                    var streamId = this.invocationId;
                    this.invocationId++;
                    // Store the stream for later use
                    streams[streamId] = argument;
                    streamIds.push(streamId.toString());
                    // remove stream from args
                    args.splice(i, 1);
                }
            }
            return [streams, streamIds];
        };
        HubConnection.prototype.isObservable = function (arg) {
            // This allows other stream implementations to just work (like rxjs)
            return arg && arg.subscribe && typeof arg.subscribe === "function";
        };
        HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {
            var invocationId = this.invocationId;
            this.invocationId++;
            return {
                arguments: args,
                invocationId: invocationId.toString(),
                streamIds: streamIds,
                target: methodName,
                type: MessageType.StreamInvocation,
            };
        };
        HubConnection.prototype.createCancelInvocation = function (id) {
            return {
                invocationId: id,
                type: MessageType.CancelInvocation,
            };
        };
        HubConnection.prototype.createStreamItemMessage = function (id, item) {
            return {
                invocationId: id,
                item: item,
                type: MessageType.StreamItem,
            };
        };
        HubConnection.prototype.createCompletionMessage = function (id, error, result) {
            if (error) {
                return {
                    error: error,
                    invocationId: id,
                    type: MessageType.Completion,
                };
            }
            return {
                invocationId: id,
                result: result,
                type: MessageType.Completion,
            };
        };
        return HubConnection;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // 0, 2, 10, 30 second delays before reconnect attempts.
    var DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];
    /** @private */
    var DefaultReconnectPolicy = /** @class */ (function () {
        function DefaultReconnectPolicy(retryDelays) {
            this.retryDelays = retryDelays !== undefined ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
        }
        DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {
            return this.retryDelays[retryContext.previousRetryCount];
        };
        return DefaultReconnectPolicy;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // This will be treated as a bit flag in the future, so we keep it using power-of-two values.
    /** Specifies a specific HTTP transport type. */
    var HttpTransportType;
    (function (HttpTransportType) {
        /** Specifies no transport preference. */
        HttpTransportType[HttpTransportType["None"] = 0] = "None";
        /** Specifies the WebSockets transport. */
        HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
        /** Specifies the Server-Sent Events transport. */
        HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
        /** Specifies the Long Polling transport. */
        HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
    })(HttpTransportType || (HttpTransportType = {}));
    /** Specifies the transfer format for a connection. */
    var TransferFormat;
    (function (TransferFormat) {
        /** Specifies that only text data will be transmitted over the connection. */
        TransferFormat[TransferFormat["Text"] = 1] = "Text";
        /** Specifies that binary data will be transmitted over the connection. */
        TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
    })(TransferFormat || (TransferFormat = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController
    // We don't actually ever use the API being polyfilled, we always use the polyfill because
    // it's a very new API right now.
    // Not exported from index.
    /** @private */
    var AbortController = /** @class */ (function () {
        function AbortController() {
            this.isAborted = false;
            this.onabort = null;
        }
        AbortController.prototype.abort = function () {
            if (!this.isAborted) {
                this.isAborted = true;
                if (this.onabort) {
                    this.onabort();
                }
            }
        };
        Object.defineProperty(AbortController.prototype, "signal", {
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbortController.prototype, "aborted", {
            get: function () {
                return this.isAborted;
            },
            enumerable: true,
            configurable: true
        });
        return AbortController;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    // Not exported from 'index', this type is internal.
    /** @private */
    var LongPollingTransport = /** @class */ (function () {
        function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent) {
            this.httpClient = httpClient;
            this.accessTokenFactory = accessTokenFactory;
            this.logger = logger;
            this.pollAbort = new AbortController();
            this.logMessageContent = logMessageContent;
            this.running = false;
            this.onreceive = null;
            this.onclose = null;
        }
        Object.defineProperty(LongPollingTransport.prototype, "pollAborted", {
            // This is an internal type, not exported from 'index' so this is really just internal.
            get: function () {
                return this.pollAbort.aborted;
            },
            enumerable: true,
            configurable: true
        });
        LongPollingTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$2(this, void 0, void 0, function () {
                var pollOptions, token, pollUrl, response;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.url = url;
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
                            // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)
                            if (transferFormat === TransferFormat.Binary &&
                                (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
                                throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                            }
                            pollOptions = {
                                abortSignal: this.pollAbort.signal,
                                headers: {},
                                timeout: 100000,
                            };
                            if (transferFormat === TransferFormat.Binary) {
                                pollOptions.responseType = "arraybuffer";
                            }
                            return [4 /*yield*/, this.getAccessToken()];
                        case 1:
                            token = _a.sent();
                            this.updateHeaderToken(pollOptions, token);
                            pollUrl = url + "&_=" + Date.now();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                            return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                        case 2:
                            response = _a.sent();
                            if (response.statusCode !== 200) {
                                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                                // Mark running as false so that the poll immediately ends and runs the close logic
                                this.closeError = new HttpError(response.statusText || "", response.statusCode);
                                this.running = false;
                            }
                            else {
                                this.running = true;
                            }
                            this.receiving = this.poll(this.url, pollOptions);
                            return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.getAccessToken = function () {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1: return [2 /*return*/, _a.sent()];
                        case 2: return [2 /*return*/, null];
                    }
                });
            });
        };
        LongPollingTransport.prototype.updateHeaderToken = function (request, token) {
            if (!request.headers) {
                request.headers = {};
            }
            if (token) {
                // tslint:disable-next-line:no-string-literal
                request.headers["Authorization"] = "Bearer " + token;
                return;
            }
            // tslint:disable-next-line:no-string-literal
            if (request.headers["Authorization"]) {
                // tslint:disable-next-line:no-string-literal
                delete request.headers["Authorization"];
            }
        };
        LongPollingTransport.prototype.poll = function (url, pollOptions) {
            return __awaiter$2(this, void 0, void 0, function () {
                var token, pollUrl, response, e_1;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, , 8, 9]);
                            _a.label = 1;
                        case 1:
                            if (!this.running) return [3 /*break*/, 7];
                            return [4 /*yield*/, this.getAccessToken()];
                        case 2:
                            token = _a.sent();
                            this.updateHeaderToken(pollOptions, token);
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 5, , 6]);
                            pollUrl = url + "&_=" + Date.now();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                            return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                        case 4:
                            response = _a.sent();
                            if (response.statusCode === 204) {
                                this.logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
                                this.running = false;
                            }
                            else if (response.statusCode !== 200) {
                                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                                // Unexpected status code
                                this.closeError = new HttpError(response.statusText || "", response.statusCode);
                                this.running = false;
                            }
                            else {
                                // Process the response
                                if (response.content) {
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) data received. " + getDataDetail(response.content, this.logMessageContent) + ".");
                                    if (this.onreceive) {
                                        this.onreceive(response.content);
                                    }
                                }
                                else {
                                    // This is another way timeout manifest.
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                                }
                            }
                            return [3 /*break*/, 6];
                        case 5:
                            e_1 = _a.sent();
                            if (!this.running) {
                                // Log but disregard errors that occur after stopping
                                this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
                            }
                            else {
                                if (e_1 instanceof TimeoutError) {
                                    // Ignore timeouts and reissue the poll.
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                                }
                                else {
                                    // Close the connection with the error as the result.
                                    this.closeError = e_1;
                                    this.running = false;
                                }
                            }
                            return [3 /*break*/, 6];
                        case 6: return [3 /*break*/, 1];
                        case 7: return [3 /*break*/, 9];
                        case 8:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.");
                            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.
                            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.
                            if (!this.pollAborted) {
                                this.raiseOnClose();
                            }
                            return [7 /*endfinally*/];
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.send = function (data) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    if (!this.running) {
                        return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                    }
                    return [2 /*return*/, sendMessage(this.logger, "LongPolling", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
                });
            });
        };
        LongPollingTransport.prototype.stop = function () {
            return __awaiter$2(this, void 0, void 0, function () {
                var deleteOptions, token;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
                            // Tell receiving loop to stop, abort any current request, and then wait for it to finish
                            this.running = false;
                            this.pollAbort.abort();
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 5, 6]);
                            return [4 /*yield*/, this.receiving];
                        case 2:
                            _a.sent();
                            // Send DELETE to clean up long polling on the server
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
                            deleteOptions = {
                                headers: {},
                            };
                            return [4 /*yield*/, this.getAccessToken()];
                        case 3:
                            token = _a.sent();
                            this.updateHeaderToken(deleteOptions, token);
                            return [4 /*yield*/, this.httpClient.delete(this.url, deleteOptions)];
                        case 4:
                            _a.sent();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.");
                            return [3 /*break*/, 6];
                        case 5:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
                            // Raise close event here instead of in polling
                            // It needs to happen after the DELETE request is sent
                            this.raiseOnClose();
                            return [7 /*endfinally*/];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.raiseOnClose = function () {
            if (this.onclose) {
                var logMessage = "(LongPolling transport) Firing onclose event.";
                if (this.closeError) {
                    logMessage += " Error: " + this.closeError;
                }
                this.logger.log(LogLevel.Trace, logMessage);
                this.onclose(this.closeError);
            }
        };
        return LongPollingTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var ServerSentEventsTransport = /** @class */ (function () {
        function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor) {
            this.httpClient = httpClient;
            this.accessTokenFactory = accessTokenFactory;
            this.logger = logger;
            this.logMessageContent = logMessageContent;
            this.eventSourceConstructor = eventSourceConstructor;
            this.onreceive = null;
            this.onclose = null;
        }
        ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$3(this, void 0, void 0, function () {
                var token;
                var _this = this;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Trace, "(SSE transport) Connecting.");
                            // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send
                            this.url = url;
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _a.sent();
                            if (token) {
                                url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                            }
                            _a.label = 2;
                        case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                                var opened = false;
                                if (transferFormat !== TransferFormat.Text) {
                                    reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                                    return;
                                }
                                var eventSource;
                                if (Platform.isBrowser || Platform.isWebWorker) {
                                    eventSource = new _this.eventSourceConstructor(url, { withCredentials: true });
                                }
                                else {
                                    // Non-browser passes cookies via the dictionary
                                    var cookies = _this.httpClient.getCookieString(url);
                                    eventSource = new _this.eventSourceConstructor(url, { withCredentials: true, headers: { Cookie: cookies } });
                                }
                                try {
                                    eventSource.onmessage = function (e) {
                                        if (_this.onreceive) {
                                            try {
                                                _this.logger.log(LogLevel.Trace, "(SSE transport) data received. " + getDataDetail(e.data, _this.logMessageContent) + ".");
                                                _this.onreceive(e.data);
                                            }
                                            catch (error) {
                                                _this.close(error);
                                                return;
                                            }
                                        }
                                    };
                                    eventSource.onerror = function (e) {
                                        var error = new Error(e.data || "Error occurred");
                                        if (opened) {
                                            _this.close(error);
                                        }
                                        else {
                                            reject(error);
                                        }
                                    };
                                    eventSource.onopen = function () {
                                        _this.logger.log(LogLevel.Information, "SSE connected to " + _this.url);
                                        _this.eventSource = eventSource;
                                        opened = true;
                                        resolve();
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                    return;
                                }
                            })];
                    }
                });
            });
        };
        ServerSentEventsTransport.prototype.send = function (data) {
            return __awaiter$3(this, void 0, void 0, function () {
                return __generator$3(this, function (_a) {
                    if (!this.eventSource) {
                        return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                    }
                    return [2 /*return*/, sendMessage(this.logger, "SSE", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
                });
            });
        };
        ServerSentEventsTransport.prototype.stop = function () {
            this.close();
            return Promise.resolve();
        };
        ServerSentEventsTransport.prototype.close = function (e) {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = undefined;
                if (this.onclose) {
                    this.onclose(e);
                }
            }
        };
        return ServerSentEventsTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var WebSocketTransport = /** @class */ (function () {
        function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {
            this.logger = logger;
            this.accessTokenFactory = accessTokenFactory;
            this.logMessageContent = logMessageContent;
            this.webSocketConstructor = webSocketConstructor;
            this.httpClient = httpClient;
            this.onreceive = null;
            this.onclose = null;
        }
        WebSocketTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$4(this, void 0, void 0, function () {
                var token;
                var _this = this;
                return __generator$4(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _a.sent();
                            if (token) {
                                url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                            }
                            _a.label = 2;
                        case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                                url = url.replace(/^http/, "ws");
                                var webSocket;
                                var cookies = _this.httpClient.getCookieString(url);
                                var opened = false;
                                if (Platform.isNode && cookies) {
                                    // Only pass cookies when in non-browser environments
                                    webSocket = new _this.webSocketConstructor(url, undefined, {
                                        headers: {
                                            Cookie: "" + cookies,
                                        },
                                    });
                                }
                                if (!webSocket) {
                                    // Chrome is not happy with passing 'undefined' as protocol
                                    webSocket = new _this.webSocketConstructor(url);
                                }
                                if (transferFormat === TransferFormat.Binary) {
                                    webSocket.binaryType = "arraybuffer";
                                }
                                // tslint:disable-next-line:variable-name
                                webSocket.onopen = function (_event) {
                                    _this.logger.log(LogLevel.Information, "WebSocket connected to " + url + ".");
                                    _this.webSocket = webSocket;
                                    opened = true;
                                    resolve();
                                };
                                webSocket.onerror = function (event) {
                                    var error = null;
                                    // ErrorEvent is a browser only type we need to check if the type exists before using it
                                    if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                                        error = event.error;
                                    }
                                    else {
                                        error = new Error("There was an error with the transport.");
                                    }
                                    reject(error);
                                };
                                webSocket.onmessage = function (message) {
                                    _this.logger.log(LogLevel.Trace, "(WebSockets transport) data received. " + getDataDetail(message.data, _this.logMessageContent) + ".");
                                    if (_this.onreceive) {
                                        _this.onreceive(message.data);
                                    }
                                };
                                webSocket.onclose = function (event) {
                                    // Don't call close handler if connection was never established
                                    // We'll reject the connect call instead
                                    if (opened) {
                                        _this.close(event);
                                    }
                                    else {
                                        var error = null;
                                        // ErrorEvent is a browser only type we need to check if the type exists before using it
                                        if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                                            error = event.error;
                                        }
                                        else {
                                            error = new Error("There was an error with the transport.");
                                        }
                                        reject(error);
                                    }
                                };
                            })];
                    }
                });
            });
        };
        WebSocketTransport.prototype.send = function (data) {
            if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
                this.logger.log(LogLevel.Trace, "(WebSockets transport) sending data. " + getDataDetail(data, this.logMessageContent) + ".");
                this.webSocket.send(data);
                return Promise.resolve();
            }
            return Promise.reject("WebSocket is not in the OPEN state");
        };
        WebSocketTransport.prototype.stop = function () {
            if (this.webSocket) {
                // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
                // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
                this.close(undefined);
            }
            return Promise.resolve();
        };
        WebSocketTransport.prototype.close = function (event) {
            // webSocket will be null if the transport did not start successfully
            if (this.webSocket) {
                // Clear websocket handlers because we are considering the socket closed now
                this.webSocket.onclose = function () { };
                this.webSocket.onmessage = function () { };
                this.webSocket.onerror = function () { };
                this.webSocket.close();
                this.webSocket = undefined;
            }
            this.logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
            if (this.onclose) {
                if (event && (event.wasClean === false || event.code !== 1000)) {
                    this.onclose(new Error("WebSocket closed with status code: " + event.code + " (" + event.reason + ")."));
                }
                else {
                    this.onclose();
                }
            }
        };
        return WebSocketTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$5 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var MAX_REDIRECTS = 100;
    var WebSocketModule = null;
    var EventSourceModule = null;
    if (Platform.isNode && typeof require !== "undefined") {
        // In order to ignore the dynamic require in webpack builds we need to do this magic
        // @ts-ignore: TS doesn't know about these names
        var requireFunc$1 = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        WebSocketModule = requireFunc$1("ws");
        EventSourceModule = requireFunc$1("eventsource");
    }
    /** @private */
    var HttpConnection = /** @class */ (function () {
        function HttpConnection(url, options) {
            if (options === void 0) { options = {}; }
            this.features = {};
            this.negotiateVersion = 1;
            Arg.isRequired(url, "url");
            this.logger = createLogger(options.logger);
            this.baseUrl = this.resolveUrl(url);
            options = options || {};
            options.logMessageContent = options.logMessageContent || false;
            if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
                options.WebSocket = WebSocket;
            }
            else if (Platform.isNode && !options.WebSocket) {
                if (WebSocketModule) {
                    options.WebSocket = WebSocketModule;
                }
            }
            if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
                options.EventSource = EventSource;
            }
            else if (Platform.isNode && !options.EventSource) {
                if (typeof EventSourceModule !== "undefined") {
                    options.EventSource = EventSourceModule;
                }
            }
            this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);
            this.connectionState = "Disconnected" /* Disconnected */;
            this.connectionStarted = false;
            this.options = options;
            this.onreceive = null;
            this.onclose = null;
        }
        HttpConnection.prototype.start = function (transferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var message, message;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            transferFormat = transferFormat || TransferFormat.Binary;
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Debug, "Starting connection with transfer format '" + TransferFormat[transferFormat] + "'.");
                            if (this.connectionState !== "Disconnected" /* Disconnected */) {
                                return [2 /*return*/, Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."))];
                            }
                            this.connectionState = "Connecting " /* Connecting */;
                            this.startInternalPromise = this.startInternal(transferFormat);
                            return [4 /*yield*/, this.startInternalPromise];
                        case 1:
                            _a.sent();
                            if (!(this.connectionState === "Disconnecting" /* Disconnecting */)) return [3 /*break*/, 3];
                            message = "Failed to start the HttpConnection before stop() was called.";
                            this.logger.log(LogLevel.Error, message);
                            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
                            return [4 /*yield*/, this.stopPromise];
                        case 2:
                            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
                            _a.sent();
                            return [2 /*return*/, Promise.reject(new Error(message))];
                        case 3:
                            if (this.connectionState !== "Connected" /* Connected */) {
                                message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
                                this.logger.log(LogLevel.Error, message);
                                return [2 /*return*/, Promise.reject(new Error(message))];
                            }
                            _a.label = 4;
                        case 4:
                            this.connectionStarted = true;
                            return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.send = function (data) {
            if (this.connectionState !== "Connected" /* Connected */) {
                return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
            }
            if (!this.sendQueue) {
                this.sendQueue = new TransportSendQueue(this.transport);
            }
            // Transport will not be null if state is connected
            return this.sendQueue.send(data);
        };
        HttpConnection.prototype.stop = function (error) {
            return __awaiter$5(this, void 0, void 0, function () {
                var _this = this;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.connectionState === "Disconnected" /* Disconnected */) {
                                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnected state.");
                                return [2 /*return*/, Promise.resolve()];
                            }
                            if (this.connectionState === "Disconnecting" /* Disconnecting */) {
                                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
                                return [2 /*return*/, this.stopPromise];
                            }
                            this.connectionState = "Disconnecting" /* Disconnecting */;
                            this.stopPromise = new Promise(function (resolve) {
                                // Don't complete stop() until stopConnection() completes.
                                _this.stopPromiseResolver = resolve;
                            });
                            // stopInternal should never throw so just observe it.
                            return [4 /*yield*/, this.stopInternal(error)];
                        case 1:
                            // stopInternal should never throw so just observe it.
                            _a.sent();
                            return [4 /*yield*/, this.stopPromise];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.stopInternal = function (error) {
            return __awaiter$5(this, void 0, void 0, function () {
                var e_1, e_2;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Set error as soon as possible otherwise there is a race between
                            // the transport closing and providing an error and the error from a close message
                            // We would prefer the close message error.
                            this.stopError = error;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.startInternalPromise];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            return [3 /*break*/, 4];
                        case 4:
                            if (!this.transport) return [3 /*break*/, 9];
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, this.transport.stop()];
                        case 6:
                            _a.sent();
                            return [3 /*break*/, 8];
                        case 7:
                            e_2 = _a.sent();
                            this.logger.log(LogLevel.Error, "HttpConnection.transport.stop() threw error '" + e_2 + "'.");
                            this.stopConnection();
                            return [3 /*break*/, 8];
                        case 8:
                            this.transport = undefined;
                            return [3 /*break*/, 10];
                        case 9:
                            this.logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
                            this.stopConnection();
                            _a.label = 10;
                        case 10: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.startInternal = function (transferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var url, negotiateResponse, redirects, _loop_1, this_1, e_3;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.baseUrl;
                            this.accessTokenFactory = this.options.accessTokenFactory;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 12, , 13]);
                            if (!this.options.skipNegotiation) return [3 /*break*/, 5];
                            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3 /*break*/, 3];
                            // No need to add a connection ID in this case
                            this.transport = this.constructTransport(HttpTransportType.WebSockets);
                            // We should just call connect directly in this case.
                            // No fallback or negotiate in this case.
                            return [4 /*yield*/, this.startTransport(url, transferFormat)];
                        case 2:
                            // We should just call connect directly in this case.
                            // No fallback or negotiate in this case.
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3: throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                        case 4: return [3 /*break*/, 11];
                        case 5:
                            negotiateResponse = null;
                            redirects = 0;
                            _loop_1 = function () {
                                var accessToken_1;
                                return __generator$5(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this_1.getNegotiationResponse(url)];
                                        case 1:
                                            negotiateResponse = _a.sent();
                                            // the user tries to stop the connection when it is being started
                                            if (this_1.connectionState === "Disconnecting" /* Disconnecting */ || this_1.connectionState === "Disconnected" /* Disconnected */) {
                                                throw new Error("The connection was stopped during negotiation.");
                                            }
                                            if (negotiateResponse.error) {
                                                throw new Error(negotiateResponse.error);
                                            }
                                            if (negotiateResponse.ProtocolVersion) {
                                                throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                                            }
                                            if (negotiateResponse.url) {
                                                url = negotiateResponse.url;
                                            }
                                            if (negotiateResponse.accessToken) {
                                                accessToken_1 = negotiateResponse.accessToken;
                                                this_1.accessTokenFactory = function () { return accessToken_1; };
                                            }
                                            redirects++;
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _a.label = 6;
                        case 6: return [5 /*yield**/, _loop_1()];
                        case 7:
                            _a.sent();
                            _a.label = 8;
                        case 8:
                            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];
                            _a.label = 9;
                        case 9:
                            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                                throw new Error("Negotiate redirection limit exceeded.");
                            }
                            return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];
                        case 10:
                            _a.sent();
                            _a.label = 11;
                        case 11:
                            if (this.transport instanceof LongPollingTransport) {
                                this.features.inherentKeepAlive = true;
                            }
                            if (this.connectionState === "Connecting " /* Connecting */) {
                                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.
                                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.
                                this.logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
                                this.connectionState = "Connected" /* Connected */;
                            }
                            return [3 /*break*/, 13];
                        case 12:
                            e_3 = _a.sent();
                            this.logger.log(LogLevel.Error, "Failed to start the connection: " + e_3);
                            this.connectionState = "Disconnected" /* Disconnected */;
                            this.transport = undefined;
                            return [2 /*return*/, Promise.reject(e_3)];
                        case 13: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.getNegotiationResponse = function (url) {
            return __awaiter$5(this, void 0, void 0, function () {
                var _a, headers, token, negotiateUrl, response, negotiateResponse, e_4;
                return __generator$5(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _b.sent();
                            if (token) {
                                headers = (_a = {},
                                    _a["Authorization"] = "Bearer " + token,
                                    _a);
                            }
                            _b.label = 2;
                        case 2:
                            negotiateUrl = this.resolveNegotiateUrl(url);
                            this.logger.log(LogLevel.Debug, "Sending negotiation request: " + negotiateUrl + ".");
                            _b.label = 3;
                        case 3:
                            _b.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, this.httpClient.post(negotiateUrl, {
                                    content: "",
                                    headers: headers,
                                })];
                        case 4:
                            response = _b.sent();
                            if (response.statusCode !== 200) {
                                return [2 /*return*/, Promise.reject(new Error("Unexpected status code returned from negotiate " + response.statusCode))];
                            }
                            negotiateResponse = JSON.parse(response.content);
                            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
                                // Negotiate version 0 doesn't use connectionToken
                                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version
                                negotiateResponse.connectionToken = negotiateResponse.connectionId;
                            }
                            return [2 /*return*/, negotiateResponse];
                        case 5:
                            e_4 = _b.sent();
                            this.logger.log(LogLevel.Error, "Failed to complete negotiation with the server: " + e_4);
                            return [2 /*return*/, Promise.reject(e_4)];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {
            if (!connectionToken) {
                return url;
            }
            return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionToken);
        };
        HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);
                            if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];
                            this.logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
                            this.transport = requestedTransport;
                            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];
                        case 1:
                            _a.sent();
                            this.connectionId = negotiateResponse.connectionId;
                            return [2 /*return*/];
                        case 2:
                            transportExceptions = [];
                            transports = negotiateResponse.availableTransports || [];
                            negotiate = negotiateResponse;
                            _i = 0, transports_1 = transports;
                            _a.label = 3;
                        case 3:
                            if (!(_i < transports_1.length)) return [3 /*break*/, 13];
                            endpoint = transports_1[_i];
                            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);
                            if (!(transportOrError instanceof Error)) return [3 /*break*/, 4];
                            // Store the error and continue, we don't want to cause a re-negotiate in these cases
                            transportExceptions.push(endpoint.transport + " failed: " + transportOrError);
                            return [3 /*break*/, 12];
                        case 4:
                            if (!this.isITransport(transportOrError)) return [3 /*break*/, 12];
                            this.transport = transportOrError;
                            if (!!negotiate) return [3 /*break*/, 9];
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, this.getNegotiationResponse(url)];
                        case 6:
                            negotiate = _a.sent();
                            return [3 /*break*/, 8];
                        case 7:
                            ex_1 = _a.sent();
                            return [2 /*return*/, Promise.reject(ex_1)];
                        case 8:
                            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);
                            _a.label = 9;
                        case 9:
                            _a.trys.push([9, 11, , 12]);
                            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];
                        case 10:
                            _a.sent();
                            this.connectionId = negotiate.connectionId;
                            return [2 /*return*/];
                        case 11:
                            ex_2 = _a.sent();
                            this.logger.log(LogLevel.Error, "Failed to start the transport '" + endpoint.transport + "': " + ex_2);
                            negotiate = undefined;
                            transportExceptions.push(endpoint.transport + " failed: " + ex_2);
                            if (this.connectionState !== "Connecting " /* Connecting */) {
                                message = "Failed to select transport before stop() was called.";
                                this.logger.log(LogLevel.Debug, message);
                                return [2 /*return*/, Promise.reject(new Error(message))];
                            }
                            return [3 /*break*/, 12];
                        case 12:
                            _i++;
                            return [3 /*break*/, 3];
                        case 13:
                            if (transportExceptions.length > 0) {
                                return [2 /*return*/, Promise.reject(new Error("Unable to connect to the server with any of the available transports. " + transportExceptions.join(" ")))];
                            }
                            return [2 /*return*/, Promise.reject(new Error("None of the transports supported by the client are supported by the server."))];
                    }
                });
            });
        };
        HttpConnection.prototype.constructTransport = function (transport) {
            switch (transport) {
                case HttpTransportType.WebSockets:
                    if (!this.options.WebSocket) {
                        throw new Error("'WebSocket' is not supported in your environment.");
                    }
                    return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);
                case HttpTransportType.ServerSentEvents:
                    if (!this.options.EventSource) {
                        throw new Error("'EventSource' is not supported in your environment.");
                    }
                    return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);
                case HttpTransportType.LongPolling:
                    return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);
                default:
                    throw new Error("Unknown transport: " + transport + ".");
            }
        };
        HttpConnection.prototype.startTransport = function (url, transferFormat) {
            var _this = this;
            this.transport.onreceive = this.onreceive;
            this.transport.onclose = function (e) { return _this.stopConnection(e); };
            return this.transport.connect(url, transferFormat);
        };
        HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {
            var transport = HttpTransportType[endpoint.transport];
            if (transport === null || transport === undefined) {
                this.logger.log(LogLevel.Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
                return new Error("Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
            }
            else {
                if (transportMatches(requestedTransport, transport)) {
                    var transferFormats = endpoint.transferFormats.map(function (s) { return TransferFormat[s]; });
                    if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
                        if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||
                            (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {
                            this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it is not supported in your environment.'");
                            return new Error("'" + HttpTransportType[transport] + "' is not supported in your environment.");
                        }
                        else {
                            this.logger.log(LogLevel.Debug, "Selecting transport '" + HttpTransportType[transport] + "'.");
                            try {
                                return this.constructTransport(transport);
                            }
                            catch (ex) {
                                return ex;
                            }
                        }
                    }
                    else {
                        this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it does not support the requested transfer format '" + TransferFormat[requestedTransferFormat] + "'.");
                        return new Error("'" + HttpTransportType[transport] + "' does not support " + TransferFormat[requestedTransferFormat] + ".");
                    }
                }
                else {
                    this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it was disabled by the client.");
                    return new Error("'" + HttpTransportType[transport] + "' is disabled by the client.");
                }
            }
        };
        HttpConnection.prototype.isITransport = function (transport) {
            return transport && typeof (transport) === "object" && "connect" in transport;
        };
        HttpConnection.prototype.stopConnection = function (error) {
            var _this = this;
            this.logger.log(LogLevel.Debug, "HttpConnection.stopConnection(" + error + ") called while in state " + this.connectionState + ".");
            this.transport = undefined;
            // If we have a stopError, it takes precedence over the error from the transport
            error = this.stopError || error;
            this.stopError = undefined;
            if (this.connectionState === "Disconnected" /* Disconnected */) {
                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection is already in the disconnected state.");
                return;
            }
            if (this.connectionState === "Connecting " /* Connecting */) {
                this.logger.log(LogLevel.Warning, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection hasn't yet left the in the connecting state.");
                return;
            }
            if (this.connectionState === "Disconnecting" /* Disconnecting */) {
                // A call to stop() induced this call to stopConnection and needs to be completed.
                // Any stop() awaiters will be scheduled to continue after the onclose callback fires.
                this.stopPromiseResolver();
            }
            if (error) {
                this.logger.log(LogLevel.Error, "Connection disconnected with error '" + error + "'.");
            }
            else {
                this.logger.log(LogLevel.Information, "Connection disconnected.");
            }
            if (this.sendQueue) {
                this.sendQueue.stop().catch(function (e) {
                    _this.logger.log(LogLevel.Error, "TransportSendQueue.stop() threw error '" + e + "'.");
                });
                this.sendQueue = undefined;
            }
            this.connectionId = undefined;
            this.connectionState = "Disconnected" /* Disconnected */;
            if (this.connectionStarted) {
                this.connectionStarted = false;
                try {
                    if (this.onclose) {
                        this.onclose(error);
                    }
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "HttpConnection.onclose(" + error + ") threw error '" + e + "'.");
                }
            }
        };
        HttpConnection.prototype.resolveUrl = function (url) {
            // startsWith is not supported in IE
            if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
                return url;
            }
            if (!Platform.isBrowser || !window.document) {
                throw new Error("Cannot resolve '" + url + "'.");
            }
            // Setting the url to the href propery of an anchor tag handles normalization
            // for us. There are 3 main cases.
            // 1. Relative path normalization e.g "b" -> "http://localhost:5000/a/b"
            // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
            // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"
            var aTag = window.document.createElement("a");
            aTag.href = url;
            this.logger.log(LogLevel.Information, "Normalizing '" + url + "' to '" + aTag.href + "'.");
            return aTag.href;
        };
        HttpConnection.prototype.resolveNegotiateUrl = function (url) {
            var index = url.indexOf("?");
            var negotiateUrl = url.substring(0, index === -1 ? url.length : index);
            if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
                negotiateUrl += "/";
            }
            negotiateUrl += "negotiate";
            negotiateUrl += index === -1 ? "" : url.substring(index);
            if (negotiateUrl.indexOf("negotiateVersion") === -1) {
                negotiateUrl += index === -1 ? "?" : "&";
                negotiateUrl += "negotiateVersion=" + this.negotiateVersion;
            }
            return negotiateUrl;
        };
        return HttpConnection;
    }());
    function transportMatches(requestedTransport, actualTransport) {
        return !requestedTransport || ((actualTransport & requestedTransport) !== 0);
    }
    /** @private */
    var TransportSendQueue = /** @class */ (function () {
        function TransportSendQueue(transport) {
            this.transport = transport;
            this.buffer = [];
            this.executing = true;
            this.sendBufferedData = new PromiseSource();
            this.transportResult = new PromiseSource();
            this.sendLoopPromise = this.sendLoop();
        }
        TransportSendQueue.prototype.send = function (data) {
            this.bufferData(data);
            if (!this.transportResult) {
                this.transportResult = new PromiseSource();
            }
            return this.transportResult.promise;
        };
        TransportSendQueue.prototype.stop = function () {
            this.executing = false;
            this.sendBufferedData.resolve();
            return this.sendLoopPromise;
        };
        TransportSendQueue.prototype.bufferData = function (data) {
            if (this.buffer.length && typeof (this.buffer[0]) !== typeof (data)) {
                throw new Error("Expected data to be of type " + typeof (this.buffer) + " but was of type " + typeof (data));
            }
            this.buffer.push(data);
            this.sendBufferedData.resolve();
        };
        TransportSendQueue.prototype.sendLoop = function () {
            return __awaiter$5(this, void 0, void 0, function () {
                var transportResult, data, error_1;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/, this.sendBufferedData.promise];
                        case 1:
                            _a.sent();
                            if (!this.executing) {
                                if (this.transportResult) {
                                    this.transportResult.reject("Connection stopped.");
                                }
                                return [3 /*break*/, 6];
                            }
                            this.sendBufferedData = new PromiseSource();
                            transportResult = this.transportResult;
                            this.transportResult = undefined;
                            data = typeof (this.buffer[0]) === "string" ?
                                this.buffer.join("") :
                                TransportSendQueue.concatBuffers(this.buffer);
                            this.buffer.length = 0;
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.transport.send(data)];
                        case 3:
                            _a.sent();
                            transportResult.resolve();
                            return [3 /*break*/, 5];
                        case 4:
                            error_1 = _a.sent();
                            transportResult.reject(error_1);
                            return [3 /*break*/, 5];
                        case 5: return [3 /*break*/, 0];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        TransportSendQueue.concatBuffers = function (arrayBuffers) {
            var totalLength = arrayBuffers.map(function (b) { return b.byteLength; }).reduce(function (a, b) { return a + b; });
            var result = new Uint8Array(totalLength);
            var offset = 0;
            for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {
                var item = arrayBuffers_1[_i];
                result.set(new Uint8Array(item), offset);
                offset += item.byteLength;
            }
            return result;
        };
        return TransportSendQueue;
    }());
    var PromiseSource = /** @class */ (function () {
        function PromiseSource() {
            var _this = this;
            this.promise = new Promise(function (resolve, reject) {
                var _a;
                return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;
            });
        }
        PromiseSource.prototype.resolve = function () {
            this.resolver();
        };
        PromiseSource.prototype.reject = function (reason) {
            this.rejecter(reason);
        };
        return PromiseSource;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    var JSON_HUB_PROTOCOL_NAME = "json";
    /** Implements the JSON Hub Protocol. */
    var JsonHubProtocol = /** @class */ (function () {
        function JsonHubProtocol() {
            /** @inheritDoc */
            this.name = JSON_HUB_PROTOCOL_NAME;
            /** @inheritDoc */
            this.version = 1;
            /** @inheritDoc */
            this.transferFormat = TransferFormat.Text;
        }
        /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.
         *
         * @param {string} input A string containing the serialized representation.
         * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
         */
        JsonHubProtocol.prototype.parseMessages = function (input, logger) {
            // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
            if (typeof input !== "string") {
                throw new Error("Invalid input for JSON hub protocol. Expected a string.");
            }
            if (!input) {
                return [];
            }
            if (logger === null) {
                logger = NullLogger.instance;
            }
            // Parse the messages
            var messages = TextMessageFormat.parse(input);
            var hubMessages = [];
            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                var message = messages_1[_i];
                var parsedMessage = JSON.parse(message);
                if (typeof parsedMessage.type !== "number") {
                    throw new Error("Invalid payload.");
                }
                switch (parsedMessage.type) {
                    case MessageType.Invocation:
                        this.isInvocationMessage(parsedMessage);
                        break;
                    case MessageType.StreamItem:
                        this.isStreamItemMessage(parsedMessage);
                        break;
                    case MessageType.Completion:
                        this.isCompletionMessage(parsedMessage);
                        break;
                    case MessageType.Ping:
                        // Single value, no need to validate
                        break;
                    case MessageType.Close:
                        // All optional values, no need to validate
                        break;
                    default:
                        // Future protocol changes can add message types, old clients can ignore them
                        logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
                        continue;
                }
                hubMessages.push(parsedMessage);
            }
            return hubMessages;
        };
        /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.
         *
         * @param {HubMessage} message The message to write.
         * @returns {string} A string containing the serialized representation of the message.
         */
        JsonHubProtocol.prototype.writeMessage = function (message) {
            return TextMessageFormat.write(JSON.stringify(message));
        };
        JsonHubProtocol.prototype.isInvocationMessage = function (message) {
            this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
            if (message.invocationId !== undefined) {
                this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
            }
        };
        JsonHubProtocol.prototype.isStreamItemMessage = function (message) {
            this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
            if (message.item === undefined) {
                throw new Error("Invalid payload for StreamItem message.");
            }
        };
        JsonHubProtocol.prototype.isCompletionMessage = function (message) {
            if (message.result && message.error) {
                throw new Error("Invalid payload for Completion message.");
            }
            if (!message.result && message.error) {
                this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
            }
            this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
        };
        JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {
            if (typeof value !== "string" || value === "") {
                throw new Error(errorMessage);
            }
        };
        return JsonHubProtocol;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    // tslint:disable:object-literal-sort-keys
    var LogLevelNameMapping = {
        trace: LogLevel.Trace,
        debug: LogLevel.Debug,
        info: LogLevel.Information,
        information: LogLevel.Information,
        warn: LogLevel.Warning,
        warning: LogLevel.Warning,
        error: LogLevel.Error,
        critical: LogLevel.Critical,
        none: LogLevel.None,
    };
    function parseLogLevel(name) {
        // Case-insensitive matching via lower-casing
        // Yes, I know case-folding is a complicated problem in Unicode, but we only support
        // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.
        var mapping = LogLevelNameMapping[name.toLowerCase()];
        if (typeof mapping !== "undefined") {
            return mapping;
        }
        else {
            throw new Error("Unknown log level: " + name);
        }
    }
    /** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */
    var HubConnectionBuilder = /** @class */ (function () {
        function HubConnectionBuilder() {
        }
        HubConnectionBuilder.prototype.configureLogging = function (logging) {
            Arg.isRequired(logging, "logging");
            if (isLogger(logging)) {
                this.logger = logging;
            }
            else if (typeof logging === "string") {
                var logLevel = parseLogLevel(logging);
                this.logger = new ConsoleLogger(logLevel);
            }
            else {
                this.logger = new ConsoleLogger(logging);
            }
            return this;
        };
        HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {
            Arg.isRequired(url, "url");
            this.url = url;
            // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
            // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.
            if (typeof transportTypeOrOptions === "object") {
                this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, transportTypeOrOptions);
            }
            else {
                this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, { transport: transportTypeOrOptions });
            }
            return this;
        };
        /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.
         *
         * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.
         */
        HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {
            Arg.isRequired(protocol, "protocol");
            this.protocol = protocol;
            return this;
        };
        HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {
            if (this.reconnectPolicy) {
                throw new Error("A reconnectPolicy has already been set.");
            }
            if (!retryDelaysOrReconnectPolicy) {
                this.reconnectPolicy = new DefaultReconnectPolicy();
            }
            else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
                this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
            }
            else {
                this.reconnectPolicy = retryDelaysOrReconnectPolicy;
            }
            return this;
        };
        /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.
         *
         * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.
         */
        HubConnectionBuilder.prototype.build = function () {
            // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
            // provided to configureLogger
            var httpConnectionOptions = this.httpConnectionOptions || {};
            // If it's 'null', the user **explicitly** asked for null, don't mess with it.
            if (httpConnectionOptions.logger === undefined) {
                // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
                httpConnectionOptions.logger = this.logger;
            }
            // Now create the connection
            if (!this.url) {
                throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
            }
            var connection = new HttpConnection(this.url, httpConnectionOptions);
            return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);
        };
        return HubConnectionBuilder;
    }());
    function isLogger(logger) {
        return logger.log !== undefined;
    }

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer$1(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Function equal to merge with the difference being that no reference
     * to original objects is kept.
     *
     * @see merge
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function deepMerge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === 'object') {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer$1,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      deepMerge: deepMerge,
      extend: extend,
      trim: trim
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies$1.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
      var defaultToConfig2Keys = [
        'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
        'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath'
      ];

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils.isObject(config2[prop])) {
          config[prop] = utils.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (utils.isObject(config1[prop])) {
          config[prop] = utils.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys);

      var otherKeys = Object
        .keys(config2)
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var _default = axios;
    axios_1.default = _default;

    var axios$1 = axios_1;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var sweetalert2_all = createCommonjsModule(function (module, exports) {
    /*!
    * sweetalert2 v10.8.1
    * Released under the MIT License.
    */
    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, function () {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function (obj) {
            return typeof obj;
          };
        } else {
          _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      var consolePrefix = 'SweetAlert2:';
      /**
       * Filter the unique values into a new array
       * @param arr
       */

      var uniqueArray = function uniqueArray(arr) {
        var result = [];

        for (var i = 0; i < arr.length; i++) {
          if (result.indexOf(arr[i]) === -1) {
            result.push(arr[i]);
          }
        }

        return result;
      };
      /**
       * Capitalize the first letter of a string
       * @param str
       */

      var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      };
      /**
       * Returns the array of object values (Object.values isn't supported in IE11)
       * @param obj
       */

      var objectValues = function objectValues(obj) {
        return Object.keys(obj).map(function (key) {
          return obj[key];
        });
      };
      /**
       * Convert NodeList to Array
       * @param nodeList
       */

      var toArray = function toArray(nodeList) {
        return Array.prototype.slice.call(nodeList);
      };
      /**
       * Standardise console warnings
       * @param message
       */

      var warn = function warn(message) {
        console.warn("".concat(consolePrefix, " ").concat(message));
      };
      /**
       * Standardise console errors
       * @param message
       */

      var error = function error(message) {
        console.error("".concat(consolePrefix, " ").concat(message));
      };
      /**
       * Private global state for `warnOnce`
       * @type {Array}
       * @private
       */

      var previousWarnOnceMessages = [];
      /**
       * Show a console warning, but only if it hasn't already been shown
       * @param message
       */

      var warnOnce = function warnOnce(message) {
        if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
          previousWarnOnceMessages.push(message);
          warn(message);
        }
      };
      /**
       * Show a one-time console warning about deprecated params/methods
       */

      var warnAboutDeprecation = function warnAboutDeprecation(deprecatedParam, useInstead) {
        warnOnce("\"".concat(deprecatedParam, "\" is deprecated and will be removed in the next major release. Please use \"").concat(useInstead, "\" instead."));
      };
      /**
       * If `arg` is a function, call it (with no arguments or context) and return the result.
       * Otherwise, just pass the value through
       * @param arg
       */

      var callIfFunction = function callIfFunction(arg) {
        return typeof arg === 'function' ? arg() : arg;
      };
      var hasToPromiseFn = function hasToPromiseFn(arg) {
        return arg && typeof arg.toPromise === 'function';
      };
      var asPromise = function asPromise(arg) {
        return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
      };
      var isPromise = function isPromise(arg) {
        return arg && Promise.resolve(arg) === arg;
      };

      var DismissReason = Object.freeze({
        cancel: 'cancel',
        backdrop: 'backdrop',
        close: 'close',
        esc: 'esc',
        timer: 'timer'
      });

      var isJqueryElement = function isJqueryElement(elem) {
        return _typeof(elem) === 'object' && elem.jquery;
      };

      var isElement = function isElement(elem) {
        return elem instanceof Element || isJqueryElement(elem);
      };

      var argsToParams = function argsToParams(args) {
        var params = {};

        if (_typeof(args[0]) === 'object' && !isElement(args[0])) {
          _extends(params, args[0]);
        } else {
          ['title', 'html', 'icon'].forEach(function (name, index) {
            var arg = args[index];

            if (typeof arg === 'string' || isElement(arg)) {
              params[name] = arg;
            } else if (arg !== undefined) {
              error("Unexpected type of ".concat(name, "! Expected \"string\" or \"Element\", got ").concat(_typeof(arg)));
            }
          });
        }

        return params;
      };

      var swalPrefix = 'swal2-';
      var prefix = function prefix(items) {
        var result = {};

        for (var i in items) {
          result[items[i]] = swalPrefix + items[i];
        }

        return result;
      };
      var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'toast-column', 'show', 'hide', 'close', 'title', 'header', 'content', 'html-container', 'actions', 'confirm', 'deny', 'cancel', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'input-label', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loader', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error']);
      var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);

      var getContainer = function getContainer() {
        return document.body.querySelector(".".concat(swalClasses.container));
      };
      var elementBySelector = function elementBySelector(selectorString) {
        var container = getContainer();
        return container ? container.querySelector(selectorString) : null;
      };

      var elementByClass = function elementByClass(className) {
        return elementBySelector(".".concat(className));
      };

      var getPopup = function getPopup() {
        return elementByClass(swalClasses.popup);
      };
      var getIcons = function getIcons() {
        var popup = getPopup();
        return toArray(popup.querySelectorAll(".".concat(swalClasses.icon)));
      };
      var getIcon = function getIcon() {
        var visibleIcon = getIcons().filter(function (icon) {
          return isVisible(icon);
        });
        return visibleIcon.length ? visibleIcon[0] : null;
      };
      var getTitle = function getTitle() {
        return elementByClass(swalClasses.title);
      };
      var getContent = function getContent() {
        return elementByClass(swalClasses.content);
      };
      var getHtmlContainer = function getHtmlContainer() {
        return elementByClass(swalClasses['html-container']);
      };
      var getImage = function getImage() {
        return elementByClass(swalClasses.image);
      };
      var getProgressSteps = function getProgressSteps() {
        return elementByClass(swalClasses['progress-steps']);
      };
      var getValidationMessage = function getValidationMessage() {
        return elementByClass(swalClasses['validation-message']);
      };
      var getConfirmButton = function getConfirmButton() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
      };
      var getDenyButton = function getDenyButton() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
      };
      var getInputLabel = function getInputLabel() {
        return elementByClass(swalClasses['input-label']);
      };
      var getLoader = function getLoader() {
        return elementBySelector(".".concat(swalClasses.loader));
      };
      var getCancelButton = function getCancelButton() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
      };
      var getActions = function getActions() {
        return elementByClass(swalClasses.actions);
      };
      var getHeader = function getHeader() {
        return elementByClass(swalClasses.header);
      };
      var getFooter = function getFooter() {
        return elementByClass(swalClasses.footer);
      };
      var getTimerProgressBar = function getTimerProgressBar() {
        return elementByClass(swalClasses['timer-progress-bar']);
      };
      var getCloseButton = function getCloseButton() {
        return elementByClass(swalClasses.close);
      }; // https://github.com/jkup/focusable/blob/master/index.js

      var focusable = "\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n";
      var getFocusableElements = function getFocusableElements() {
        var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // sort according to tabindex
        .sort(function (a, b) {
          a = parseInt(a.getAttribute('tabindex'));
          b = parseInt(b.getAttribute('tabindex'));

          if (a > b) {
            return 1;
          } else if (a < b) {
            return -1;
          }

          return 0;
        });
        var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {
          return el.getAttribute('tabindex') !== '-1';
        });
        return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
          return isVisible(el);
        });
      };
      var isModal = function isModal() {
        return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);
      };
      var isToast = function isToast() {
        return document.body.classList.contains(swalClasses['toast-shown']);
      };
      var isLoading = function isLoading() {
        return getPopup().hasAttribute('data-loading');
      };

      var states = {
        previousBodyPadding: null
      };
      var setInnerHtml = function setInnerHtml(elem, html) {
        // #1926
        elem.textContent = '';

        if (html) {
          var parser = new DOMParser();
          var parsed = parser.parseFromString(html, "text/html");
          toArray(parsed.querySelector('head').childNodes).forEach(function (child) {
            elem.appendChild(child);
          });
          toArray(parsed.querySelector('body').childNodes).forEach(function (child) {
            elem.appendChild(child);
          });
        }
      };
      var hasClass = function hasClass(elem, className) {
        if (!className) {
          return false;
        }

        var classList = className.split(/\s+/);

        for (var i = 0; i < classList.length; i++) {
          if (!elem.classList.contains(classList[i])) {
            return false;
          }
        }

        return true;
      };

      var removeCustomClasses = function removeCustomClasses(elem, params) {
        toArray(elem.classList).forEach(function (className) {
          if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1) && !(objectValues(params.showClass).indexOf(className) !== -1)) {
            elem.classList.remove(className);
          }
        });
      };

      var applyCustomClass = function applyCustomClass(elem, params, className) {
        removeCustomClasses(elem, params);

        if (params.customClass && params.customClass[className]) {
          if (typeof params.customClass[className] !== 'string' && !params.customClass[className].forEach) {
            return warn("Invalid type of customClass.".concat(className, "! Expected string or iterable object, got \"").concat(_typeof(params.customClass[className]), "\""));
          }

          addClass(elem, params.customClass[className]);
        }
      };
      function getInput(content, inputType) {
        if (!inputType) {
          return null;
        }

        switch (inputType) {
          case 'select':
          case 'textarea':
          case 'file':
            return getChildByClass(content, swalClasses[inputType]);

          case 'checkbox':
            return content.querySelector(".".concat(swalClasses.checkbox, " input"));

          case 'radio':
            return content.querySelector(".".concat(swalClasses.radio, " input:checked")) || content.querySelector(".".concat(swalClasses.radio, " input:first-child"));

          case 'range':
            return content.querySelector(".".concat(swalClasses.range, " input"));

          default:
            return getChildByClass(content, swalClasses.input);
        }
      }
      var focusInput = function focusInput(input) {
        input.focus(); // place cursor at end of text in text input

        if (input.type !== 'file') {
          // http://stackoverflow.com/a/2345915
          var val = input.value;
          input.value = '';
          input.value = val;
        }
      };
      var toggleClass = function toggleClass(target, classList, condition) {
        if (!target || !classList) {
          return;
        }

        if (typeof classList === 'string') {
          classList = classList.split(/\s+/).filter(Boolean);
        }

        classList.forEach(function (className) {
          if (target.forEach) {
            target.forEach(function (elem) {
              condition ? elem.classList.add(className) : elem.classList.remove(className);
            });
          } else {
            condition ? target.classList.add(className) : target.classList.remove(className);
          }
        });
      };
      var addClass = function addClass(target, classList) {
        toggleClass(target, classList, true);
      };
      var removeClass = function removeClass(target, classList) {
        toggleClass(target, classList, false);
      };
      var getChildByClass = function getChildByClass(elem, className) {
        for (var i = 0; i < elem.childNodes.length; i++) {
          if (hasClass(elem.childNodes[i], className)) {
            return elem.childNodes[i];
          }
        }
      };
      var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
        if (value || parseInt(value) === 0) {
          elem.style[property] = typeof value === 'number' ? "".concat(value, "px") : value;
        } else {
          elem.style.removeProperty(property);
        }
      };
      var show = function show(elem) {
        var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
        elem.style.display = display;
      };
      var hide = function hide(elem) {
        elem.style.display = 'none';
      };
      var setStyle = function setStyle(parent, selector, property, value) {
        var el = parent.querySelector(selector);

        if (el) {
          el.style[property] = value;
        }
      };
      var toggle = function toggle(elem, condition, display) {
        condition ? show(elem, display) : hide(elem);
      }; // borrowed from jquery $(elem).is(':visible') implementation

      var isVisible = function isVisible(elem) {
        return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
      };
      /* istanbul ignore next */

      var isScrollable = function isScrollable(elem) {
        return !!(elem.scrollHeight > elem.clientHeight);
      }; // borrowed from https://stackoverflow.com/a/46352119

      var hasCssAnimation = function hasCssAnimation(elem) {
        var style = window.getComputedStyle(elem);
        var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
        var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
        return animDuration > 0 || transDuration > 0;
      };
      var contains = function contains(haystack, needle) {
        if (typeof haystack.contains === 'function') {
          return haystack.contains(needle);
        }
      };
      var animateTimerProgressBar = function animateTimerProgressBar(timer) {
        var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var timerProgressBar = getTimerProgressBar();

        if (isVisible(timerProgressBar)) {
          if (reset) {
            timerProgressBar.style.transition = 'none';
            timerProgressBar.style.width = '100%';
          }

          setTimeout(function () {
            timerProgressBar.style.transition = "width ".concat(timer / 1000, "s linear");
            timerProgressBar.style.width = '0%';
          }, 10);
        }
      };
      var stopTimerProgressBar = function stopTimerProgressBar() {
        var timerProgressBar = getTimerProgressBar();
        var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        timerProgressBar.style.removeProperty('transition');
        timerProgressBar.style.width = '100%';
        var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        var timerProgressBarPercent = parseInt(timerProgressBarWidth / timerProgressBarFullWidth * 100);
        timerProgressBar.style.removeProperty('transition');
        timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
      };

      // Detect Node env
      var isNodeEnv = function isNodeEnv() {
        return typeof window === 'undefined' || typeof document === 'undefined';
      };

      var sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n   <div class=\"").concat(swalClasses.header, "\">\n     <ul class=\"").concat(swalClasses['progress-steps'], "\"></ul>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.error, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.question, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.warning, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.info, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.success, "\"></div>\n     <img class=\"").concat(swalClasses.image, "\" />\n     <h2 class=\"").concat(swalClasses.title, "\" id=\"").concat(swalClasses.title, "\"></h2>\n     <button type=\"button\" class=\"").concat(swalClasses.close, "\"></button>\n   </div>\n   <div class=\"").concat(swalClasses.content, "\">\n     <div id=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses['html-container'], "\"></div>\n     <input class=\"").concat(swalClasses.input, "\" />\n     <input type=\"file\" class=\"").concat(swalClasses.file, "\" />\n     <div class=\"").concat(swalClasses.range, "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"").concat(swalClasses.select, "\"></select>\n     <div class=\"").concat(swalClasses.radio, "\"></div>\n     <label for=\"").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n       <input type=\"checkbox\" />\n       <span class=\"").concat(swalClasses.label, "\"></span>\n     </label>\n     <textarea class=\"").concat(swalClasses.textarea, "\"></textarea>\n     <div class=\"").concat(swalClasses['validation-message'], "\" id=\"").concat(swalClasses['validation-message'], "\"></div>\n   </div>\n   <div class=\"").concat(swalClasses.actions, "\">\n     <div class=\"").concat(swalClasses.loader, "\"></div>\n     <button type=\"button\" class=\"").concat(swalClasses.confirm, "\"></button>\n     <button type=\"button\" class=\"").concat(swalClasses.deny, "\"></button>\n     <button type=\"button\" class=\"").concat(swalClasses.cancel, "\"></button>\n   </div>\n   <div class=\"").concat(swalClasses.footer, "\"></div>\n   <div class=\"").concat(swalClasses['timer-progress-bar-container'], "\">\n     <div class=\"").concat(swalClasses['timer-progress-bar'], "\"></div>\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, '');

      var resetOldContainer = function resetOldContainer() {
        var oldContainer = getContainer();

        if (!oldContainer) {
          return false;
        }

        oldContainer.parentNode.removeChild(oldContainer);
        removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
        return true;
      };

      var oldInputVal; // IE11 workaround, see #1109 for details

      var resetValidationMessage = function resetValidationMessage(e) {
        if (Swal.isVisible() && oldInputVal !== e.target.value) {
          Swal.resetValidationMessage();
        }

        oldInputVal = e.target.value;
      };

      var addInputChangeListeners = function addInputChangeListeners() {
        var content = getContent();
        var input = getChildByClass(content, swalClasses.input);
        var file = getChildByClass(content, swalClasses.file);
        var range = content.querySelector(".".concat(swalClasses.range, " input"));
        var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
        var select = getChildByClass(content, swalClasses.select);
        var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
        var textarea = getChildByClass(content, swalClasses.textarea);
        input.oninput = resetValidationMessage;
        file.onchange = resetValidationMessage;
        select.onchange = resetValidationMessage;
        checkbox.onchange = resetValidationMessage;
        textarea.oninput = resetValidationMessage;

        range.oninput = function (e) {
          resetValidationMessage(e);
          rangeOutput.value = range.value;
        };

        range.onchange = function (e) {
          resetValidationMessage(e);
          range.nextSibling.value = range.value;
        };
      };

      var getTarget = function getTarget(target) {
        return typeof target === 'string' ? document.querySelector(target) : target;
      };

      var setupAccessibility = function setupAccessibility(params) {
        var popup = getPopup();
        popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
        popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');

        if (!params.toast) {
          popup.setAttribute('aria-modal', 'true');
        }
      };

      var setupRTL = function setupRTL(targetElement) {
        if (window.getComputedStyle(targetElement).direction === 'rtl') {
          addClass(getContainer(), swalClasses.rtl);
        }
      };
      /*
       * Add modal + backdrop to DOM
       */


      var init = function init(params) {
        // Clean up the old popup container if it exists
        var oldContainerExisted = resetOldContainer();
        /* istanbul ignore if */

        if (isNodeEnv()) {
          error('SweetAlert2 requires document to initialize');
          return;
        }

        var container = document.createElement('div');
        container.className = swalClasses.container;

        if (oldContainerExisted) {
          addClass(container, swalClasses['no-transition']);
        }

        setInnerHtml(container, sweetHTML);
        var targetElement = getTarget(params.target);
        targetElement.appendChild(container);
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
      };

      var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
        // DOM element
        if (param instanceof HTMLElement) {
          target.appendChild(param); // Object
        } else if (_typeof(param) === 'object') {
          handleObject(param, target); // Plain string
        } else if (param) {
          setInnerHtml(target, param);
        }
      };

      var handleObject = function handleObject(param, target) {
        // JQuery element(s)
        if (param.jquery) {
          handleJqueryElem(target, param); // For other objects use their string representation
        } else {
          setInnerHtml(target, param.toString());
        }
      };

      var handleJqueryElem = function handleJqueryElem(target, elem) {
        target.textContent = '';

        if (0 in elem) {
          for (var i = 0; (i in elem); i++) {
            target.appendChild(elem[i].cloneNode(true));
          }
        } else {
          target.appendChild(elem.cloneNode(true));
        }
      };

      var animationEndEvent = function () {
        // Prevent run in Node env

        /* istanbul ignore if */
        if (isNodeEnv()) {
          return false;
        }

        var testEl = document.createElement('div');
        var transEndEventNames = {
          WebkitAnimation: 'webkitAnimationEnd',
          OAnimation: 'oAnimationEnd oanimationend',
          animation: 'animationend'
        };

        for (var i in transEndEventNames) {
          if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {
            return transEndEventNames[i];
          }
        }

        return false;
      }();

      // https://github.com/twbs/bootstrap/blob/master/js/src/modal.js

      var measureScrollbar = function measureScrollbar() {
        var scrollDiv = document.createElement('div');
        scrollDiv.className = swalClasses['scrollbar-measure'];
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };

      var renderActions = function renderActions(instance, params) {
        var actions = getActions();
        var loader = getLoader();
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton(); // Actions (buttons) wrapper

        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
          hide(actions);
        } // Custom class


        applyCustomClass(actions, params, 'actions'); // Render buttons

        renderButton(confirmButton, 'confirm', params);
        renderButton(denyButton, 'deny', params);
        renderButton(cancelButton, 'cancel', params);
        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);

        if (params.reverseButtons) {
          actions.insertBefore(cancelButton, loader);
          actions.insertBefore(denyButton, loader);
          actions.insertBefore(confirmButton, loader);
        } // Loader


        loader.innerHTML = params.loaderHtml;
        applyCustomClass(loader, params, 'loader');
      };

      function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
        if (!params.buttonsStyling) {
          return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
        }

        addClass([confirmButton, denyButton, cancelButton], swalClasses.styled); // Buttons background colors

        if (params.confirmButtonColor) {
          confirmButton.style.backgroundColor = params.confirmButtonColor;
        }

        if (params.denyButtonColor) {
          denyButton.style.backgroundColor = params.denyButtonColor;
        }

        if (params.cancelButtonColor) {
          cancelButton.style.backgroundColor = params.cancelButtonColor;
        }
      }

      function renderButton(button, buttonType, params) {
        toggle(button, params["show".concat(capitalizeFirstLetter(buttonType), "Button")], 'inline-block');
        setInnerHtml(button, params["".concat(buttonType, "ButtonText")]); // Set caption text

        button.setAttribute('aria-label', params["".concat(buttonType, "ButtonAriaLabel")]); // ARIA label
        // Add buttons custom classes

        button.className = swalClasses[buttonType];
        applyCustomClass(button, params, "".concat(buttonType, "Button"));
        addClass(button, params["".concat(buttonType, "ButtonClass")]);
      }

      function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === 'string') {
          container.style.background = backdrop;
        } else if (!backdrop) {
          addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
        }
      }

      function handlePositionParam(container, position) {
        if (position in swalClasses) {
          addClass(container, swalClasses[position]);
        } else {
          warn('The "position" parameter is not valid, defaulting to "center"');
          addClass(container, swalClasses.center);
        }
      }

      function handleGrowParam(container, grow) {
        if (grow && typeof grow === 'string') {
          var growClass = "grow-".concat(grow);

          if (growClass in swalClasses) {
            addClass(container, swalClasses[growClass]);
          }
        }
      }

      var renderContainer = function renderContainer(instance, params) {
        var container = getContainer();

        if (!container) {
          return;
        }

        handleBackdropParam(container, params.backdrop);

        if (!params.backdrop && params.allowOutsideClick) {
          warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        }

        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow); // Custom class

        applyCustomClass(container, params, 'container'); // Set queue step attribute for getQueueStep() method

        var queueStep = document.body.getAttribute('data-swal2-queue-step');

        if (queueStep) {
          container.setAttribute('data-queue-step', queueStep);
          document.body.removeAttribute('data-swal2-queue-step');
        }
      };

      /**
       * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
       * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
       * This is the approach that Babel will probably take to implement private methods/fields
       *   https://github.com/tc39/proposal-private-methods
       *   https://github.com/babel/babel/pull/7555
       * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
       *   then we can use that language feature.
       */
      var privateProps = {
        promise: new WeakMap(),
        innerParams: new WeakMap(),
        domCache: new WeakMap()
      };

      var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
      var renderInput = function renderInput(instance, params) {
        var content = getContent();
        var innerParams = privateProps.innerParams.get(instance);
        var rerender = !innerParams || params.input !== innerParams.input;
        inputTypes.forEach(function (inputType) {
          var inputClass = swalClasses[inputType];
          var inputContainer = getChildByClass(content, inputClass); // set attributes

          setAttributes(inputType, params.inputAttributes); // set class

          inputContainer.className = inputClass;

          if (rerender) {
            hide(inputContainer);
          }
        });

        if (params.input) {
          if (rerender) {
            showInput(params);
          } // set custom class


          setCustomClass(params);
        }
      };

      var showInput = function showInput(params) {
        if (!renderInputType[params.input]) {
          return error("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"".concat(params.input, "\""));
        }

        var inputContainer = getInputContainer(params.input);
        var input = renderInputType[params.input](inputContainer, params);
        show(input); // input autofocus

        setTimeout(function () {
          focusInput(input);
        });
      };

      var removeAttributes = function removeAttributes(input) {
        for (var i = 0; i < input.attributes.length; i++) {
          var attrName = input.attributes[i].name;

          if (!(['type', 'value', 'style'].indexOf(attrName) !== -1)) {
            input.removeAttribute(attrName);
          }
        }
      };

      var setAttributes = function setAttributes(inputType, inputAttributes) {
        var input = getInput(getContent(), inputType);

        if (!input) {
          return;
        }

        removeAttributes(input);

        for (var attr in inputAttributes) {
          // Do not set a placeholder for <input type="range">
          // it'll crash Edge, #1298
          if (inputType === 'range' && attr === 'placeholder') {
            continue;
          }

          input.setAttribute(attr, inputAttributes[attr]);
        }
      };

      var setCustomClass = function setCustomClass(params) {
        var inputContainer = getInputContainer(params.input);

        if (params.customClass) {
          addClass(inputContainer, params.customClass.input);
        }
      };

      var setInputPlaceholder = function setInputPlaceholder(input, params) {
        if (!input.placeholder || params.inputPlaceholder) {
          input.placeholder = params.inputPlaceholder;
        }
      };

      var setInputLabel = function setInputLabel(input, prependTo, params) {
        if (params.inputLabel) {
          input.id = swalClasses.input;
          var label = document.createElement('label');
          var labelClass = swalClasses['input-label'];
          label.setAttribute('for', input.id);
          label.className = labelClass;
          label.innerText = params.inputLabel;
          prependTo.insertAdjacentElement('beforebegin', label);
        }
      };

      var getInputContainer = function getInputContainer(inputType) {
        var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
        return getChildByClass(getContent(), inputClass);
      };

      var renderInputType = {};

      renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {
        if (typeof params.inputValue === 'string' || typeof params.inputValue === 'number') {
          input.value = params.inputValue;
        } else if (!isPromise(params.inputValue)) {
          warn("Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"".concat(_typeof(params.inputValue), "\""));
        }

        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        input.type = params.input;
        return input;
      };

      renderInputType.file = function (input, params) {
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        return input;
      };

      renderInputType.range = function (range, params) {
        var rangeInput = range.querySelector('input');
        var rangeOutput = range.querySelector('output');
        rangeInput.value = params.inputValue;
        rangeInput.type = params.input;
        rangeOutput.value = params.inputValue;
        setInputLabel(rangeInput, range, params);
        return range;
      };

      renderInputType.select = function (select, params) {
        select.textContent = '';

        if (params.inputPlaceholder) {
          var placeholder = document.createElement('option');
          setInnerHtml(placeholder, params.inputPlaceholder);
          placeholder.value = '';
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }

        setInputLabel(select, select, params);
        return select;
      };

      renderInputType.radio = function (radio) {
        radio.textContent = '';
        return radio;
      };

      renderInputType.checkbox = function (checkboxContainer, params) {
        var checkbox = getInput(getContent(), 'checkbox');
        checkbox.value = 1;
        checkbox.id = swalClasses.checkbox;
        checkbox.checked = Boolean(params.inputValue);
        var label = checkboxContainer.querySelector('span');
        setInnerHtml(label, params.inputPlaceholder);
        return checkboxContainer;
      };

      renderInputType.textarea = function (textarea, params) {
        textarea.value = params.inputValue;
        setInputPlaceholder(textarea, params);
        setInputLabel(textarea, textarea, params);

        if ('MutationObserver' in window) {
          // #1699
          var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
          var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);

          var outputsize = function outputsize() {
            var contentWidth = textarea.offsetWidth + popupPadding;

            if (contentWidth > initialPopupWidth) {
              getPopup().style.width = "".concat(contentWidth, "px");
            } else {
              getPopup().style.width = null;
            }
          };

          new MutationObserver(outputsize).observe(textarea, {
            attributes: true,
            attributeFilter: ['style']
          });
        }

        return textarea;
      };

      var renderContent = function renderContent(instance, params) {
        var content = getContent().querySelector("#".concat(swalClasses.content)); // Content as HTML

        if (params.html) {
          parseHtmlToContainer(params.html, content);
          show(content, 'block'); // Content as plain text
        } else if (params.text) {
          content.textContent = params.text;
          show(content, 'block'); // No content
        } else {
          hide(content);
        }

        renderInput(instance, params); // Custom class

        applyCustomClass(getContent(), params, 'content');
      };

      var renderFooter = function renderFooter(instance, params) {
        var footer = getFooter();
        toggle(footer, params.footer);

        if (params.footer) {
          parseHtmlToContainer(params.footer, footer);
        } // Custom class


        applyCustomClass(footer, params, 'footer');
      };

      var renderCloseButton = function renderCloseButton(instance, params) {
        var closeButton = getCloseButton();
        setInnerHtml(closeButton, params.closeButtonHtml); // Custom class

        applyCustomClass(closeButton, params, 'closeButton');
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
      };

      var renderIcon = function renderIcon(instance, params) {
        var innerParams = privateProps.innerParams.get(instance); // if the given icon already rendered, apply the styling without re-rendering the icon

        if (innerParams && params.icon === innerParams.icon && getIcon()) {
          applyStyles(getIcon(), params);
          return;
        }

        hideAllIcons();

        if (!params.icon) {
          return;
        }

        if (Object.keys(iconTypes).indexOf(params.icon) !== -1) {
          var icon = elementBySelector(".".concat(swalClasses.icon, ".").concat(iconTypes[params.icon]));
          show(icon); // Custom or default content

          setContent(icon, params);
          applyStyles(icon, params); // Animate icon

          addClass(icon, params.showClass.icon);
        } else {
          error("Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"".concat(params.icon, "\""));
        }
      };

      var hideAllIcons = function hideAllIcons() {
        var icons = getIcons();

        for (var i = 0; i < icons.length; i++) {
          hide(icons[i]);
        }
      };

      var applyStyles = function applyStyles(icon, params) {
        // Icon color
        setColor(icon, params); // Success icon background color

        adjustSuccessIconBackgoundColor(); // Custom class

        applyCustomClass(icon, params, 'icon');
      }; // Adjust success icon background color to match the popup background color


      var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {
        var popup = getPopup();
        var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
        var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');

        for (var i = 0; i < successIconParts.length; i++) {
          successIconParts[i].style.backgroundColor = popupBackgroundColor;
        }
      };

      var setContent = function setContent(icon, params) {
        icon.textContent = '';

        if (params.iconHtml) {
          setInnerHtml(icon, iconContent(params.iconHtml));
        } else if (params.icon === 'success') {
          setInnerHtml(icon, "\n      <div class=\"swal2-success-circular-line-left\"></div>\n      <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n      <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n      <div class=\"swal2-success-circular-line-right\"></div>\n    ");
        } else if (params.icon === 'error') {
          setInnerHtml(icon, "\n      <span class=\"swal2-x-mark\">\n        <span class=\"swal2-x-mark-line-left\"></span>\n        <span class=\"swal2-x-mark-line-right\"></span>\n      </span>\n    ");
        } else {
          var defaultIconHtml = {
            question: '?',
            warning: '!',
            info: 'i'
          };
          setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
        }
      };

      var setColor = function setColor(icon, params) {
        if (!params.iconColor) {
          return;
        }

        icon.style.color = params.iconColor;
        icon.style.borderColor = params.iconColor;

        for (var _i = 0, _arr = ['.swal2-success-line-tip', '.swal2-success-line-long', '.swal2-x-mark-line-left', '.swal2-x-mark-line-right']; _i < _arr.length; _i++) {
          var sel = _arr[_i];
          setStyle(icon, sel, 'backgroundColor', params.iconColor);
        }

        setStyle(icon, '.swal2-success-ring', 'borderColor', params.iconColor);
      };

      var iconContent = function iconContent(content) {
        return "<div class=\"".concat(swalClasses['icon-content'], "\">").concat(content, "</div>");
      };

      var renderImage = function renderImage(instance, params) {
        var image = getImage();

        if (!params.imageUrl) {
          return hide(image);
        }

        show(image, ''); // Src, alt

        image.setAttribute('src', params.imageUrl);
        image.setAttribute('alt', params.imageAlt); // Width, height

        applyNumericalStyle(image, 'width', params.imageWidth);
        applyNumericalStyle(image, 'height', params.imageHeight); // Class

        image.className = swalClasses.image;
        applyCustomClass(image, params, 'image');
      };

      var currentSteps = [];
      /*
       * Global function for chaining sweetAlert popups
       */

      var queue = function queue(steps) {
        var Swal = this;
        currentSteps = steps;

        var resetAndResolve = function resetAndResolve(resolve, value) {
          currentSteps = [];
          resolve(value);
        };

        var queueResult = [];
        return new Promise(function (resolve) {
          (function step(i, callback) {
            if (i < currentSteps.length) {
              document.body.setAttribute('data-swal2-queue-step', i);
              Swal.fire(currentSteps[i]).then(function (result) {
                if (typeof result.value !== 'undefined') {
                  queueResult.push(result.value);
                  step(i + 1);
                } else {
                  resetAndResolve(resolve, {
                    dismiss: result.dismiss
                  });
                }
              });
            } else {
              resetAndResolve(resolve, {
                value: queueResult
              });
            }
          })(0);
        });
      };
      /*
       * Global function for getting the index of current popup in queue
       */

      var getQueueStep = function getQueueStep() {
        return getContainer() && getContainer().getAttribute('data-queue-step');
      };
      /*
       * Global function for inserting a popup to the queue
       */

      var insertQueueStep = function insertQueueStep(step, index) {
        if (index && index < currentSteps.length) {
          return currentSteps.splice(index, 0, step);
        }

        return currentSteps.push(step);
      };
      /*
       * Global function for deleting a popup from the queue
       */

      var deleteQueueStep = function deleteQueueStep(index) {
        if (typeof currentSteps[index] !== 'undefined') {
          currentSteps.splice(index, 1);
        }
      };

      var createStepElement = function createStepElement(step) {
        var stepEl = document.createElement('li');
        addClass(stepEl, swalClasses['progress-step']);
        setInnerHtml(stepEl, step);
        return stepEl;
      };

      var createLineElement = function createLineElement(params) {
        var lineEl = document.createElement('li');
        addClass(lineEl, swalClasses['progress-step-line']);

        if (params.progressStepsDistance) {
          lineEl.style.width = params.progressStepsDistance;
        }

        return lineEl;
      };

      var renderProgressSteps = function renderProgressSteps(instance, params) {
        var progressStepsContainer = getProgressSteps();

        if (!params.progressSteps || params.progressSteps.length === 0) {
          return hide(progressStepsContainer);
        }

        show(progressStepsContainer);
        progressStepsContainer.textContent = '';
        var currentProgressStep = parseInt(params.currentProgressStep === undefined ? getQueueStep() : params.currentProgressStep);

        if (currentProgressStep >= params.progressSteps.length) {
          warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
        }

        params.progressSteps.forEach(function (step, index) {
          var stepEl = createStepElement(step);
          progressStepsContainer.appendChild(stepEl);

          if (index === currentProgressStep) {
            addClass(stepEl, swalClasses['active-progress-step']);
          }

          if (index !== params.progressSteps.length - 1) {
            var lineEl = createLineElement(params);
            progressStepsContainer.appendChild(lineEl);
          }
        });
      };

      var renderTitle = function renderTitle(instance, params) {
        var title = getTitle();
        toggle(title, params.title || params.titleText);

        if (params.title) {
          parseHtmlToContainer(params.title, title);
        }

        if (params.titleText) {
          title.innerText = params.titleText;
        } // Custom class


        applyCustomClass(title, params, 'title');
      };

      var renderHeader = function renderHeader(instance, params) {
        var header = getHeader(); // Custom class

        applyCustomClass(header, params, 'header'); // Progress steps

        renderProgressSteps(instance, params); // Icon

        renderIcon(instance, params); // Image

        renderImage(instance, params); // Title

        renderTitle(instance, params); // Close button

        renderCloseButton(instance, params);
      };

      var renderPopup = function renderPopup(instance, params) {
        var popup = getPopup(); // Width

        applyNumericalStyle(popup, 'width', params.width); // Padding

        applyNumericalStyle(popup, 'padding', params.padding); // Background

        if (params.background) {
          popup.style.background = params.background;
        } // Classes


        addClasses(popup, params);
      };

      var addClasses = function addClasses(popup, params) {
        // Default Class + showClass when updating Swal.update({})
        popup.className = "".concat(swalClasses.popup, " ").concat(isVisible(popup) ? params.showClass.popup : '');

        if (params.toast) {
          addClass([document.documentElement, document.body], swalClasses['toast-shown']);
          addClass(popup, swalClasses.toast);
        } else {
          addClass(popup, swalClasses.modal);
        } // Custom class


        applyCustomClass(popup, params, 'popup');

        if (typeof params.customClass === 'string') {
          addClass(popup, params.customClass);
        } // Icon class (#1842)


        if (params.icon) {
          addClass(popup, swalClasses["icon-".concat(params.icon)]);
        }
      };

      var render = function render(instance, params) {
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderHeader(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);

        if (typeof params.didRender === 'function') {
          params.didRender(getPopup());
        } else if (typeof params.onRender === 'function') {
          params.onRender(getPopup()); // @deprecated
        }
      };

      /*
       * Global function to determine if SweetAlert2 popup is shown
       */

      var isVisible$1 = function isVisible$$1() {
        return isVisible(getPopup());
      };
      /*
       * Global function to click 'Confirm' button
       */

      var clickConfirm = function clickConfirm() {
        return getConfirmButton() && getConfirmButton().click();
      };
      /*
       * Global function to click 'Deny' button
       */

      var clickDeny = function clickDeny() {
        return getDenyButton() && getDenyButton().click();
      };
      /*
       * Global function to click 'Cancel' button
       */

      var clickCancel = function clickCancel() {
        return getCancelButton() && getCancelButton().click();
      };

      function fire() {
        var Swal = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _construct(Swal, args);
      }

      /**
       * Returns an extended version of `Swal` containing `params` as defaults.
       * Useful for reusing Swal configuration.
       *
       * For example:
       *
       * Before:
       * const textPromptOptions = { input: 'text', showCancelButton: true }
       * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
       * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
       *
       * After:
       * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
       * const {value: firstName} = await TextPrompt('What is your first name?')
       * const {value: lastName} = await TextPrompt('What is your last name?')
       *
       * @param mixinParams
       */
      function mixin(mixinParams) {
        var MixinSwal = /*#__PURE__*/function (_this) {
          _inherits(MixinSwal, _this);

          var _super = _createSuper(MixinSwal);

          function MixinSwal() {
            _classCallCheck(this, MixinSwal);

            return _super.apply(this, arguments);
          }

          _createClass(MixinSwal, [{
            key: "_main",
            value: function _main(params) {
              return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, _extends({}, mixinParams, params));
            }
          }]);

          return MixinSwal;
        }(this);

        return MixinSwal;
      }

      /**
       * Show spinner instead of Confirm button
       */

      var showLoading = function showLoading() {
        var popup = getPopup();

        if (!popup) {
          Swal.fire();
        }

        popup = getPopup();
        var actions = getActions();
        var confirmButton = getConfirmButton();
        var loader = getLoader();
        show(actions);
        hide(confirmButton);
        addClass([popup, actions], swalClasses.loading);
        show(loader);
        popup.setAttribute('data-loading', true);
        popup.setAttribute('aria-busy', true);
        popup.focus();
      };

      var RESTORE_FOCUS_TIMEOUT = 100;

      var globalState = {};

      var focusPreviousActiveElement = function focusPreviousActiveElement() {
        if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
          globalState.previousActiveElement.focus();
          globalState.previousActiveElement = null;
        } else if (document.body) {
          document.body.focus();
        }
      }; // Restore previous active (focused) element


      var restoreActiveElement = function restoreActiveElement() {
        return new Promise(function (resolve) {
          var x = window.scrollX;
          var y = window.scrollY;
          globalState.restoreFocusTimeout = setTimeout(function () {
            focusPreviousActiveElement();
            resolve();
          }, RESTORE_FOCUS_TIMEOUT); // issues/900

          /* istanbul ignore if */

          if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            // IE doesn't have scrollX/scrollY support
            window.scrollTo(x, y);
          }
        });
      };

      /**
       * If `timer` parameter is set, returns number of milliseconds of timer remained.
       * Otherwise, returns undefined.
       */

      var getTimerLeft = function getTimerLeft() {
        return globalState.timeout && globalState.timeout.getTimerLeft();
      };
      /**
       * Stop timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */

      var stopTimer = function stopTimer() {
        if (globalState.timeout) {
          stopTimerProgressBar();
          return globalState.timeout.stop();
        }
      };
      /**
       * Resume timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */

      var resumeTimer = function resumeTimer() {
        if (globalState.timeout) {
          var remaining = globalState.timeout.start();
          animateTimerProgressBar(remaining);
          return remaining;
        }
      };
      /**
       * Resume timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */

      var toggleTimer = function toggleTimer() {
        var timer = globalState.timeout;
        return timer && (timer.running ? stopTimer() : resumeTimer());
      };
      /**
       * Increase timer. Returns number of milliseconds of an updated timer.
       * If `timer` parameter isn't set, returns undefined.
       */

      var increaseTimer = function increaseTimer(n) {
        if (globalState.timeout) {
          var remaining = globalState.timeout.increase(n);
          animateTimerProgressBar(remaining, true);
          return remaining;
        }
      };
      /**
       * Check if timer is running. Returns true if timer is running
       * or false if timer is paused or stopped.
       * If `timer` parameter isn't set, returns undefined
       */

      var isTimerRunning = function isTimerRunning() {
        return globalState.timeout && globalState.timeout.isRunning();
      };

      var defaultParams = {
        title: '',
        titleText: '',
        text: '',
        html: '',
        footer: '',
        icon: undefined,
        iconColor: undefined,
        iconHtml: undefined,
        toast: false,
        animation: true,
        showClass: {
          popup: 'swal2-show',
          backdrop: 'swal2-backdrop-show',
          icon: 'swal2-icon-show'
        },
        hideClass: {
          popup: 'swal2-hide',
          backdrop: 'swal2-backdrop-hide',
          icon: 'swal2-icon-hide'
        },
        customClass: undefined,
        target: 'body',
        backdrop: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showDenyButton: false,
        showCancelButton: false,
        preConfirm: undefined,
        preDeny: undefined,
        confirmButtonText: 'OK',
        confirmButtonAriaLabel: '',
        confirmButtonColor: undefined,
        denyButtonText: 'No',
        denyButtonAriaLabel: '',
        denyButtonColor: undefined,
        cancelButtonText: 'Cancel',
        cancelButtonAriaLabel: '',
        cancelButtonColor: undefined,
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusDeny: false,
        focusCancel: false,
        showCloseButton: false,
        closeButtonHtml: '&times;',
        closeButtonAriaLabel: 'Close this dialog',
        loaderHtml: '',
        showLoaderOnConfirm: false,
        imageUrl: undefined,
        imageWidth: undefined,
        imageHeight: undefined,
        imageAlt: '',
        timer: undefined,
        timerProgressBar: false,
        width: undefined,
        padding: undefined,
        background: undefined,
        input: undefined,
        inputPlaceholder: '',
        inputLabel: '',
        inputValue: '',
        inputOptions: {},
        inputAutoTrim: true,
        inputAttributes: {},
        inputValidator: undefined,
        returnInputValueOnDeny: false,
        validationMessage: undefined,
        grow: false,
        position: 'center',
        progressSteps: [],
        currentProgressStep: undefined,
        progressStepsDistance: undefined,
        onBeforeOpen: undefined,
        onOpen: undefined,
        willOpen: undefined,
        didOpen: undefined,
        onRender: undefined,
        didRender: undefined,
        onClose: undefined,
        onAfterClose: undefined,
        willClose: undefined,
        didClose: undefined,
        onDestroy: undefined,
        didDestroy: undefined,
        scrollbarPadding: true
      };
      var updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'background', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'denyButtonAriaLabel', 'denyButtonColor', 'denyButtonText', 'didClose', 'didDestroy', 'footer', 'hideClass', 'html', 'icon', 'iconColor', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'onAfterClose', 'onClose', 'onDestroy', 'progressSteps', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'showDenyButton', 'text', 'title', 'titleText', 'willClose'];
      var deprecatedParams = {
        animation: 'showClass" and "hideClass',
        onBeforeOpen: 'willOpen',
        onOpen: 'didOpen',
        onRender: 'didRender',
        onClose: 'willClose',
        onAfterClose: 'didClose',
        onDestroy: 'didDestroy'
      };
      var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusDeny', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];
      /**
       * Is valid parameter
       * @param {String} paramName
       */

      var isValidParameter = function isValidParameter(paramName) {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
      };
      /**
       * Is valid parameter for Swal.update() method
       * @param {String} paramName
       */

      var isUpdatableParameter = function isUpdatableParameter(paramName) {
        return updatableParams.indexOf(paramName) !== -1;
      };
      /**
       * Is deprecated parameter
       * @param {String} paramName
       */

      var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
        return deprecatedParams[paramName];
      };

      var checkIfParamIsValid = function checkIfParamIsValid(param) {
        if (!isValidParameter(param)) {
          warn("Unknown parameter \"".concat(param, "\""));
        }
      };

      var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
        if (toastIncompatibleParams.indexOf(param) !== -1) {
          warn("The parameter \"".concat(param, "\" is incompatible with toasts"));
        }
      };

      var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
        if (isDeprecatedParameter(param)) {
          warnAboutDeprecation(param, isDeprecatedParameter(param));
        }
      };
      /**
       * Show relevant warnings for given params
       *
       * @param params
       */


      var showWarningsForParams = function showWarningsForParams(params) {
        for (var param in params) {
          checkIfParamIsValid(param);

          if (params.toast) {
            checkIfToastParamIsValid(param);
          }

          checkIfParamIsDeprecated(param);
        }
      };



      var staticMethods = /*#__PURE__*/Object.freeze({
        isValidParameter: isValidParameter,
        isUpdatableParameter: isUpdatableParameter,
        isDeprecatedParameter: isDeprecatedParameter,
        argsToParams: argsToParams,
        isVisible: isVisible$1,
        clickConfirm: clickConfirm,
        clickDeny: clickDeny,
        clickCancel: clickCancel,
        getContainer: getContainer,
        getPopup: getPopup,
        getTitle: getTitle,
        getContent: getContent,
        getHtmlContainer: getHtmlContainer,
        getImage: getImage,
        getIcon: getIcon,
        getIcons: getIcons,
        getInputLabel: getInputLabel,
        getCloseButton: getCloseButton,
        getActions: getActions,
        getConfirmButton: getConfirmButton,
        getDenyButton: getDenyButton,
        getCancelButton: getCancelButton,
        getLoader: getLoader,
        getHeader: getHeader,
        getFooter: getFooter,
        getTimerProgressBar: getTimerProgressBar,
        getFocusableElements: getFocusableElements,
        getValidationMessage: getValidationMessage,
        isLoading: isLoading,
        fire: fire,
        mixin: mixin,
        queue: queue,
        getQueueStep: getQueueStep,
        insertQueueStep: insertQueueStep,
        deleteQueueStep: deleteQueueStep,
        showLoading: showLoading,
        enableLoading: showLoading,
        getTimerLeft: getTimerLeft,
        stopTimer: stopTimer,
        resumeTimer: resumeTimer,
        toggleTimer: toggleTimer,
        increaseTimer: increaseTimer,
        isTimerRunning: isTimerRunning
      });

      /**
       * Enables buttons and hide loader.
       */

      function hideLoading() {
        // do nothing if popup is closed
        var innerParams = privateProps.innerParams.get(this);

        if (!innerParams) {
          return;
        }

        var domCache = privateProps.domCache.get(this);
        hide(domCache.loader);

        if (innerParams.showConfirmButton) {
          show(domCache.confirmButton, 'inline-block');
        } else if (!innerParams.showConfirmButton && !innerParams.showCancelButton) {
          hide(domCache.actions);
        }

        removeClass([domCache.popup, domCache.actions], swalClasses.loading);
        domCache.popup.removeAttribute('aria-busy');
        domCache.popup.removeAttribute('data-loading');
        domCache.confirmButton.disabled = false;
        domCache.denyButton.disabled = false;
        domCache.cancelButton.disabled = false;
      }

      function getInput$1(instance) {
        var innerParams = privateProps.innerParams.get(instance || this);
        var domCache = privateProps.domCache.get(instance || this);

        if (!domCache) {
          return null;
        }

        return getInput(domCache.content, innerParams.input);
      }

      var fixScrollbar = function fixScrollbar() {
        // for queues, do not do this more than once
        if (states.previousBodyPadding !== null) {
          return;
        } // if the body has overflow


        if (document.body.scrollHeight > window.innerHeight) {
          // add padding so the content doesn't shift after removal of scrollbar
          states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
          document.body.style.paddingRight = "".concat(states.previousBodyPadding + measureScrollbar(), "px");
        }
      };
      var undoScrollbar = function undoScrollbar() {
        if (states.previousBodyPadding !== null) {
          document.body.style.paddingRight = "".concat(states.previousBodyPadding, "px");
          states.previousBodyPadding = null;
        }
      };

      /* istanbul ignore file */

      var iOSfix = function iOSfix() {
        var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;

        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
          var offset = document.body.scrollTop;
          document.body.style.top = "".concat(offset * -1, "px");
          addClass(document.body, swalClasses.iosfix);
          lockBodyScroll();
          addBottomPaddingForTallPopups(); // #1948
        }
      };

      var addBottomPaddingForTallPopups = function addBottomPaddingForTallPopups() {
        var safari = !navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i);

        if (safari) {
          var bottomPanelHeight = 44;

          if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {
            getContainer().style.paddingBottom = "".concat(bottomPanelHeight, "px");
          }
        }
      };

      var lockBodyScroll = function lockBodyScroll() {
        // #1246
        var container = getContainer();
        var preventTouchMove;

        container.ontouchstart = function (e) {
          preventTouchMove = shouldPreventTouchMove(e);
        };

        container.ontouchmove = function (e) {
          if (preventTouchMove) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
      };

      var shouldPreventTouchMove = function shouldPreventTouchMove(event) {
        var target = event.target;
        var container = getContainer();

        if (event.touches && event.touches.length && event.touches[0].touchType === 'stylus') {
          // #1786
          return false;
        }

        if (target === container) {
          return true;
        }

        if (!isScrollable(container) && target.tagName !== 'INPUT' && // #1603
        !(isScrollable(getContent()) && // #1944
        getContent().contains(target))) {
          return true;
        }

        return false;
      };

      var undoIOSfix = function undoIOSfix() {
        if (hasClass(document.body, swalClasses.iosfix)) {
          var offset = parseInt(document.body.style.top, 10);
          removeClass(document.body, swalClasses.iosfix);
          document.body.style.top = '';
          document.body.scrollTop = offset * -1;
        }
      };

      /* istanbul ignore file */

      var isIE11 = function isIE11() {
        return !!window.MSInputMethodContext && !!document.documentMode;
      }; // Fix IE11 centering sweetalert2/issues/933


      var fixVerticalPositionIE = function fixVerticalPositionIE() {
        var container = getContainer();
        var popup = getPopup();
        container.style.removeProperty('align-items');

        if (popup.offsetTop < 0) {
          container.style.alignItems = 'flex-start';
        }
      };

      var IEfix = function IEfix() {
        if (typeof window !== 'undefined' && isIE11()) {
          fixVerticalPositionIE();
          window.addEventListener('resize', fixVerticalPositionIE);
        }
      };
      var undoIEfix = function undoIEfix() {
        if (typeof window !== 'undefined' && isIE11()) {
          window.removeEventListener('resize', fixVerticalPositionIE);
        }
      };

      // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
      // elements not within the active modal dialog will not be surfaced if a user opens a screen
      // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.

      var setAriaHidden = function setAriaHidden() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function (el) {
          if (el === getContainer() || contains(el, getContainer())) {
            return;
          }

          if (el.hasAttribute('aria-hidden')) {
            el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));
          }

          el.setAttribute('aria-hidden', 'true');
        });
      };
      var unsetAriaHidden = function unsetAriaHidden() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function (el) {
          if (el.hasAttribute('data-previous-aria-hidden')) {
            el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
            el.removeAttribute('data-previous-aria-hidden');
          } else {
            el.removeAttribute('aria-hidden');
          }
        });
      };

      /**
       * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
       * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
       * This is the approach that Babel will probably take to implement private methods/fields
       *   https://github.com/tc39/proposal-private-methods
       *   https://github.com/babel/babel/pull/7555
       * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
       *   then we can use that language feature.
       */
      var privateMethods = {
        swalPromiseResolve: new WeakMap()
      };

      /*
       * Instance method to close sweetAlert
       */

      function removePopupAndResetState(instance, container, isToast$$1, didClose) {
        if (isToast$$1) {
          triggerDidCloseAndDispose(instance, didClose);
        } else {
          restoreActiveElement().then(function () {
            return triggerDidCloseAndDispose(instance, didClose);
          });
          globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = false;
        }

        if (container.parentNode && !document.body.getAttribute('data-swal2-queue-step')) {
          container.parentNode.removeChild(container);
        }

        if (isModal()) {
          undoScrollbar();
          undoIOSfix();
          undoIEfix();
          unsetAriaHidden();
        }

        removeBodyClasses();
      }

      function removeBodyClasses() {
        removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);
      }

      function close(resolveValue) {
        var popup = getPopup();

        if (!popup) {
          return;
        }

        resolveValue = prepareResolveValue(resolveValue);
        var innerParams = privateProps.innerParams.get(this);

        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
          return;
        }

        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        removeClass(popup, innerParams.showClass.popup);
        addClass(popup, innerParams.hideClass.popup);
        var backdrop = getContainer();
        removeClass(backdrop, innerParams.showClass.backdrop);
        addClass(backdrop, innerParams.hideClass.backdrop);
        handlePopupAnimation(this, popup, innerParams); // Resolve Swal promise

        swalPromiseResolve(resolveValue);
      }

      var prepareResolveValue = function prepareResolveValue(resolveValue) {
        // When user calls Swal.close()
        if (typeof resolveValue === 'undefined') {
          return {
            isConfirmed: false,
            isDenied: false,
            isDismissed: true
          };
        }

        return _extends({
          isConfirmed: false,
          isDenied: false,
          isDismissed: false
        }, resolveValue);
      };

      var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
        var container = getContainer(); // If animation is supported, animate

        var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
        var onClose = innerParams.onClose,
            onAfterClose = innerParams.onAfterClose,
            willClose = innerParams.willClose,
            didClose = innerParams.didClose;
        runDidClose(popup, willClose, onClose);

        if (animationIsSupported) {
          animatePopup(instance, popup, container, didClose || onAfterClose);
        } else {
          // Otherwise, remove immediately
          removePopupAndResetState(instance, container, isToast(), didClose || onAfterClose);
        }
      };

      var runDidClose = function runDidClose(popup, willClose, onClose) {
        if (willClose !== null && typeof willClose === 'function') {
          willClose(popup);
        } else if (onClose !== null && typeof onClose === 'function') {
          onClose(popup); // @deprecated
        }
      };

      var animatePopup = function animatePopup(instance, popup, container, didClose) {
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), didClose);
        popup.addEventListener(animationEndEvent, function (e) {
          if (e.target === popup) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
          }
        });
      };

      var triggerDidCloseAndDispose = function triggerDidCloseAndDispose(instance, didClose) {
        setTimeout(function () {
          if (typeof didClose === 'function') {
            didClose();
          }

          instance._destroy();
        });
      };

      function setButtonsDisabled(instance, buttons, disabled) {
        var domCache = privateProps.domCache.get(instance);
        buttons.forEach(function (button) {
          domCache[button].disabled = disabled;
        });
      }

      function setInputDisabled(input, disabled) {
        if (!input) {
          return false;
        }

        if (input.type === 'radio') {
          var radiosContainer = input.parentNode.parentNode;
          var radios = radiosContainer.querySelectorAll('input');

          for (var i = 0; i < radios.length; i++) {
            radios[i].disabled = disabled;
          }
        } else {
          input.disabled = disabled;
        }
      }

      function enableButtons() {
        setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], false);
      }
      function disableButtons() {
        setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], true);
      }
      function enableInput() {
        return setInputDisabled(this.getInput(), false);
      }
      function disableInput() {
        return setInputDisabled(this.getInput(), true);
      }

      function showValidationMessage(error) {
        var domCache = privateProps.domCache.get(this);
        var params = privateProps.innerParams.get(this);
        setInnerHtml(domCache.validationMessage, error);
        domCache.validationMessage.className = swalClasses['validation-message'];

        if (params.customClass && params.customClass.validationMessage) {
          addClass(domCache.validationMessage, params.customClass.validationMessage);
        }

        show(domCache.validationMessage);
        var input = this.getInput();

        if (input) {
          input.setAttribute('aria-invalid', true);
          input.setAttribute('aria-describedBy', swalClasses['validation-message']);
          focusInput(input);
          addClass(input, swalClasses.inputerror);
        }
      } // Hide block with validation message

      function resetValidationMessage$1() {
        var domCache = privateProps.domCache.get(this);

        if (domCache.validationMessage) {
          hide(domCache.validationMessage);
        }

        var input = this.getInput();

        if (input) {
          input.removeAttribute('aria-invalid');
          input.removeAttribute('aria-describedBy');
          removeClass(input, swalClasses.inputerror);
        }
      }

      function getProgressSteps$1() {
        var domCache = privateProps.domCache.get(this);
        return domCache.progressSteps;
      }

      var Timer = /*#__PURE__*/function () {
        function Timer(callback, delay) {
          _classCallCheck(this, Timer);

          this.callback = callback;
          this.remaining = delay;
          this.running = false;
          this.start();
        }

        _createClass(Timer, [{
          key: "start",
          value: function start() {
            if (!this.running) {
              this.running = true;
              this.started = new Date();
              this.id = setTimeout(this.callback, this.remaining);
            }

            return this.remaining;
          }
        }, {
          key: "stop",
          value: function stop() {
            if (this.running) {
              this.running = false;
              clearTimeout(this.id);
              this.remaining -= new Date() - this.started;
            }

            return this.remaining;
          }
        }, {
          key: "increase",
          value: function increase(n) {
            var running = this.running;

            if (running) {
              this.stop();
            }

            this.remaining += n;

            if (running) {
              this.start();
            }

            return this.remaining;
          }
        }, {
          key: "getTimerLeft",
          value: function getTimerLeft() {
            if (this.running) {
              this.stop();
              this.start();
            }

            return this.remaining;
          }
        }, {
          key: "isRunning",
          value: function isRunning() {
            return this.running;
          }
        }]);

        return Timer;
      }();

      var defaultInputValidators = {
        email: function email(string, validationMessage) {
          return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
        },
        url: function url(string, validationMessage) {
          // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
          return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
        }
      };

      function setDefaultInputValidators(params) {
        // Use default `inputValidator` for supported input types if not provided
        if (!params.inputValidator) {
          Object.keys(defaultInputValidators).forEach(function (key) {
            if (params.input === key) {
              params.inputValidator = defaultInputValidators[key];
            }
          });
        }
      }

      function validateCustomTargetElement(params) {
        // Determine if the custom target element is valid
        if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
          warn('Target parameter is not valid, defaulting to "body"');
          params.target = 'body';
        }
      }
      /**
       * Set type, text and actions on popup
       *
       * @param params
       * @returns {boolean}
       */


      function setParameters(params) {
        setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm

        if (params.showLoaderOnConfirm && !params.preConfirm) {
          warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
        } // params.animation will be actually used in renderPopup.js
        // but in case when params.animation is a function, we need to call that function
        // before popup (re)initialization, so it'll be possible to check Swal.isVisible()
        // inside the params.animation function


        params.animation = callIfFunction(params.animation);
        validateCustomTargetElement(params); // Replace newlines with <br> in title

        if (typeof params.title === 'string') {
          params.title = params.title.split('\n').join('<br />');
        }

        init(params);
      }

      var SHOW_CLASS_TIMEOUT = 10;
      /**
       * Open popup, add necessary classes and styles, fix scrollbar
       *
       * @param params
       */

      var openPopup = function openPopup(params) {
        var container = getContainer();
        var popup = getPopup();

        if (typeof params.willOpen === 'function') {
          params.willOpen(popup);
        } else if (typeof params.onBeforeOpen === 'function') {
          params.onBeforeOpen(popup); // @deprecated
        }

        var bodyStyles = window.getComputedStyle(document.body);
        var initialBodyOverflow = bodyStyles.overflowY;
        addClasses$1(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'

        setTimeout(function () {
          setScrollingVisibility(container, popup);
        }, SHOW_CLASS_TIMEOUT);

        if (isModal()) {
          fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
          setAriaHidden();
        }

        if (!isToast() && !globalState.previousActiveElement) {
          globalState.previousActiveElement = document.activeElement;
        }

        runDidOpen(popup, params);
        removeClass(container, swalClasses['no-transition']);
      };

      var runDidOpen = function runDidOpen(popup, params) {
        if (typeof params.didOpen === 'function') {
          setTimeout(function () {
            return params.didOpen(popup);
          });
        } else if (typeof params.onOpen === 'function') {
          setTimeout(function () {
            return params.onOpen(popup);
          }); // @deprecated
        }
      };

      var swalOpenAnimationFinished = function swalOpenAnimationFinished(event) {
        var popup = getPopup();

        if (event.target !== popup) {
          return;
        }

        var container = getContainer();
        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
        container.style.overflowY = 'auto';
      };

      var setScrollingVisibility = function setScrollingVisibility(container, popup) {
        if (animationEndEvent && hasCssAnimation(popup)) {
          container.style.overflowY = 'hidden';
          popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
        } else {
          container.style.overflowY = 'auto';
        }
      };

      var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding, initialBodyOverflow) {
        iOSfix();
        IEfix();

        if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
          fixScrollbar();
        } // sweetalert2/issues/1247


        setTimeout(function () {
          container.scrollTop = 0;
        });
      };

      var addClasses$1 = function addClasses(container, popup, params) {
        addClass(container, params.showClass.backdrop); // the workaround with setting/unsetting opacity is needed for #2019 and 2059

        popup.style.setProperty('opacity', '0', 'important');
        show(popup);
        setTimeout(function () {
          // Animate popup right after showing it
          addClass(popup, params.showClass.popup); // and remove the opacity workaround

          popup.style.removeProperty('opacity');
        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062

        addClass([document.documentElement, document.body], swalClasses.shown);

        if (params.heightAuto && params.backdrop && !params.toast) {
          addClass([document.documentElement, document.body], swalClasses['height-auto']);
        }
      };

      var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
        if (params.input === 'select' || params.input === 'radio') {
          handleInputOptions(instance, params);
        } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(params.input) !== -1 && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
          handleInputValue(instance, params);
        }
      };
      var getInputValue = function getInputValue(instance, innerParams) {
        var input = instance.getInput();

        if (!input) {
          return null;
        }

        switch (innerParams.input) {
          case 'checkbox':
            return getCheckboxValue(input);

          case 'radio':
            return getRadioValue(input);

          case 'file':
            return getFileValue(input);

          default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
      };

      var getCheckboxValue = function getCheckboxValue(input) {
        return input.checked ? 1 : 0;
      };

      var getRadioValue = function getRadioValue(input) {
        return input.checked ? input.value : null;
      };

      var getFileValue = function getFileValue(input) {
        return input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
      };

      var handleInputOptions = function handleInputOptions(instance, params) {
        var content = getContent();

        var processInputOptions = function processInputOptions(inputOptions) {
          return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
        };

        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
          showLoading();
          asPromise(params.inputOptions).then(function (inputOptions) {
            instance.hideLoading();
            processInputOptions(inputOptions);
          });
        } else if (_typeof(params.inputOptions) === 'object') {
          processInputOptions(params.inputOptions);
        } else {
          error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
        }
      };

      var handleInputValue = function handleInputValue(instance, params) {
        var input = instance.getInput();
        hide(input);
        asPromise(params.inputValue).then(function (inputValue) {
          input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : "".concat(inputValue);
          show(input);
          input.focus();
          instance.hideLoading();
        })["catch"](function (err) {
          error("Error in inputValue promise: ".concat(err));
          input.value = '';
          show(input);
          input.focus();
          instance.hideLoading();
        });
      };

      var populateInputOptions = {
        select: function select(content, inputOptions, params) {
          var select = getChildByClass(content, swalClasses.select);

          var renderOption = function renderOption(parent, optionLabel, optionValue) {
            var option = document.createElement('option');
            option.value = optionValue;
            setInnerHtml(option, optionLabel);

            if (params.inputValue.toString() === optionValue.toString()) {
              option.selected = true;
            }

            parent.appendChild(option);
          };

          inputOptions.forEach(function (inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1]; // <optgroup> spec:
            // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
            // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
            // check whether this is a <optgroup>

            if (Array.isArray(optionLabel)) {
              // if it is an array, then it is an <optgroup>
              var optgroup = document.createElement('optgroup');
              optgroup.label = optionValue;
              optgroup.disabled = false; // not configurable for now

              select.appendChild(optgroup);
              optionLabel.forEach(function (o) {
                return renderOption(optgroup, o[1], o[0]);
              });
            } else {
              // case of <option>
              renderOption(select, optionLabel, optionValue);
            }
          });
          select.focus();
        },
        radio: function radio(content, inputOptions, params) {
          var radio = getChildByClass(content, swalClasses.radio);
          inputOptions.forEach(function (inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement('input');
            var radioLabelElement = document.createElement('label');
            radioInput.type = 'radio';
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;

            if (params.inputValue.toString() === radioValue.toString()) {
              radioInput.checked = true;
            }

            var label = document.createElement('span');
            setInnerHtml(label, radioLabel);
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio.appendChild(radioLabelElement);
          });
          var radios = radio.querySelectorAll('input');

          if (radios.length) {
            radios[0].focus();
          }
        }
      };
      /**
       * Converts `inputOptions` into an array of `[value, label]`s
       * @param inputOptions
       */

      var formatInputOptions = function formatInputOptions(inputOptions) {
        var result = [];

        if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
          inputOptions.forEach(function (value, key) {
            var valueFormatted = value;

            if (_typeof(valueFormatted) === 'object') {
              // case of <optgroup>
              valueFormatted = formatInputOptions(valueFormatted);
            }

            result.push([key, valueFormatted]);
          });
        } else {
          Object.keys(inputOptions).forEach(function (key) {
            var valueFormatted = inputOptions[key];

            if (_typeof(valueFormatted) === 'object') {
              // case of <optgroup>
              valueFormatted = formatInputOptions(valueFormatted);
            }

            result.push([key, valueFormatted]);
          });
        }

        return result;
      };

      var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {
        instance.disableButtons();

        if (innerParams.input) {
          handleConfirmOrDenyWithInput(instance, innerParams, 'confirm');
        } else {
          confirm(instance, innerParams, true);
        }
      };
      var handleDenyButtonClick = function handleDenyButtonClick(instance, innerParams) {
        instance.disableButtons();

        if (innerParams.returnInputValueOnDeny) {
          handleConfirmOrDenyWithInput(instance, innerParams, 'deny');
        } else {
          deny(instance, innerParams, false);
        }
      };
      var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
      };

      var handleConfirmOrDenyWithInput = function handleConfirmOrDenyWithInput(instance, innerParams, type
      /* type is either 'confirm' or 'deny' */
      ) {
        var inputValue = getInputValue(instance, innerParams);

        if (innerParams.inputValidator) {
          handleInputValidator(instance, innerParams, inputValue);
        } else if (!instance.getInput().checkValidity()) {
          instance.enableButtons();
          instance.showValidationMessage(innerParams.validationMessage);
        } else if (type === 'deny') {
          deny(instance, innerParams, inputValue);
        } else {
          confirm(instance, innerParams, inputValue);
        }
      };

      var handleInputValidator = function handleInputValidator(instance, innerParams, inputValue) {
        instance.disableInput();
        var validationPromise = Promise.resolve().then(function () {
          return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
        });
        validationPromise.then(function (validationMessage) {
          instance.enableButtons();
          instance.enableInput();

          if (validationMessage) {
            instance.showValidationMessage(validationMessage);
          } else {
            confirm(instance, innerParams, inputValue);
          }
        });
      };

      var deny = function deny(instance, innerParams, value) {
        if (innerParams.preDeny) {
          var preDenyPromise = Promise.resolve().then(function () {
            return asPromise(innerParams.preDeny(value, innerParams.validationMessage));
          });
          preDenyPromise.then(function (preDenyValue) {
            if (preDenyValue === false) {
              instance.hideLoading();
            } else {
              instance.closePopup({
                isDenied: true,
                value: typeof preDenyValue === 'undefined' ? value : preDenyValue
              });
            }
          });
        } else {
          instance.closePopup({
            isDenied: true,
            value: value
          });
        }
      };

      var succeedWith = function succeedWith(instance, value) {
        instance.closePopup({
          isConfirmed: true,
          value: value
        });
      };

      var confirm = function confirm(instance, innerParams, value) {
        if (innerParams.showLoaderOnConfirm) {
          showLoading(); // TODO: make showLoading an *instance* method
        }

        if (innerParams.preConfirm) {
          instance.resetValidationMessage();
          var preConfirmPromise = Promise.resolve().then(function () {
            return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
          });
          preConfirmPromise.then(function (preConfirmValue) {
            if (isVisible(getValidationMessage()) || preConfirmValue === false) {
              instance.hideLoading();
            } else {
              succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
            }
          });
        } else {
          succeedWith(instance, value);
        }
      };

      var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {
        if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
          globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = false;
        }

        if (!innerParams.toast) {
          globalState.keydownHandler = function (e) {
            return keydownHandler(instance, e, dismissWith);
          };

          globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
          globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
          globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = true;
        }
      }; // Focus handling

      var setFocus = function setFocus(innerParams, index, increment) {
        var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match

        for (var i = 0; i < focusableElements.length; i++) {
          index = index + increment; // rollover to first item

          if (index === focusableElements.length) {
            index = 0; // go to last item
          } else if (index === -1) {
            index = focusableElements.length - 1;
          }

          return focusableElements[index].focus();
        } // no visible focusable elements, focus the popup


        getPopup().focus();
      };
      var arrowKeysNextButton = ['ArrowRight', 'ArrowDown', 'Right', 'Down' // IE11
      ];
      var arrowKeysPreviousButton = ['ArrowLeft', 'ArrowUp', 'Left', 'Up' // IE11
      ];
      var escKeys = ['Escape', 'Esc' // IE11
      ];

      var keydownHandler = function keydownHandler(instance, e, dismissWith) {
        var innerParams = privateProps.innerParams.get(instance);

        if (innerParams.stopKeydownPropagation) {
          e.stopPropagation();
        } // ENTER


        if (e.key === 'Enter') {
          handleEnter(instance, e, innerParams); // TAB
        } else if (e.key === 'Tab') {
          handleTab(e, innerParams); // ARROWS - switch focus between buttons
        } else if ([].concat(arrowKeysNextButton, arrowKeysPreviousButton).indexOf(e.key) !== -1) {
          handleArrows(e.key); // ESC
        } else if (escKeys.indexOf(e.key) !== -1) {
          handleEsc(e, innerParams, dismissWith);
        }
      };

      var handleEnter = function handleEnter(instance, e, innerParams) {
        // #720 #721
        if (e.isComposing) {
          return;
        }

        if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
          if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {
            return; // do not submit
          }

          clickConfirm();
          e.preventDefault();
        }
      };

      var handleTab = function handleTab(e, innerParams) {
        var targetElement = e.target;
        var focusableElements = getFocusableElements();
        var btnIndex = -1;

        for (var i = 0; i < focusableElements.length; i++) {
          if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
          }
        }

        if (!e.shiftKey) {
          // Cycle to the next button
          setFocus(innerParams, btnIndex, 1);
        } else {
          // Cycle to the prev button
          setFocus(innerParams, btnIndex, -1);
        }

        e.stopPropagation();
        e.preventDefault();
      };

      var handleArrows = function handleArrows(key) {
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();

        if (!([confirmButton, denyButton, cancelButton].indexOf(document.activeElement) !== -1)) {
          return;
        }

        var sibling = arrowKeysNextButton.indexOf(key) !== -1 ? 'nextElementSibling' : 'previousElementSibling';
        var buttonToFocus = document.activeElement[sibling];

        if (buttonToFocus) {
          buttonToFocus.focus();
        }
      };

      var handleEsc = function handleEsc(e, innerParams, dismissWith) {
        if (callIfFunction(innerParams.allowEscapeKey)) {
          e.preventDefault();
          dismissWith(DismissReason.esc);
        }
      };

      var handlePopupClick = function handlePopupClick(instance, domCache, dismissWith) {
        var innerParams = privateProps.innerParams.get(instance);

        if (innerParams.toast) {
          handleToastClick(instance, domCache, dismissWith);
        } else {
          // Ignore click events that had mousedown on the popup but mouseup on the container
          // This can happen when the user drags a slider
          handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup

          handleContainerMousedown(domCache);
          handleModalClick(instance, domCache, dismissWith);
        }
      };

      var handleToastClick = function handleToastClick(instance, domCache, dismissWith) {
        // Closing toast by internal click
        domCache.popup.onclick = function () {
          var innerParams = privateProps.innerParams.get(instance);

          if (innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
            return;
          }

          dismissWith(DismissReason.close);
        };
      };

      var ignoreOutsideClick = false;

      var handleModalMousedown = function handleModalMousedown(domCache) {
        domCache.popup.onmousedown = function () {
          domCache.container.onmouseup = function (e) {
            domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't
            // have any other direct children aside of the popup

            if (e.target === domCache.container) {
              ignoreOutsideClick = true;
            }
          };
        };
      };

      var handleContainerMousedown = function handleContainerMousedown(domCache) {
        domCache.container.onmousedown = function () {
          domCache.popup.onmouseup = function (e) {
            domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup

            if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
              ignoreOutsideClick = true;
            }
          };
        };
      };

      var handleModalClick = function handleModalClick(instance, domCache, dismissWith) {
        domCache.container.onclick = function (e) {
          var innerParams = privateProps.innerParams.get(instance);

          if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
          }

          if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(DismissReason.backdrop);
          }
        };
      };

      function _main(userParams) {
        showWarningsForParams(userParams);

        if (globalState.currentInstance) {
          globalState.currentInstance._destroy();
        }

        globalState.currentInstance = this;
        var innerParams = prepareParams(userParams);
        setParameters(innerParams);
        Object.freeze(innerParams); // clear the previous timer

        if (globalState.timeout) {
          globalState.timeout.stop();
          delete globalState.timeout;
        } // clear the restore focus timeout


        clearTimeout(globalState.restoreFocusTimeout);
        var domCache = populateDomCache(this);
        render(this, innerParams);
        privateProps.innerParams.set(this, innerParams);
        return swalPromise(this, domCache, innerParams);
      }

      var prepareParams = function prepareParams(userParams) {
        var showClass = _extends({}, defaultParams.showClass, userParams.showClass);

        var hideClass = _extends({}, defaultParams.hideClass, userParams.hideClass);

        var params = _extends({}, defaultParams, userParams);

        params.showClass = showClass;
        params.hideClass = hideClass; // @deprecated

        if (userParams.animation === false) {
          params.showClass = {
            popup: 'swal2-noanimation',
            backdrop: 'swal2-noanimation'
          };
          params.hideClass = {};
        }

        return params;
      };

      var swalPromise = function swalPromise(instance, domCache, innerParams) {
        return new Promise(function (resolve) {
          // functions to handle all closings/dismissals
          var dismissWith = function dismissWith(dismiss) {
            instance.closePopup({
              isDismissed: true,
              dismiss: dismiss
            });
          };

          privateMethods.swalPromiseResolve.set(instance, resolve);

          domCache.confirmButton.onclick = function () {
            return handleConfirmButtonClick(instance, innerParams);
          };

          domCache.denyButton.onclick = function () {
            return handleDenyButtonClick(instance, innerParams);
          };

          domCache.cancelButton.onclick = function () {
            return handleCancelButtonClick(instance, dismissWith);
          };

          domCache.closeButton.onclick = function () {
            return dismissWith(DismissReason.close);
          };

          handlePopupClick(instance, domCache, dismissWith);
          addKeydownHandler(instance, globalState, innerParams, dismissWith);

          if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
            addClass(document.body, swalClasses['toast-column']);
          } else {
            removeClass(document.body, swalClasses['toast-column']);
          }

          handleInputOptionsAndValue(instance, innerParams);
          openPopup(innerParams);
          setupTimer(globalState, innerParams, dismissWith);
          initFocus(domCache, innerParams); // Scroll container to top on open (#1247, #1946)

          setTimeout(function () {
            domCache.container.scrollTop = 0;
          });
        });
      };

      var populateDomCache = function populateDomCache(instance) {
        var domCache = {
          popup: getPopup(),
          container: getContainer(),
          content: getContent(),
          actions: getActions(),
          confirmButton: getConfirmButton(),
          denyButton: getDenyButton(),
          cancelButton: getCancelButton(),
          loader: getLoader(),
          closeButton: getCloseButton(),
          validationMessage: getValidationMessage(),
          progressSteps: getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
      };

      var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {
        var timerProgressBar = getTimerProgressBar();
        hide(timerProgressBar);

        if (innerParams.timer) {
          globalState$$1.timeout = new Timer(function () {
            dismissWith('timer');
            delete globalState$$1.timeout;
          }, innerParams.timer);

          if (innerParams.timerProgressBar) {
            show(timerProgressBar);
            setTimeout(function () {
              if (globalState$$1.timeout.running) {
                // timer can be already stopped at this point
                animateTimerProgressBar(innerParams.timer);
              }
            });
          }
        }
      };

      var initFocus = function initFocus(domCache, innerParams) {
        if (innerParams.toast) {
          return;
        }

        if (!callIfFunction(innerParams.allowEnterKey)) {
          return blurActiveElement();
        }

        if (!focusButton(domCache, innerParams)) {
          setFocus(innerParams, -1, 1);
        }
      };

      var focusButton = function focusButton(domCache, innerParams) {
        if (innerParams.focusDeny && isVisible(domCache.denyButton)) {
          domCache.denyButton.focus();
          return true;
        }

        if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
          domCache.cancelButton.focus();
          return true;
        }

        if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
          domCache.confirmButton.focus();
          return true;
        }

        return false;
      };

      var blurActiveElement = function blurActiveElement() {
        if (document.activeElement && typeof document.activeElement.blur === 'function') {
          document.activeElement.blur();
        }
      };

      /**
       * Updates popup parameters.
       */

      function update(params) {
        var popup = getPopup();
        var innerParams = privateProps.innerParams.get(this);

        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
          return warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
        }

        var validUpdatableParams = {}; // assign valid params from `params` to `defaults`

        Object.keys(params).forEach(function (param) {
          if (Swal.isUpdatableParameter(param)) {
            validUpdatableParams[param] = params[param];
          } else {
            warn("Invalid parameter to update: \"".concat(param, "\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\n\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md"));
          }
        });

        var updatedParams = _extends({}, innerParams, validUpdatableParams);

        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
          params: {
            value: _extends({}, this.params, params),
            writable: false,
            enumerable: true
          }
        });
      }

      function _destroy() {
        var domCache = privateProps.domCache.get(this);
        var innerParams = privateProps.innerParams.get(this);

        if (!innerParams) {
          return; // This instance has already been destroyed
        } // Check if there is another Swal closing


        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
          globalState.swalCloseEventFinishedCallback();
          delete globalState.swalCloseEventFinishedCallback;
        } // Check if there is a swal disposal defer timer


        if (globalState.deferDisposalTimer) {
          clearTimeout(globalState.deferDisposalTimer);
          delete globalState.deferDisposalTimer;
        }

        runDidDestroy(innerParams);
        disposeSwal(this);
      }

      var runDidDestroy = function runDidDestroy(innerParams) {
        if (typeof innerParams.didDestroy === 'function') {
          innerParams.didDestroy();
        } else if (typeof innerParams.onDestroy === 'function') {
          innerParams.onDestroy(); // @deprecated
        }
      };

      var disposeSwal = function disposeSwal(instance) {
        // Unset this.params so GC will dispose it (#1569)
        delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)

        delete globalState.keydownHandler;
        delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)

        unsetWeakMaps(privateProps);
        unsetWeakMaps(privateMethods);
      };

      var unsetWeakMaps = function unsetWeakMaps(obj) {
        for (var i in obj) {
          obj[i] = new WeakMap();
        }
      };



      var instanceMethods = /*#__PURE__*/Object.freeze({
        hideLoading: hideLoading,
        disableLoading: hideLoading,
        getInput: getInput$1,
        close: close,
        closePopup: close,
        closeModal: close,
        closeToast: close,
        enableButtons: enableButtons,
        disableButtons: disableButtons,
        enableInput: enableInput,
        disableInput: disableInput,
        showValidationMessage: showValidationMessage,
        resetValidationMessage: resetValidationMessage$1,
        getProgressSteps: getProgressSteps$1,
        _main: _main,
        update: update,
        _destroy: _destroy
      });

      var currentInstance;

      var SweetAlert = /*#__PURE__*/function () {
        function SweetAlert() {
          _classCallCheck(this, SweetAlert);

          // Prevent run in Node env
          if (typeof window === 'undefined') {
            return;
          } // Check for the existence of Promise


          if (typeof Promise === 'undefined') {
            error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');
          }

          currentInstance = this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var outerParams = Object.freeze(this.constructor.argsToParams(args));
          Object.defineProperties(this, {
            params: {
              value: outerParams,
              writable: false,
              enumerable: true,
              configurable: true
            }
          });

          var promise = this._main(this.params);

          privateProps.promise.set(this, promise);
        } // `catch` cannot be the name of a module export, so we define our thenable methods here instead


        _createClass(SweetAlert, [{
          key: "then",
          value: function then(onFulfilled) {
            var promise = privateProps.promise.get(this);
            return promise.then(onFulfilled);
          }
        }, {
          key: "finally",
          value: function _finally(onFinally) {
            var promise = privateProps.promise.get(this);
            return promise["finally"](onFinally);
          }
        }]);

        return SweetAlert;
      }(); // Assign instance methods from src/instanceMethods/*.js to prototype


      _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor


      _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility


      Object.keys(instanceMethods).forEach(function (key) {
        SweetAlert[key] = function () {
          if (currentInstance) {
            var _currentInstance;

            return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
          }
        };
      });
      SweetAlert.DismissReason = DismissReason;
      SweetAlert.version = '10.8.1';

      var Swal = SweetAlert;
      Swal["default"] = Swal;

      return Swal;

    }));
    if (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.Sweetalert2){  commonjsGlobal.swal = commonjsGlobal.sweetAlert = commonjsGlobal.Swal = commonjsGlobal.SweetAlert = commonjsGlobal.Sweetalert2;}

    "undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t;}catch(e){n.innerText=t;}}(document,".swal2-popup.swal2-toast{flex-direction:row;align-items:center;width:auto;padding:.625em;overflow-y:hidden;background:#fff;box-shadow:0 0 .625em #d9d9d9}.swal2-popup.swal2-toast .swal2-header{flex-direction:row;padding:0}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:static;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;padding:0;font-size:1em}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{font-size:.25em}}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{flex-basis:auto!important;width:auto;height:auto;margin:0 .3125em;padding:0}.swal2-popup.swal2-toast .swal2-styled{margin:0 .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:flex;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-bottom-end>:first-child,.swal2-container.swal2-bottom-left>:first-child,.swal2-container.swal2-bottom-right>:first-child,.swal2-container.swal2-bottom-start>:first-child,.swal2-container.swal2-bottom>:first-child{margin-top:auto}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-no-transition{transition:none!important}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-popup{display:none;position:relative;box-sizing:border-box;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border:none;border-radius:.3125em;background:#fff;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-header{display:flex;flex-direction:column;align-items:center;padding:0 1.8em}.swal2-title{position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:100%;margin:1.25em auto 0;padding:0 1.6em}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 2em;box-shadow:none;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#2778c4;color:#fff;font-size:1.0625em}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#d14529;color:#fff;font-size:1.0625em}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#757575;color:#fff;font-size:1.0625em}.swal2-styled:focus{outline:0;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;height:.25em;overflow:hidden;border-bottom-right-radius:.3125em;border-bottom-left-radius:.3125em}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:1.25em auto}.swal2-close{position:absolute;z-index:2;top:0;right:0;align-items:center;justify-content:center;width:1.2em;height:1.2em;padding:0;overflow:hidden;transition:color .1s ease-out;border:none;border-radius:0;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close::-moz-focus-inner{border:0}.swal2-content{z-index:1;justify-content:center;margin:0;padding:0 1.6em;color:#545454;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em auto}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 3px #c4e6f5}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em auto;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-input[type=number]{max-width:10em}.swal2-file{background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto}.swal2-validation-message{display:none;align-items:center;justify-content:center;margin:0 -2.7em;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:0 0 1.25em;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-moz-document url-prefix(){.swal2-close:focus{outline:2px solid rgba(50,100,150,.4)}}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{top:auto;right:auto;bottom:auto;left:auto;max-width:calc(100% - .625em * 2);background-color:transparent!important}body.swal2-no-backdrop .swal2-container>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-container.swal2-top{top:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-top-left,body.swal2-no-backdrop .swal2-container.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-top-end,body.swal2-no-backdrop .swal2-container.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-container.swal2-center{top:50%;left:50%;transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-left,body.swal2-no-backdrop .swal2-container.swal2-center-start{top:50%;left:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-end,body.swal2-no-backdrop .swal2-container.swal2-center-right{top:50%;right:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom{bottom:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom-left,body.swal2-no-backdrop .swal2-container.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-bottom-end,body.swal2-no-backdrop .swal2-container.swal2-bottom-right{right:0;bottom:0}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}body.swal2-toast-column .swal2-toast{flex-direction:column;align-items:stretch}body.swal2-toast-column .swal2-toast .swal2-actions{flex:1;align-self:stretch;height:2.2em;margin-top:.3125em}body.swal2-toast-column .swal2-toast .swal2-loading{justify-content:center}body.swal2-toast-column .swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}body.swal2-toast-column .swal2-toast .swal2-validation-message{font-size:1em}");
    });

    // const _host = "http://192.168.1.104:93";
    // const _host = "http://172.20.1.12:303";
    const _host = "http://45.33.20.181:107";

    const axiosInstance = axios$1.create({
      baseURL: _host + "/api"
    });

    const axios$2 = writable(axiosInstance);
    const connection = writable(new HubConnectionBuilder()
      .withUrl(_host + "/hub", {
        accessTokenFactory: () => localStorage.getItem('access_token'),
      }).build());

    const session = writable(new Session(window.localStorage));

    const activePage = writable("home.index");
    const dataCita = writable({});
    const host = readable(_host + "/api");

    const errorConn = () => {
      sweetalert2_all.fire({
        title: 'Error',
        text: 'Ocurrio un problema al intentar conectar, intente de nuevo',
        icon: 'error'
      });
    };

    const notification = (time) => {
      return sweetalert2_all.mixin({
        toast: true,
        position: 'top-end',
        showConfirmButton: false,
        timer: time,
        timerProgressBar: true,
        onOpen: (toast) => {
          toast.addEventListener('mouseenter', sweetalert2_all.stopTimer);
          toast.addEventListener('mouseleave', sweetalert2_all.resumeTimer);
        }
      })
    };

    const errorConexion = readable(errorConn);
    const toast = readable(notification);

    /**
     * The code was extracted from:
     * https://github.com/davidchambers/Base64.js
     */

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function InvalidCharacterError(message) {
      this.message = message;
    }

    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';

    function polyfill (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
    }


    var atob$1 = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob$1(str).replace(/(.)/g, function (m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = '0' + code;
        }
        return '%' + code;
      }));
    }

    var base64_url_decode = function(str) {
      var output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }

      try{
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob$1(output);
      }
    };

    function InvalidTokenError(message) {
      this.message = message;
    }

    InvalidTokenError.prototype = new Error();
    InvalidTokenError.prototype.name = 'InvalidTokenError';

    var lib = function (token,options) {
      if (typeof token !== 'string') {
        throw new InvalidTokenError('Invalid token specified');
      }

      options = options || {};
      var pos = options.header === true ? 0 : 1;
      try {
        return JSON.parse(base64_url_decode(token.split('.')[pos]));
      } catch (e) {
        throw new InvalidTokenError('Invalid token specified: ' + e.message);
      }
    };

    var InvalidTokenError_1 = InvalidTokenError;
    lib.InvalidTokenError = InvalidTokenError_1;

    class UserManager {
        constructor(token) {
            this.asign(token);
        }

        asign(token) {
            if (token != null) {
                let obj = lib(token);
        
                this.name = obj.name;
                this.nameid = obj.nameid;
                this.userName = obj.unique_name;
                this.role = [];
                
                if (typeof obj.role == 'string') {
                    this.role.push(obj.role);
                } else if (typeof obj.role == 'object') {
                    this.role = obj.role;
                }
            } else {
                this.name = "";
                this.nameid = "";
                this.userName = "";
                this.role = [];
            }
        }

        is(roleName) {
            return this.role.some(x => x == roleName);
        }
        isAny(roles) {
            let result = false;
            for (const i of roles) {
                if (this.is(i)) {
                    result = true;
                    break;
                }
            }

            return result;
        }
    }

    /* src\Layout\Aside.svelte generated by Svelte v3.23.0 */
    const file = "src\\Layout\\Aside.svelte";

    function create_fragment$1(ctx) {
    	let aside;
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let span0;
    	let a0;
    	let link_action;
    	let t2;
    	let div0;
    	let a1;
    	let t3;
    	let a2;
    	let t4;
    	let div2;
    	let ul1;
    	let li0;
    	let a3;
    	let span2;
    	let span1;
    	let t6;
    	let span3;
    	let i0;
    	let link_action_1;
    	let active_action;
    	let t7;
    	let li1;
    	let a4;
    	let span5;
    	let span4;
    	let t9;
    	let span6;
    	let i1;
    	let link_action_2;
    	let active_action_1;
    	let t10;
    	let li2;
    	let a5;
    	let span8;
    	let span7;
    	let t12;
    	let span9;
    	let i2;
    	let link_action_3;
    	let active_action_2;
    	let t13;
    	let li3;
    	let a6;
    	let span11;
    	let span10;
    	let t15;
    	let span12;
    	let i3;
    	let link_action_4;
    	let active_action_3;
    	let t16;
    	let li4;
    	let a7;
    	let span14;
    	let span13;
    	let t18;
    	let span15;
    	let i4;
    	let link_action_5;
    	let active_action_4;
    	let t19;
    	let li6;
    	let a8;
    	let span19;
    	let span17;
    	let t20;
    	let span16;
    	let t21;
    	let span18;
    	let t23;
    	let span20;
    	let i5;
    	let t24;
    	let ul0;
    	let li5;
    	let a9;
    	let span22;
    	let span21;
    	let t26;
    	let span23;
    	let i6;
    	let link_action_6;
    	let active_action_5;
    	let active_action_6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			aside = element("aside");
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			span0 = element("span");
    			a0 = element("a");
    			a0.textContent = "Gestor de Citas";
    			t2 = space();
    			div0 = element("div");
    			a1 = element("a");
    			t3 = space();
    			a2 = element("a");
    			t4 = space();
    			div2 = element("div");
    			ul1 = element("ul");
    			li0 = element("li");
    			a3 = element("a");
    			span2 = element("span");
    			span1 = element("span");
    			span1.textContent = "Escritorio";
    			t6 = space();
    			span3 = element("span");
    			i0 = element("i");
    			t7 = space();
    			li1 = element("li");
    			a4 = element("a");
    			span5 = element("span");
    			span4 = element("span");
    			span4.textContent = "Asistente";
    			t9 = space();
    			span6 = element("span");
    			i1 = element("i");
    			t10 = space();
    			li2 = element("li");
    			a5 = element("a");
    			span8 = element("span");
    			span7 = element("span");
    			span7.textContent = "Citas programadas";
    			t12 = space();
    			span9 = element("span");
    			i2 = element("i");
    			t13 = space();
    			li3 = element("li");
    			a6 = element("a");
    			span11 = element("span");
    			span10 = element("span");
    			span10.textContent = "Gestor de Citas";
    			t15 = space();
    			span12 = element("span");
    			i3 = element("i");
    			t16 = space();
    			li4 = element("li");
    			a7 = element("a");
    			span14 = element("span");
    			span13 = element("span");
    			span13.textContent = "Espacio del medico";
    			t18 = space();
    			span15 = element("span");
    			i4 = element("i");
    			t19 = space();
    			li6 = element("li");
    			a8 = element("a");
    			span19 = element("span");
    			span17 = element("span");
    			t20 = text("Mantenimiento\r\n              ");
    			span16 = element("span");
    			t21 = space();
    			span18 = element("span");
    			span18.textContent = "Usuarios...";
    			t23 = space();
    			span20 = element("span");
    			i5 = element("i");
    			t24 = space();
    			ul0 = element("ul");
    			li5 = element("li");
    			a9 = element("a");
    			span22 = element("span");
    			span21 = element("span");
    			span21.textContent = "Usuarios";
    			t26 = space();
    			span23 = element("span");
    			i6 = element("i");
    			i6.textContent = "U";
    			attr_dev(img, "class", "admin-brand-logo");
    			if (img.src !== (img_src_value = "assets/img/logo.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "40");
    			attr_dev(img, "alt", "atmos Logo");
    			add_location(img, file, 12, 4, 401);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file, 18, 6, 563);
    			attr_dev(span0, "class", "admin-brand-content");
    			add_location(span0, file, 17, 4, 521);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "admin-pin-sidebar btn-ghost btn btn-rounded-circle");
    			add_location(a1, file, 23, 6, 712);
    			attr_dev(a2, "href", "#!");
    			attr_dev(a2, "class", "admin-close-sidebar");
    			add_location(a2, file, 27, 6, 870);
    			attr_dev(div0, "class", "ml-auto");
    			add_location(div0, file, 21, 4, 656);
    			attr_dev(div1, "class", "admin-sidebar-brand");
    			add_location(div1, file, 10, 2, 326);
    			attr_dev(span1, "class", "menu-name");
    			add_location(span1, file, 39, 12, 1247);
    			attr_dev(span2, "class", "menu-label");
    			add_location(span2, file, 38, 10, 1208);
    			attr_dev(i0, "class", "icon-placeholder mdi mdi-view-dashboard-outline");
    			add_location(i0, file, 42, 12, 1357);
    			attr_dev(span3, "class", "menu-icon");
    			add_location(span3, file, 41, 10, 1319);
    			attr_dev(a3, "href", "/");
    			attr_dev(a3, "class", "menu-link");
    			add_location(a3, file, 37, 8, 1157);
    			attr_dev(li0, "class", "menu-item");
    			add_location(li0, file, 36, 6, 1108);
    			attr_dev(span4, "class", "menu-name");
    			add_location(span4, file, 52, 12, 1761);
    			attr_dev(span5, "class", "menu-label");
    			add_location(span5, file, 51, 10, 1722);
    			attr_dev(i1, "class", "icon-placeholder mdi mdi-calendar-check");
    			add_location(i1, file, 55, 12, 1870);
    			attr_dev(span6, "class", "menu-icon");
    			add_location(span6, file, 54, 10, 1832);
    			attr_dev(a4, "href", "/Asistente/Index");
    			attr_dev(a4, "class", "menu-link");
    			add_location(a4, file, 50, 8, 1656);
    			attr_dev(li1, "class", "menu-item");
    			toggle_class(li1, "d-none", !/*user*/ ctx[0].isAny(["assistant", "admin"]));
    			add_location(li1, file, 48, 6, 1532);
    			attr_dev(span7, "class", "menu-name");
    			add_location(span7, file, 63, 12, 2240);
    			attr_dev(span8, "class", "menu-label");
    			add_location(span8, file, 62, 10, 2201);
    			attr_dev(i2, "class", "icon-placeholder mdi mdi-calendar-check");
    			add_location(i2, file, 66, 12, 2357);
    			attr_dev(span9, "class", "menu-icon");
    			add_location(span9, file, 65, 10, 2319);
    			attr_dev(a5, "href", "/Asistente/CitasProgramadas");
    			attr_dev(a5, "class", "menu-link");
    			add_location(a5, file, 61, 8, 2124);
    			attr_dev(li2, "class", "menu-item");
    			toggle_class(li2, "d-none", !/*user*/ ctx[0].isAny(["assistant", "operator", "admin"]));
    			add_location(li2, file, 59, 6, 1977);
    			attr_dev(span10, "class", "menu-name");
    			add_location(span10, file, 76, 12, 2763);
    			attr_dev(span11, "class", "menu-label");
    			add_location(span11, file, 75, 10, 2724);
    			attr_dev(i3, "class", "icon-placeholder mdi mdi-calendar-multiselect");
    			add_location(i3, file, 79, 12, 2878);
    			attr_dev(span12, "class", "menu-icon");
    			add_location(span12, file, 78, 10, 2840);
    			attr_dev(a6, "href", "/Cita/Gestionar");
    			attr_dev(a6, "class", "menu-link");
    			add_location(a6, file, 74, 8, 2659);
    			attr_dev(li3, "class", "menu-item");
    			toggle_class(li3, "d-none", !/*user*/ ctx[0].isAny(["assistant", "operator", "admin"]));
    			add_location(li3, file, 72, 6, 2524);
    			attr_dev(span13, "class", "menu-name");
    			add_location(span13, file, 90, 12, 3291);
    			attr_dev(span14, "class", "menu-label");
    			add_location(span14, file, 89, 10, 3252);
    			attr_dev(i4, "class", "icon-placeholder mdi mdi-doctor");
    			add_location(i4, file, 93, 12, 3409);
    			attr_dev(span15, "class", "menu-icon");
    			add_location(span15, file, 92, 10, 3371);
    			attr_dev(a7, "href", "/Medico/EspacioTrabajo");
    			attr_dev(a7, "class", "menu-link");
    			add_location(a7, file, 88, 8, 3180);
    			attr_dev(li4, "class", "menu-item");
    			toggle_class(li4, "d-none", !/*user*/ ctx[0].isAny(["doctor", "admin"]));
    			add_location(li4, file, 86, 6, 3053);
    			attr_dev(span16, "class", "menu-arrow");
    			add_location(span16, file, 107, 14, 3850);
    			attr_dev(span17, "class", "menu-name");
    			add_location(span17, file, 105, 12, 3781);
    			attr_dev(span18, "class", "menu-info");
    			add_location(span18, file, 109, 12, 3912);
    			attr_dev(span19, "class", "menu-label");
    			add_location(span19, file, 104, 10, 3742);
    			attr_dev(i5, "class", "icon-placeholder mdi mdi-settings-outline");
    			add_location(i5, file, 112, 12, 4023);
    			attr_dev(span20, "class", "menu-icon");
    			add_location(span20, file, 111, 10, 3985);
    			attr_dev(a8, "href", "#!");
    			attr_dev(a8, "class", "open-dropdown menu-link");
    			add_location(a8, file, 103, 8, 3685);
    			attr_dev(span21, "class", "menu-name");
    			add_location(span21, file, 120, 16, 4356);
    			attr_dev(span22, "class", "menu-label");
    			add_location(span22, file, 119, 14, 4313);
    			attr_dev(i6, "class", "icon-placeholder ");
    			add_location(i6, file, 123, 16, 4476);
    			attr_dev(span23, "class", "menu-icon");
    			add_location(span23, file, 122, 14, 4434);
    			attr_dev(a9, "href", "/Usuario/Index");
    			attr_dev(a9, "class", " menu-link");
    			add_location(a9, file, 118, 12, 4244);
    			attr_dev(li5, "class", "menu-item");
    			add_location(li5, file, 117, 10, 4178);
    			attr_dev(ul0, "class", "sub-menu");
    			add_location(ul0, file, 116, 8, 4145);
    			attr_dev(li6, "class", "menu-item ");
    			toggle_class(li6, "d-none", !/*user*/ ctx[0].isAny(["admin"]));
    			add_location(li6, file, 100, 6, 3570);
    			attr_dev(ul1, "class", "menu");
    			add_location(ul1, file, 34, 4, 1052);
    			attr_dev(div2, "class", "admin-sidebar-wrapper js-scrollbar");
    			add_location(div2, file, 32, 2, 968);
    			attr_dev(aside, "class", "admin-sidebar");
    			add_location(aside, file, 9, 0, 293);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, aside, anchor);
    			append_dev(aside, div1);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, span0);
    			append_dev(span0, a0);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, a1);
    			append_dev(div0, t3);
    			append_dev(div0, a2);
    			append_dev(aside, t4);
    			append_dev(aside, div2);
    			append_dev(div2, ul1);
    			append_dev(ul1, li0);
    			append_dev(li0, a3);
    			append_dev(a3, span2);
    			append_dev(span2, span1);
    			append_dev(a3, t6);
    			append_dev(a3, span3);
    			append_dev(span3, i0);
    			append_dev(ul1, t7);
    			append_dev(ul1, li1);
    			append_dev(li1, a4);
    			append_dev(a4, span5);
    			append_dev(span5, span4);
    			append_dev(a4, t9);
    			append_dev(a4, span6);
    			append_dev(span6, i1);
    			append_dev(ul1, t10);
    			append_dev(ul1, li2);
    			append_dev(li2, a5);
    			append_dev(a5, span8);
    			append_dev(span8, span7);
    			append_dev(a5, t12);
    			append_dev(a5, span9);
    			append_dev(span9, i2);
    			append_dev(ul1, t13);
    			append_dev(ul1, li3);
    			append_dev(li3, a6);
    			append_dev(a6, span11);
    			append_dev(span11, span10);
    			append_dev(a6, t15);
    			append_dev(a6, span12);
    			append_dev(span12, i3);
    			append_dev(ul1, t16);
    			append_dev(ul1, li4);
    			append_dev(li4, a7);
    			append_dev(a7, span14);
    			append_dev(span14, span13);
    			append_dev(a7, t18);
    			append_dev(a7, span15);
    			append_dev(span15, i4);
    			append_dev(ul1, t19);
    			append_dev(ul1, li6);
    			append_dev(li6, a8);
    			append_dev(a8, span19);
    			append_dev(span19, span17);
    			append_dev(span17, t20);
    			append_dev(span17, span16);
    			append_dev(span19, t21);
    			append_dev(span19, span18);
    			append_dev(a8, t23);
    			append_dev(a8, span20);
    			append_dev(span20, i5);
    			append_dev(li6, t24);
    			append_dev(li6, ul0);
    			append_dev(ul0, li5);
    			append_dev(li5, a9);
    			append_dev(a9, span22);
    			append_dev(span22, span21);
    			append_dev(a9, t26);
    			append_dev(a9, span23);
    			append_dev(span23, i6);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a0)),
    					action_destroyer(link_action_1 = link.call(null, a3)),
    					action_destroyer(active_action = active.call(null, li0, "/")),
    					action_destroyer(link_action_2 = link.call(null, a4)),
    					action_destroyer(active_action_1 = active.call(null, li1, "/Asistente/Index")),
    					action_destroyer(link_action_3 = link.call(null, a5)),
    					action_destroyer(active_action_2 = active.call(null, li2, "/Asistente/CitasProgramadas")),
    					action_destroyer(link_action_4 = link.call(null, a6)),
    					action_destroyer(active_action_3 = active.call(null, li3, "/Cita/Gestionar")),
    					action_destroyer(link_action_5 = link.call(null, a7)),
    					action_destroyer(active_action_4 = active.call(null, li4, "/Medico/EspacioTrabajo")),
    					action_destroyer(link_action_6 = link.call(null, a9)),
    					action_destroyer(active_action_5 = active.call(null, li5, "/Usuario/Index")),
    					action_destroyer(active_action_6 = active.call(null, li6, "/Usuario/*"))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*user*/ 1) {
    				toggle_class(li1, "d-none", !/*user*/ ctx[0].isAny(["assistant", "admin"]));
    			}

    			if (dirty & /*user*/ 1) {
    				toggle_class(li2, "d-none", !/*user*/ ctx[0].isAny(["assistant", "operator", "admin"]));
    			}

    			if (dirty & /*user*/ 1) {
    				toggle_class(li3, "d-none", !/*user*/ ctx[0].isAny(["assistant", "operator", "admin"]));
    			}

    			if (dirty & /*user*/ 1) {
    				toggle_class(li4, "d-none", !/*user*/ ctx[0].isAny(["doctor", "admin"]));
    			}

    			if (dirty & /*user*/ 1) {
    				toggle_class(li6, "d-none", !/*user*/ ctx[0].isAny(["admin"]));
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(aside);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $session;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(1, $session = $$value));
    	let user = new UserManager($session.authorizationHeader.Authorization);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Aside> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Aside", $$slots, []);

    	$$self.$capture_state = () => ({
    		link,
    		active,
    		activePage,
    		session,
    		UserManager,
    		user,
    		$session
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) $$invalidate(0, user = $$props.user);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [user];
    }

    class Aside extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Aside",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\Layout\Header.svelte generated by Svelte v3.23.0 */
    const file$1 = "src\\Layout\\Header.svelte";

    function create_fragment$2(ctx) {
    	let header;
    	let a0;
    	let t0;
    	let nav0;
    	let ul0;
    	let li0;
    	let a1;
    	let i0;
    	let t1;
    	let nav1;
    	let ul1;
    	let li1;
    	let div10;
    	let a2;
    	let i1;
    	let t2;
    	let span0;
    	let t3;
    	let div9;
    	let div0;
    	let a3;
    	let t4;
    	let span1;
    	let t6;
    	let a4;
    	let t7;
    	let div8;
    	let div1;
    	let t9;
    	let a5;
    	let div3;
    	let div2;
    	let i2;
    	let t10;
    	let t11;
    	let a6;
    	let div5;
    	let div4;
    	let i3;
    	let t12;
    	let t13;
    	let a7;
    	let div7;
    	let div6;
    	let i4;
    	let t14;
    	let t15;
    	let li2;
    	let a8;
    	let div11;
    	let span2;
    	let t16_value = /*user*/ ctx[0].userName[0] + "";
    	let t16;
    	let t17;
    	let div13;
    	let a9;
    	let t19;
    	let div12;
    	let t20;
    	let a10;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			header = element("header");
    			a0 = element("a");
    			t0 = space();
    			nav0 = element("nav");
    			ul0 = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			i0 = element("i");
    			t1 = space();
    			nav1 = element("nav");
    			ul1 = element("ul");
    			li1 = element("li");
    			div10 = element("div");
    			a2 = element("a");
    			i1 = element("i");
    			t2 = space();
    			span0 = element("span");
    			t3 = space();
    			div9 = element("div");
    			div0 = element("div");
    			a3 = element("a");
    			t4 = space();
    			span1 = element("span");
    			span1.textContent = "Notifications";
    			t6 = space();
    			a4 = element("a");
    			t7 = space();
    			div8 = element("div");
    			div1 = element("div");
    			div1.textContent = "today";
    			t9 = space();
    			a5 = element("a");
    			div3 = element("div");
    			div2 = element("div");
    			i2 = element("i");
    			t10 = text("\r\n                    All systems operational.");
    			t11 = space();
    			a6 = element("a");
    			div5 = element("div");
    			div4 = element("div");
    			i3 = element("i");
    			t12 = text("\r\n                    File upload successful.");
    			t13 = space();
    			a7 = element("a");
    			div7 = element("div");
    			div6 = element("div");
    			i4 = element("i");
    			t14 = text("\r\n                    Your holiday has been denied");
    			t15 = space();
    			li2 = element("li");
    			a8 = element("a");
    			div11 = element("div");
    			span2 = element("span");
    			t16 = text(t16_value);
    			t17 = space();
    			div13 = element("div");
    			a9 = element("a");
    			a9.textContent = "Resetear contraseña";
    			t19 = space();
    			div12 = element("div");
    			t20 = space();
    			a10 = element("a");
    			a10.textContent = "Cerrar sesion";
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "sidebar-toggle");
    			attr_dev(a0, "data-toggleclass", "sidebar-open");
    			attr_dev(a0, "data-target", "body");
    			add_location(a0, file$1, 23, 2, 526);
    			attr_dev(i0, "class", " mdi mdi-magnify mdi-24px align-middle");
    			add_location(i0, file$1, 40, 10, 913);
    			attr_dev(a1, "class", "nav-link ");
    			attr_dev(a1, "data-target", "#!siteSearchModal");
    			attr_dev(a1, "data-toggle", "modal");
    			attr_dev(a1, "href", "#!");
    			add_location(a1, file$1, 35, 8, 774);
    			attr_dev(li0, "class", "nav-item");
    			add_location(li0, file$1, 34, 6, 743);
    			attr_dev(ul0, "class", "nav align-items-center");
    			add_location(ul0, file$1, 32, 4, 698);
    			attr_dev(nav0, "class", " mr-auto my-auto");
    			add_location(nav0, file$1, 31, 2, 662);
    			attr_dev(i1, "class", "mdi mdi-24px mdi-bell-outline");
    			add_location(i1, file$1, 56, 12, 1330);
    			attr_dev(span0, "class", "notification-counter");
    			add_location(span0, file$1, 57, 12, 1387);
    			attr_dev(a2, "href", "#!");
    			attr_dev(a2, "class", "nav-link");
    			attr_dev(a2, "data-toggle", "dropdown");
    			attr_dev(a2, "aria-haspopup", "true");
    			attr_dev(a2, "aria-expanded", "false");
    			add_location(a2, file$1, 50, 10, 1155);
    			attr_dev(a3, "href", "#!");
    			attr_dev(a3, "class", "mdi mdi-18px mdi-settings text-muted");
    			add_location(a3, file$1, 64, 14, 1661);
    			attr_dev(span1, "class", "h5 m-0");
    			add_location(span1, file$1, 67, 14, 1781);
    			attr_dev(a4, "href", "#!");
    			attr_dev(a4, "class", "mdi mdi-18px mdi-notification-clear-all text-muted");
    			add_location(a4, file$1, 68, 14, 1838);
    			attr_dev(div0, "class", "d-flex p-all-15 bg-white justify-content-between\r\n              border-bottom ");
    			add_location(div0, file$1, 61, 12, 1538);
    			attr_dev(div1, "class", "text-overline m-b-5");
    			add_location(div1, file$1, 75, 14, 2088);
    			attr_dev(i2, "class", "mdi mdi-circle text-success");
    			add_location(i2, file$1, 79, 20, 2285);
    			attr_dev(div2, "class", "card-body");
    			add_location(div2, file$1, 78, 18, 2240);
    			attr_dev(div3, "class", "card");
    			add_location(div3, file$1, 77, 16, 2202);
    			attr_dev(a5, "href", "#!");
    			attr_dev(a5, "class", "d-block m-b-10");
    			add_location(a5, file$1, 76, 14, 2148);
    			attr_dev(i3, "class", "mdi mdi-upload-multiple ");
    			add_location(i3, file$1, 87, 20, 2595);
    			attr_dev(div4, "class", "card-body");
    			add_location(div4, file$1, 86, 18, 2550);
    			attr_dev(div5, "class", "card");
    			add_location(div5, file$1, 85, 16, 2512);
    			attr_dev(a6, "href", "#!");
    			attr_dev(a6, "class", "d-block m-b-10");
    			add_location(a6, file$1, 84, 14, 2458);
    			attr_dev(i4, "class", "mdi mdi-cancel text-danger");
    			add_location(i4, file$1, 95, 20, 2901);
    			attr_dev(div6, "class", "card-body");
    			add_location(div6, file$1, 94, 18, 2856);
    			attr_dev(div7, "class", "card");
    			add_location(div7, file$1, 93, 16, 2818);
    			attr_dev(a7, "href", "#!");
    			attr_dev(a7, "class", "d-block m-b-10");
    			add_location(a7, file$1, 92, 14, 2764);
    			attr_dev(div8, "class", "notification-events bg-gray-300");
    			add_location(div8, file$1, 74, 12, 2027);
    			attr_dev(div9, "class", "dropdown-menu notification-container dropdown-menu-right");
    			add_location(div9, file$1, 60, 10, 1454);
    			attr_dev(div10, "class", "dropdown");
    			add_location(div10, file$1, 49, 8, 1121);
    			attr_dev(li1, "class", "nav-item");
    			add_location(li1, file$1, 48, 6, 1090);
    			attr_dev(span2, "class", "avatar-title rounded-circle bg-dark");
    			add_location(span2, file$1, 115, 12, 3443);
    			attr_dev(div11, "class", "avatar avatar-sm avatar-online");
    			add_location(div11, file$1, 114, 10, 3385);
    			attr_dev(a8, "class", "nav-link dropdown-toggle");
    			attr_dev(a8, "href", "#!");
    			attr_dev(a8, "role", "button");
    			attr_dev(a8, "data-toggle", "dropdown");
    			attr_dev(a8, "aria-haspopup", "true");
    			attr_dev(a8, "aria-expanded", "false");
    			add_location(a8, file$1, 107, 8, 3181);
    			attr_dev(a9, "class", "dropdown-item");
    			attr_dev(a9, "href", "#!");
    			add_location(a9, file$1, 120, 10, 3621);
    			attr_dev(div12, "class", "dropdown-divider");
    			add_location(div12, file$1, 121, 10, 3691);
    			attr_dev(a10, "class", "dropdown-item");
    			attr_dev(a10, "href", "#!");
    			add_location(a10, file$1, 122, 10, 3735);
    			attr_dev(div13, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div13, file$1, 119, 8, 3562);
    			attr_dev(li2, "class", "nav-item dropdown ");
    			add_location(li2, file$1, 106, 6, 3140);
    			attr_dev(ul1, "class", "nav align-items-center");
    			add_location(ul1, file$1, 46, 4, 1045);
    			attr_dev(nav1, "class", " ml-auto");
    			add_location(nav1, file$1, 45, 2, 1017);
    			attr_dev(header, "class", "admin-header");
    			add_location(header, file$1, 22, 0, 493);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, a0);
    			append_dev(header, t0);
    			append_dev(header, nav0);
    			append_dev(nav0, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a1);
    			append_dev(a1, i0);
    			append_dev(header, t1);
    			append_dev(header, nav1);
    			append_dev(nav1, ul1);
    			append_dev(ul1, li1);
    			append_dev(li1, div10);
    			append_dev(div10, a2);
    			append_dev(a2, i1);
    			append_dev(a2, t2);
    			append_dev(a2, span0);
    			append_dev(div10, t3);
    			append_dev(div10, div9);
    			append_dev(div9, div0);
    			append_dev(div0, a3);
    			append_dev(div0, t4);
    			append_dev(div0, span1);
    			append_dev(div0, t6);
    			append_dev(div0, a4);
    			append_dev(div9, t7);
    			append_dev(div9, div8);
    			append_dev(div8, div1);
    			append_dev(div8, t9);
    			append_dev(div8, a5);
    			append_dev(a5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, i2);
    			append_dev(div2, t10);
    			append_dev(div8, t11);
    			append_dev(div8, a6);
    			append_dev(a6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, i3);
    			append_dev(div4, t12);
    			append_dev(div8, t13);
    			append_dev(div8, a7);
    			append_dev(a7, div7);
    			append_dev(div7, div6);
    			append_dev(div6, i4);
    			append_dev(div6, t14);
    			append_dev(ul1, t15);
    			append_dev(ul1, li2);
    			append_dev(li2, a8);
    			append_dev(a8, div11);
    			append_dev(div11, span2);
    			append_dev(span2, t16);
    			append_dev(li2, t17);
    			append_dev(li2, div13);
    			append_dev(div13, a9);
    			append_dev(div13, t19);
    			append_dev(div13, div12);
    			append_dev(div13, t20);
    			append_dev(div13, a10);

    			if (!mounted) {
    				dispose = listen_dev(a10, "click", prevent_default(/*logOut*/ ctx[1]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*user*/ 1 && t16_value !== (t16_value = /*user*/ ctx[0].userName[0] + "")) set_data_dev(t16, t16_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $session;
    	let $connection;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(2, $session = $$value));
    	validate_store(connection, "connection");
    	component_subscribe($$self, connection, $$value => $$invalidate(3, $connection = $$value));
    	let user = {};
    	user = new UserManager($session.authorizationHeader.Authorization);
    	let name = "";
    	jQuery(".modal-backdrop").hide();

    	const logOut = function () {
    		$session.clear();
    		$session.invalidate();
    		$connection.stop();
    		push("/Home/Login");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Header", $$slots, []);

    	$$self.$capture_state = () => ({
    		session,
    		connection,
    		push,
    		jwt: lib,
    		UserManager,
    		user,
    		name,
    		logOut,
    		$session,
    		$connection
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) $$invalidate(0, user = $$props.user);
    		if ("name" in $$props) name = $$props.name;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [user, logOut];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\Pages\Home\Index.svelte generated by Svelte v3.23.0 */
    const file$2 = "src\\Pages\\Home\\Index.svelte";

    function create_fragment$3(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let h1;
    	let t3;
    	let p;
    	let current;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Bienvenido";
    			t3 = space();
    			p = element("p");
    			p.textContent = "Al sistema de gestion de citas";
    			attr_dev(h1, "class", "display-4");
    			add_location(h1, file$2, 22, 12, 629);
    			add_location(p, file$2, 23, 12, 680);
    			attr_dev(div0, "class", "col-4 container");
    			add_location(div0, file$2, 21, 10, 586);
    			attr_dev(div1, "class", "row justify-content-center");
    			add_location(div1, file$2, 20, 8, 534);
    			attr_dev(div2, "class", "jumbotron jumbotron-fluid");
    			add_location(div2, file$2, 18, 6, 477);
    			attr_dev(div3, "class", "container mt-3");
    			add_location(div3, file$2, 17, 4, 441);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$2, 16, 2, 404);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$2, 14, 0, 361);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(div0, t3);
    			append_dev(div0, p);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $activePage;
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(0, $activePage = $$value));
    	set_store_value(activePage, $activePage = "home.index");

    	onDestroy(() => {
    		set_store_value(activePage, $activePage = "");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Index", $$slots, []);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		activePage,
    		session,
    		onDestroy,
    		push,
    		$activePage
    	});

    	return [];
    }

    class Index extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\Pages\Home\Login.svelte generated by Svelte v3.23.0 */

    const { console: console_1$1 } = globals;
    const file$3 = "src\\Pages\\Home\\Login.svelte";

    // (86:14) {#if loginFail}
    function create_if_block_1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Usuario y contraseña no coinciden";
    			attr_dev(div, "class", "alert alert-danger mt-2");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$3, 86, 16, 2712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(86:14) {#if loginFail}",
    		ctx
    	});

    	return block;
    }

    // (91:14) {#if cargando}
    function create_if_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Cargando...";
    			attr_dev(div, "class", "alert alert-primary mt-2");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$3, 91, 16, 2908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(91:14) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let main;
    	let div9;
    	let div8;
    	let div6;
    	let div5;
    	let div4;
    	let div0;
    	let t0;
    	let h3;
    	let t2;
    	let form;
    	let div3;
    	let div1;
    	let label0;
    	let t4;
    	let input0;
    	let t5;
    	let div2;
    	let label1;
    	let t7;
    	let input1;
    	let t8;
    	let button;
    	let t10;
    	let t11;
    	let t12;
    	let div7;
    	let mounted;
    	let dispose;
    	let if_block0 = /*loginFail*/ ctx[0] && create_if_block_1(ctx);
    	let if_block1 = /*cargando*/ ctx[3] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div9 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			h3 = element("h3");
    			h3.textContent = "Entrar";
    			t2 = space();
    			form = element("form");
    			div3 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Correo electronico";
    			t4 = space();
    			input0 = element("input");
    			t5 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Contraseña";
    			t7 = space();
    			input1 = element("input");
    			t8 = space();
    			button = element("button");
    			button.textContent = "Iniciar sesión";
    			t10 = space();
    			if (if_block0) if_block0.c();
    			t11 = space();
    			if (if_block1) if_block1.c();
    			t12 = space();
    			div7 = element("div");
    			attr_dev(div0, "class", "p-b-20 text-center");
    			add_location(div0, file$3, 55, 12, 1490);
    			attr_dev(h3, "class", "text-center p-b-20 fw-400");
    			add_location(h3, file$3, 56, 12, 1538);
    			add_location(label0, file$3, 63, 18, 1847);
    			attr_dev(input0, "type", "username");
    			input0.required = true;
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Correo electronico");
    			add_location(input0, file$3, 64, 18, 1900);
    			attr_dev(div1, "class", "form-group floating-label col-md-12");
    			add_location(div1, file$3, 62, 16, 1778);
    			add_location(label1, file$3, 72, 18, 2226);
    			attr_dev(input1, "type", "password");
    			input1.required = true;
    			attr_dev(input1, "placeholder", "Contraseña");
    			attr_dev(input1, "class", "form-control ");
    			add_location(input1, file$3, 73, 18, 2271);
    			attr_dev(div2, "class", "form-group floating-label col-md-12");
    			add_location(div2, file$3, 71, 16, 2157);
    			attr_dev(div3, "class", "form-row");
    			add_location(div3, file$3, 61, 14, 1738);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary btn-block btn-lg");
    			add_location(button, file$3, 82, 14, 2543);
    			attr_dev(form, "class", "needs-validation");
    			attr_dev(form, "action", "");
    			add_location(form, file$3, 57, 12, 1601);
    			attr_dev(div4, "class", "mx-auto col-md-8");
    			add_location(div4, file$3, 54, 10, 1446);
    			attr_dev(div5, "class", "row align-items-center m-h-100");
    			add_location(div5, file$3, 53, 8, 1390);
    			attr_dev(div6, "class", "col-lg-4 bg-white");
    			add_location(div6, file$3, 52, 6, 1349);
    			attr_dev(div7, "class", "col-lg-8 d-none d-md-block bg-cover");
    			set_style(div7, "background-image", "url('assets/img/login.svg')");
    			add_location(div7, file$3, 101, 6, 3116);
    			attr_dev(div8, "class", "row ");
    			add_location(div8, file$3, 51, 4, 1323);
    			attr_dev(div9, "class", "container-fluid");
    			add_location(div9, file$3, 50, 2, 1288);
    			add_location(main, file$3, 49, 0, 1278);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, h3);
    			append_dev(div4, t2);
    			append_dev(div4, form);
    			append_dev(form, div3);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t4);
    			append_dev(div1, input0);
    			set_input_value(input0, /*username*/ ctx[1]);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t7);
    			append_dev(div2, input1);
    			set_input_value(input1, /*password*/ ctx[2]);
    			append_dev(form, t8);
    			append_dev(form, button);
    			append_dev(form, t10);
    			if (if_block0) if_block0.m(form, null);
    			append_dev(form, t11);
    			if (if_block1) if_block1.m(form, null);
    			append_dev(div8, t12);
    			append_dev(div8, div7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[8]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[9]),
    					listen_dev(form, "submit", prevent_default(/*iniciar*/ ctx[4]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*username*/ 2) {
    				set_input_value(input0, /*username*/ ctx[1]);
    			}

    			if (dirty & /*password*/ 4 && input1.value !== /*password*/ ctx[2]) {
    				set_input_value(input1, /*password*/ ctx[2]);
    			}

    			if (/*loginFail*/ ctx[0]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(form, t11);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cargando*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(form, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $host;
    	let $session;
    	let $connection;
    	validate_store(host, "host");
    	component_subscribe($$self, host, $$value => $$invalidate(5, $host = $$value));
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(6, $session = $$value));
    	validate_store(connection, "connection");
    	component_subscribe($$self, connection, $$value => $$invalidate(7, $connection = $$value));
    	let loginFail = false;
    	let username = "";
    	let password = "";
    	let cargando = false;
    	jQuery(".modal-backdrop").hide();

    	const iniciar = function () {
    		$$invalidate(3, cargando = true);
    		$$invalidate(0, loginFail = false);
    		let _session = new Session(localStorage);

    		login(_session, $host + "/Users/LogIn", username, password).then(x => {
    			if (x) {
    				$$invalidate(0, loginFail = true);
    				$$invalidate(3, cargando = false);
    			} else {
    				set_store_value(session, $session = _session);
    				$$invalidate(3, cargando = false);

    				if ($session.isValid) {
    					if ($connection.state === HubConnectionState.Disconnected) {
    						$connection.start().catch(e => console.error(e));
    					}

    					push("/");
    				}
    			}
    		}).catch(e => {
    			$$invalidate(3, cargando = false);

    			sweetalert2_all.fire({
    				title: "Error de conexion",
    				text: "Hubo un problema al conectar al servidor!",
    				icon: "error"
    			});
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Login", $$slots, []);

    	function input0_input_handler() {
    		username = this.value;
    		$$invalidate(1, username);
    	}

    	function input1_input_handler() {
    		password = this.value;
    		$$invalidate(2, password);
    	}

    	$$self.$capture_state = () => ({
    		host,
    		session,
    		connection,
    		axios: axios$2,
    		push,
    		Session,
    		login,
    		HubConnectionState,
    		Swal: sweetalert2_all,
    		loginFail,
    		username,
    		password,
    		cargando,
    		iniciar,
    		$host,
    		$session,
    		$connection
    	});

    	$$self.$inject_state = $$props => {
    		if ("loginFail" in $$props) $$invalidate(0, loginFail = $$props.loginFail);
    		if ("username" in $$props) $$invalidate(1, username = $$props.username);
    		if ("password" in $$props) $$invalidate(2, password = $$props.password);
    		if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		loginFail,
    		username,
    		password,
    		cargando,
    		iniciar,
    		$host,
    		$session,
    		$connection,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\Pages\Asistente\Index.svelte generated by Svelte v3.23.0 */

    const { console: console_1$2 } = globals;
    const file$4 = "src\\Pages\\Asistente\\Index.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[60] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[60] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[65] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[65] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[60] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[60] = list[i];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[60] = list[i];
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[65] = list[i];
    	return child_ctx;
    }

    // (420:14) {#each medicos as item}
    function create_each_block_7(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[65].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[65].medicoID + "=" + /*item*/ ctx[65].userName;
    			option.value = option.__value;
    			add_location(option, file$4, 420, 16, 11063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*medicos*/ 2 && t_value !== (t_value = /*item*/ ctx[65].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*medicos*/ 2 && option_value_value !== (option_value_value = /*item*/ ctx[65].medicoID + "=" + /*item*/ ctx[65].userName)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(420:14) {#each medicos as item}",
    		ctx
    	});

    	return block;
    }

    // (438:12) {#if citasEnTurno.length > 0}
    function create_if_block_5(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t6;
    	let tbody;
    	let each_value_6 = /*citasEnTurno*/ ctx[3];
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Nombre";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Celular";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Observacion";
    			t5 = space();
    			th3 = element("th");
    			t6 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$4, 441, 20, 11842);
    			add_location(th1, file$4, 442, 20, 11879);
    			add_location(th2, file$4, 443, 20, 11917);
    			add_location(th3, file$4, 444, 20, 11959);
    			add_location(tr, file$4, 440, 18, 11816);
    			add_location(thead, file$4, 439, 16, 11789);
    			attr_dev(tbody, "class", "svelte-1gvzc7h");
    			add_location(tbody, file$4, 447, 16, 12034);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$4, 438, 14, 11723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t6);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pacienteEnviado, citasEnTurno, cargarDatosPaciente*/ 16456) {
    				each_value_6 = /*citasEnTurno*/ ctx[3];
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_6.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(438:12) {#if citasEnTurno.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (449:18) {#each citasEnTurno as i}
    function create_each_block_6(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*i*/ ctx[60].nombrePaciente + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2;
    	let td2;
    	let t3_value = /*i*/ ctx[60].observaciones + "";
    	let t3;
    	let t4;
    	let td3;
    	let button;
    	let i;
    	let t5;
    	let t6;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[38](/*i*/ ctx[60], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			button = element("button");
    			i = element("i");
    			t5 = text("\r\n                          Ver paciente");
    			t6 = space();
    			add_location(td0, file$4, 450, 22, 12189);
    			add_location(td1, file$4, 453, 22, 12289);
    			add_location(td2, file$4, 454, 22, 12319);
    			attr_dev(i, "class", "mdi mdi-account-search-outline");
    			add_location(i, file$4, 461, 26, 12695);
    			attr_dev(button, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button, "data-toggle", "modal");
    			attr_dev(button, "data-target", "#modalPaciente");
    			add_location(button, file$4, 456, 24, 12426);
    			set_style(td3, "text-align", "right");
    			add_location(td3, file$4, 455, 22, 12369);
    			attr_dev(tr, "class", "svelte-1gvzc7h");
    			toggle_class(tr, "active-turno", /*pacienteEnviado*/ ctx[6] == /*i*/ ctx[60].pacienteID);
    			add_location(tr, file$4, 449, 20, 12108);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, button);
    			append_dev(button, i);
    			append_dev(button, t5);
    			append_dev(tr, t6);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*citasEnTurno*/ 8 && t0_value !== (t0_value = /*i*/ ctx[60].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citasEnTurno*/ 8 && t3_value !== (t3_value = /*i*/ ctx[60].observaciones + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*pacienteEnviado, citasEnTurno*/ 72) {
    				toggle_class(tr, "active-turno", /*pacienteEnviado*/ ctx[6] == /*i*/ ctx[60].pacienteID);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(449:18) {#each citasEnTurno as i}",
    		ctx
    	});

    	return block;
    }

    // (478:12) {#if citasPendientes.length > 0}
    function create_if_block_4(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t6;
    	let tbody;
    	let each_value_5 = /*citasPendientes*/ ctx[2];
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Nombre";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Celular";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Observacion";
    			t5 = space();
    			th3 = element("th");
    			t6 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$4, 481, 20, 13418);
    			add_location(th1, file$4, 482, 20, 13455);
    			add_location(th2, file$4, 483, 20, 13493);
    			add_location(th3, file$4, 484, 20, 13535);
    			add_location(tr, file$4, 480, 18, 13392);
    			add_location(thead, file$4, 479, 16, 13365);
    			add_location(tbody, file$4, 487, 16, 13610);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$4, 478, 14, 13299);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t6);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*cambiarEstadoCita, citasPendientes, reprogramarCita, cargarDatosPaciente*/ 311300) {
    				each_value_5 = /*citasPendientes*/ ctx[2];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(478:12) {#if citasPendientes.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (489:18) {#each citasPendientes as i}
    function create_each_block_5(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*i*/ ctx[60].nombrePaciente + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2;
    	let td2;
    	let t3_value = /*i*/ ctx[60].observaciones + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5;
    	let td4;
    	let button0;
    	let i0;
    	let t6;
    	let t7;
    	let button1;
    	let i1;
    	let t8;
    	let t9;
    	let button2;
    	let i2;
    	let t10;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[39](/*i*/ ctx[60], ...args);
    	}

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[40](/*i*/ ctx[60], ...args);
    	}

    	function click_handler_3(...args) {
    		return /*click_handler_3*/ ctx[41](/*i*/ ctx[60], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = space();
    			td4 = element("td");
    			button0 = element("button");
    			i0 = element("i");
    			t6 = text("\r\n                          Ver paciente");
    			t7 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t8 = text("\r\n                          Reprogramar");
    			t9 = space();
    			button2 = element("button");
    			i2 = element("i");
    			t10 = space();
    			attr_dev(td0, "class", "svelte-1gvzc7h");
    			add_location(td0, file$4, 490, 22, 13736);
    			attr_dev(td1, "class", "svelte-1gvzc7h");
    			add_location(td1, file$4, 491, 22, 13787);
    			attr_dev(td2, "class", "svelte-1gvzc7h");
    			add_location(td2, file$4, 492, 22, 13817);
    			attr_dev(td3, "class", "svelte-1gvzc7h");
    			add_location(td3, file$4, 493, 22, 13867);
    			attr_dev(i0, "class", "mdi mdi-account-search-outline");
    			add_location(i0, file$4, 500, 26, 14223);
    			attr_dev(button0, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button0, "data-toggle", "modal");
    			attr_dev(button0, "data-target", "#modalPaciente");
    			add_location(button0, file$4, 495, 24, 13954);
    			attr_dev(i1, "class", "mdi mdi-calendar-remove");
    			add_location(i1, file$4, 508, 26, 14634);
    			attr_dev(button1, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button1, "data-toggle", "modal");
    			attr_dev(button1, "data-target", "#modalCrearCita");
    			add_location(button1, file$4, 503, 24, 14368);
    			attr_dev(i2, "class", "mdi mdi-ticket-confirmation");
    			add_location(i2, file$4, 515, 26, 14984);
    			attr_dev(button2, "class", "btn btn-primary btn-sm mb-1");
    			attr_dev(button2, "title", "Poner en cola");
    			add_location(button2, file$4, 511, 24, 14771);
    			set_style(td4, "text-align", "right");
    			attr_dev(td4, "class", "svelte-1gvzc7h");
    			add_location(td4, file$4, 494, 22, 13897);
    			attr_dev(tr, "class", "cursor-table svelte-1gvzc7h");
    			add_location(tr, file$4, 489, 20, 13687);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(tr, t5);
    			append_dev(tr, td4);
    			append_dev(td4, button0);
    			append_dev(button0, i0);
    			append_dev(button0, t6);
    			append_dev(td4, t7);
    			append_dev(td4, button1);
    			append_dev(button1, i1);
    			append_dev(button1, t8);
    			append_dev(td4, t9);
    			append_dev(td4, button2);
    			append_dev(button2, i2);
    			append_dev(tr, t10);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", click_handler_1, false, false, false),
    					listen_dev(button1, "click", click_handler_2, false, false, false),
    					listen_dev(button2, "click", click_handler_3, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*citasPendientes*/ 4 && t0_value !== (t0_value = /*i*/ ctx[60].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citasPendientes*/ 4 && t3_value !== (t3_value = /*i*/ ctx[60].observaciones + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(489:18) {#each citasPendientes as i}",
    		ctx
    	});

    	return block;
    }

    // (531:12) {#if citasRealizadas.length > 0}
    function create_if_block_3(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t6;
    	let tbody;
    	let each_value_4 = /*citasRealizadas*/ ctx[4];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Nombre";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Celular";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Observacion";
    			t5 = space();
    			th3 = element("th");
    			t6 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$4, 534, 20, 15666);
    			add_location(th1, file$4, 535, 20, 15703);
    			add_location(th2, file$4, 536, 20, 15741);
    			add_location(th3, file$4, 537, 20, 15783);
    			add_location(tr, file$4, 533, 18, 15640);
    			add_location(thead, file$4, 532, 16, 15613);
    			add_location(tbody, file$4, 540, 16, 15858);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$4, 531, 14, 15547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t6);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*reprogramarCita, citasRealizadas, cargarDatosPaciente*/ 49168) {
    				each_value_4 = /*citasRealizadas*/ ctx[4];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(531:12) {#if citasRealizadas.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (542:18) {#each citasRealizadas as i}
    function create_each_block_4(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*i*/ ctx[60].nombrePaciente + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2;
    	let td2;
    	let t3_value = /*i*/ ctx[60].observaciones + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5;
    	let td4;
    	let button0;
    	let i0;
    	let t6;
    	let t7;
    	let button1;
    	let i1;
    	let t8;
    	let t9;
    	let mounted;
    	let dispose;

    	function click_handler_4(...args) {
    		return /*click_handler_4*/ ctx[42](/*i*/ ctx[60], ...args);
    	}

    	function click_handler_5(...args) {
    		return /*click_handler_5*/ ctx[43](/*i*/ ctx[60], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = space();
    			td4 = element("td");
    			button0 = element("button");
    			i0 = element("i");
    			t6 = text("\r\n                          Ver paciente");
    			t7 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t8 = text("\r\n                          Crear cita");
    			t9 = space();
    			attr_dev(td0, "class", "svelte-1gvzc7h");
    			add_location(td0, file$4, 543, 22, 15984);
    			attr_dev(td1, "class", "svelte-1gvzc7h");
    			add_location(td1, file$4, 544, 22, 16035);
    			attr_dev(td2, "class", "svelte-1gvzc7h");
    			add_location(td2, file$4, 545, 22, 16065);
    			attr_dev(td3, "class", "svelte-1gvzc7h");
    			add_location(td3, file$4, 546, 22, 16115);
    			attr_dev(i0, "class", "mdi mdi-account-search-outline");
    			add_location(i0, file$4, 553, 26, 16471);
    			attr_dev(button0, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button0, "data-toggle", "modal");
    			attr_dev(button0, "data-target", "#modalPaciente");
    			add_location(button0, file$4, 548, 24, 16202);
    			attr_dev(i1, "class", "mdi mdi-calendar-remove");
    			add_location(i1, file$4, 561, 26, 16882);
    			attr_dev(button1, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button1, "data-toggle", "modal");
    			attr_dev(button1, "data-target", "#modalNuevaCita");
    			add_location(button1, file$4, 556, 24, 16616);
    			set_style(td4, "text-align", "right");
    			attr_dev(td4, "class", "svelte-1gvzc7h");
    			add_location(td4, file$4, 547, 22, 16145);
    			attr_dev(tr, "class", "cursor-table svelte-1gvzc7h");
    			add_location(tr, file$4, 542, 20, 15935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(tr, t5);
    			append_dev(tr, td4);
    			append_dev(td4, button0);
    			append_dev(button0, i0);
    			append_dev(button0, t6);
    			append_dev(td4, t7);
    			append_dev(td4, button1);
    			append_dev(button1, i1);
    			append_dev(button1, t8);
    			append_dev(tr, t9);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", click_handler_4, false, false, false),
    					listen_dev(button1, "click", click_handler_5, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*citasRealizadas*/ 16 && t0_value !== (t0_value = /*i*/ ctx[60].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citasRealizadas*/ 16 && t3_value !== (t3_value = /*i*/ ctx[60].observaciones + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(542:18) {#each citasRealizadas as i}",
    		ctx
    	});

    	return block;
    }

    // (671:16) {#each aseguradoras as item}
    function create_each_block_3(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[65].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[65].id;
    			option.value = option.__value;
    			add_location(option, file$4, 671, 18, 20400);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(671:16) {#each aseguradoras as item}",
    		ctx
    	});

    	return block;
    }

    // (706:16) {#each provincias as item}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[65].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[65].id;
    			option.value = option.__value;
    			add_location(option, file$4, 706, 18, 21841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(706:16) {#each provincias as item}",
    		ctx
    	});

    	return block;
    }

    // (743:12) {#if cita.estadoID == 2}
    function create_if_block_2(ctx) {
    	let button;
    	let t;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text("Enviar paciente\r\n              ");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-send");
    			add_location(i, file$4, 749, 14, 23263);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-success");
    			attr_dev(button, "title", "Guardar y enviar");
    			add_location(button, file$4, 743, 12, 23059);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*enviarPaciente*/ ctx[21], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(743:12) {#if cita.estadoID == 2}",
    		ctx
    	});

    	return block;
    }

    // (812:10) {#if horasDisponibles.length <= 0}
    function create_if_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad en este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$4, 812, 12, 25253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(812:10) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (817:10) {#each horasDisponibles as i}
    function create_each_block_1(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*i*/ ctx[60].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Seleccionar";
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$4, 820, 16, 25577);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$4, 819, 14, 25545);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$4, 823, 16, 25686);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$4, 822, 14, 25647);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$4, 817, 12, 25444);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*cambiarFechaCita*/ ctx[17](/*i*/ ctx[60].time))) /*cambiarFechaCita*/ ctx[17](/*i*/ ctx[60].time).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 32 && t0_value !== (t0_value = /*i*/ ctx[60].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(817:10) {#each horasDisponibles as i}",
    		ctx
    	});

    	return block;
    }

    // (896:10) {#if horasDisponibles.length <= 0}
    function create_if_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad en este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$4, 896, 12, 28029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(896:10) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (901:10) {#each horasDisponibles as i}
    function create_each_block(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*i*/ ctx[60].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler_6(...args) {
    		return /*click_handler_6*/ ctx[59](/*i*/ ctx[60], ...args);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Seleccionar";
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$4, 904, 16, 28353);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$4, 903, 14, 28321);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$4, 907, 16, 28462);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$4, 906, 14, 28423);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$4, 901, 12, 28220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_6, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 32 && t0_value !== (t0_value = /*i*/ ctx[60].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(901:10) {#each horasDisponibles as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div14;
    	let div6;
    	let div5;
    	let div3;
    	let div2;
    	let input0;
    	let t2;
    	let div1;
    	let div0;
    	let span0;
    	let t3;
    	let div4;
    	let select0;
    	let option0;
    	let option0_value_value;
    	let t5;
    	let a;
    	let i0;
    	let t6;
    	let t7;
    	let div13;
    	let div8;
    	let h40;
    	let t9;
    	let div7;
    	let h41;
    	let t11;
    	let t12;
    	let div10;
    	let h42;
    	let t14;
    	let h43;
    	let t16;
    	let div9;
    	let t17;
    	let div12;
    	let h44;
    	let t19;
    	let h45;
    	let t21;
    	let div11;
    	let t22;
    	let div42;
    	let div41;
    	let div40;
    	let div15;
    	let h50;
    	let i1;
    	let t23;
    	let t24;
    	let button0;
    	let span1;
    	let t26;
    	let div39;
    	let form;
    	let input1;
    	let t27;
    	let div17;
    	let div16;
    	let label0;
    	let t29;
    	let input2;
    	let t30;
    	let div19;
    	let div18;
    	let label1;
    	let t32;
    	let input3;
    	let t33;
    	let div21;
    	let div20;
    	let label2;
    	let t35;
    	let input4;
    	let t36;
    	let div23;
    	let div22;
    	let label3;
    	let t38;
    	let input5;
    	let t39;
    	let div25;
    	let div24;
    	let label4;
    	let t41;
    	let input6;
    	let t42;
    	let div27;
    	let div26;
    	let label5;
    	let t44;
    	let select1;
    	let option1;
    	let t46;
    	let div29;
    	let div28;
    	let label6;
    	let t48;
    	let input7;
    	let t49;
    	let div31;
    	let div30;
    	let label7;
    	let t51;
    	let select2;
    	let option2;
    	let option3;
    	let option3_value_value;
    	let option4;
    	let option4_value_value;
    	let option5;
    	let option5_value_value;
    	let t56;
    	let div33;
    	let div32;
    	let label8;
    	let t58;
    	let select3;
    	let option6;
    	let t60;
    	let div35;
    	let div34;
    	let label9;
    	let t62;
    	let textarea0;
    	let t63;
    	let div37;
    	let div36;
    	let label10;
    	let t65;
    	let textarea1;
    	let t66;
    	let br;
    	let t67;
    	let div38;
    	let button1;
    	let t69;
    	let button2;
    	let t70;
    	let i2;
    	let t71;
    	let t72;
    	let div54;
    	let div53;
    	let div52;
    	let div43;
    	let h51;
    	let i3;
    	let t73;
    	let t74;
    	let button3;
    	let span2;
    	let t76;
    	let div50;
    	let div48;
    	let div45;
    	let div44;
    	let label11;
    	let t78;
    	let input8;
    	let t79;
    	let div47;
    	let div46;
    	let label12;
    	let t81;
    	let select4;
    	let option7;
    	let option7_value_value;
    	let option8;
    	let option8_value_value;
    	let option9;
    	let option9_value_value;
    	let t85;
    	let div49;
    	let t86;
    	let t87;
    	let div51;
    	let button4;
    	let t89;
    	let div66;
    	let div65;
    	let div64;
    	let div55;
    	let h52;
    	let i4;
    	let t90;
    	let t91;
    	let button5;
    	let span3;
    	let t93;
    	let div62;
    	let div60;
    	let div57;
    	let div56;
    	let label13;
    	let t95;
    	let input9;
    	let t96;
    	let div59;
    	let div58;
    	let label14;
    	let t98;
    	let select5;
    	let option10;
    	let option10_value_value;
    	let option11;
    	let option11_value_value;
    	let option12;
    	let option12_value_value;
    	let t102;
    	let div61;
    	let t103;
    	let t104;
    	let div63;
    	let button6;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_7 = /*medicos*/ ctx[1];
    	validate_each_argument(each_value_7);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks_4[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	let if_block0 = /*citasEnTurno*/ ctx[3].length > 0 && create_if_block_5(ctx);
    	let if_block1 = /*citasPendientes*/ ctx[2].length > 0 && create_if_block_4(ctx);
    	let if_block2 = /*citasRealizadas*/ ctx[4].length > 0 && create_if_block_3(ctx);
    	let each_value_3 = /*aseguradoras*/ ctx[12];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*provincias*/ ctx[11];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let if_block3 = /*cita*/ ctx[10].estadoID == 2 && create_if_block_2(ctx);
    	let if_block4 = /*horasDisponibles*/ ctx[5].length <= 0 && create_if_block_1$1(ctx);
    	let each_value_1 = /*horasDisponibles*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block5 = /*horasDisponibles*/ ctx[5].length <= 0 && create_if_block$2(ctx);
    	let each_value = /*horasDisponibles*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div14 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t3 = space();
    			div4 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t5 = space();
    			a = element("a");
    			i0 = element("i");
    			t6 = text("\r\n            Nueva cita");
    			t7 = space();
    			div13 = element("div");
    			div8 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Consultas en turno";
    			t9 = space();
    			div7 = element("div");
    			h41 = element("h4");
    			h41.textContent = "No hay cita";
    			t11 = space();
    			if (if_block0) if_block0.c();
    			t12 = space();
    			div10 = element("div");
    			h42 = element("h4");
    			h42.textContent = "Consultas pendientes";
    			t14 = space();
    			h43 = element("h4");
    			h43.textContent = "No hay cita";
    			t16 = space();
    			div9 = element("div");
    			if (if_block1) if_block1.c();
    			t17 = space();
    			div12 = element("div");
    			h44 = element("h4");
    			h44.textContent = "Consultas realizadas";
    			t19 = space();
    			h45 = element("h4");
    			h45.textContent = "No hay cita";
    			t21 = space();
    			div11 = element("div");
    			if (if_block2) if_block2.c();
    			t22 = space();
    			div42 = element("div");
    			div41 = element("div");
    			div40 = element("div");
    			div15 = element("div");
    			h50 = element("h5");
    			i1 = element("i");
    			t23 = text("\r\n          Paciente");
    			t24 = space();
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "×";
    			t26 = space();
    			div39 = element("div");
    			form = element("form");
    			input1 = element("input");
    			t27 = space();
    			div17 = element("div");
    			div16 = element("div");
    			label0 = element("label");
    			label0.textContent = "Nombre";
    			t29 = space();
    			input2 = element("input");
    			t30 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label1 = element("label");
    			label1.textContent = "Apellido";
    			t32 = space();
    			input3 = element("input");
    			t33 = space();
    			div21 = element("div");
    			div20 = element("div");
    			label2 = element("label");
    			label2.textContent = "Cedula";
    			t35 = space();
    			input4 = element("input");
    			t36 = space();
    			div23 = element("div");
    			div22 = element("div");
    			label3 = element("label");
    			label3.textContent = "Telefono";
    			t38 = space();
    			input5 = element("input");
    			t39 = space();
    			div25 = element("div");
    			div24 = element("div");
    			label4 = element("label");
    			label4.textContent = "Correo electronico";
    			t41 = space();
    			input6 = element("input");
    			t42 = space();
    			div27 = element("div");
    			div26 = element("div");
    			label5 = element("label");
    			label5.textContent = "Aseguradora";
    			t44 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t46 = space();
    			div29 = element("div");
    			div28 = element("div");
    			label6 = element("label");
    			label6.textContent = "No. Seguro";
    			t48 = space();
    			input7 = element("input");
    			t49 = space();
    			div31 = element("div");
    			div30 = element("div");
    			label7 = element("label");
    			label7.textContent = "Pais";
    			t51 = space();
    			select2 = element("select");
    			option2 = element("option");
    			option2.textContent = "- Seleccionar -";
    			option3 = element("option");
    			option3.textContent = "Rep. Dom.";
    			option4 = element("option");
    			option4.textContent = "Haiti";
    			option5 = element("option");
    			option5.textContent = "Venezuela";
    			t56 = space();
    			div33 = element("div");
    			div32 = element("div");
    			label8 = element("label");
    			label8.textContent = "Provincia";
    			t58 = space();
    			select3 = element("select");
    			option6 = element("option");
    			option6.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t60 = space();
    			div35 = element("div");
    			div34 = element("div");
    			label9 = element("label");
    			label9.textContent = "Direccion";
    			t62 = space();
    			textarea0 = element("textarea");
    			t63 = space();
    			div37 = element("div");
    			div36 = element("div");
    			label10 = element("label");
    			label10.textContent = "Observaciones";
    			t65 = space();
    			textarea1 = element("textarea");
    			t66 = space();
    			br = element("br");
    			t67 = space();
    			div38 = element("div");
    			button1 = element("button");
    			button1.textContent = "Cerrar";
    			t69 = space();
    			button2 = element("button");
    			t70 = text("Guardar\r\n              ");
    			i2 = element("i");
    			t71 = space();
    			if (if_block3) if_block3.c();
    			t72 = space();
    			div54 = element("div");
    			div53 = element("div");
    			div52 = element("div");
    			div43 = element("div");
    			h51 = element("h5");
    			i3 = element("i");
    			t73 = text("\r\n          Reprogramacion de cita");
    			t74 = space();
    			button3 = element("button");
    			span2 = element("span");
    			span2.textContent = "×";
    			t76 = space();
    			div50 = element("div");
    			div48 = element("div");
    			div45 = element("div");
    			div44 = element("div");
    			label11 = element("label");
    			label11.textContent = "Fecha";
    			t78 = space();
    			input8 = element("input");
    			t79 = space();
    			div47 = element("div");
    			div46 = element("div");
    			label12 = element("label");
    			label12.textContent = "Tanda";
    			t81 = space();
    			select4 = element("select");
    			option7 = element("option");
    			option7.textContent = "- Seleccionar -";
    			option8 = element("option");
    			option8.textContent = "Matutina";
    			option9 = element("option");
    			option9.textContent = "Vespertina";
    			t85 = space();
    			div49 = element("div");
    			if (if_block4) if_block4.c();
    			t86 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t87 = space();
    			div51 = element("div");
    			button4 = element("button");
    			button4.textContent = "Anular cita";
    			t89 = space();
    			div66 = element("div");
    			div65 = element("div");
    			div64 = element("div");
    			div55 = element("div");
    			h52 = element("h5");
    			i4 = element("i");
    			t90 = text("\r\n          Creacion de cita");
    			t91 = space();
    			button5 = element("button");
    			span3 = element("span");
    			span3.textContent = "×";
    			t93 = space();
    			div62 = element("div");
    			div60 = element("div");
    			div57 = element("div");
    			div56 = element("div");
    			label13 = element("label");
    			label13.textContent = "Fecha";
    			t95 = space();
    			input9 = element("input");
    			t96 = space();
    			div59 = element("div");
    			div58 = element("div");
    			label14 = element("label");
    			label14.textContent = "Tanda";
    			t98 = space();
    			select5 = element("select");
    			option10 = element("option");
    			option10.textContent = "- Seleccionar -";
    			option11 = element("option");
    			option11.textContent = "Matutina";
    			option12 = element("option");
    			option12.textContent = "Vespertina";
    			t102 = space();
    			div61 = element("div");
    			if (if_block5) if_block5.c();
    			t103 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t104 = space();
    			div63 = element("div");
    			button6 = element("button");
    			button6.textContent = "Anular cita";
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "class", "form-control form-control-appended");
    			attr_dev(input0, "data-bind", "textInput: busqueda");
    			attr_dev(input0, "placeholder", "Buscar");
    			add_location(input0, file$4, 403, 14, 10359);
    			attr_dev(span0, "class", "mdi mdi-magnify");
    			add_location(span0, file$4, 411, 18, 10701);
    			attr_dev(div0, "class", "input-group-text");
    			add_location(div0, file$4, 410, 16, 10651);
    			attr_dev(div1, "class", "input-group-append");
    			add_location(div1, file$4, 409, 14, 10601);
    			attr_dev(div2, "class", "input-group input-group-flush mb-3");
    			add_location(div2, file$4, 402, 12, 10295);
    			attr_dev(div3, "class", "col-md-5");
    			add_location(div3, file$4, 401, 10, 10259);
    			option0.__value = option0_value_value = 0;
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			add_location(option0, file$4, 418, 14, 10946);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "id", "sltMedicos");
    			set_style(select0, "width", "100%");
    			add_location(select0, file$4, 417, 12, 10865);
    			attr_dev(div4, "class", "col-lg-4");
    			add_location(div4, file$4, 416, 10, 10829);
    			attr_dev(i0, "class", "mdi mdi-plus");
    			add_location(i0, file$4, 426, 12, 11296);
    			attr_dev(a, "href", "#/Cita/Crear");
    			attr_dev(a, "class", "btn m-b-30 ml-2 mr-2 ml-3 btn-primary");
    			add_location(a, file$4, 425, 10, 11213);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$4, 400, 8, 10230);
    			attr_dev(div6, "class", "mt-4 col-md-12");
    			add_location(div6, file$4, 399, 6, 10192);
    			attr_dev(h40, "class", "alert-heading");
    			add_location(h40, file$4, 434, 10, 11500);
    			toggle_class(h41, "d-none", /*citasEnTurno*/ ctx[3].length > 0);
    			add_location(h41, file$4, 436, 12, 11605);
    			attr_dev(div7, "class", "table-responsive");
    			add_location(div7, file$4, 435, 10, 11561);
    			attr_dev(div8, "class", "alert alert-success");
    			attr_dev(div8, "role", "alert");
    			add_location(div8, file$4, 433, 8, 11442);
    			attr_dev(h42, "class", "alert-heading");
    			add_location(h42, file$4, 474, 10, 13070);
    			toggle_class(h43, "d-none", /*citasPendientes*/ ctx[2].length > 0);
    			add_location(h43, file$4, 475, 10, 13133);
    			attr_dev(div9, "class", "table-responsive");
    			add_location(div9, file$4, 476, 10, 13207);
    			attr_dev(div10, "class", "alert alert-primary");
    			attr_dev(div10, "role", "alert");
    			add_location(div10, file$4, 473, 8, 13012);
    			attr_dev(h44, "class", "alert-heading");
    			add_location(h44, file$4, 527, 10, 15318);
    			toggle_class(h45, "d-none", /*citasRealizadas*/ ctx[4].length > 0);
    			add_location(h45, file$4, 528, 10, 15381);
    			attr_dev(div11, "class", "table-responsive");
    			add_location(div11, file$4, 529, 10, 15455);
    			attr_dev(div12, "class", "alert alert-secondary");
    			attr_dev(div12, "role", "alert");
    			add_location(div12, file$4, 526, 8, 15258);
    			attr_dev(div13, "class", "col-md-12 m-b-30");
    			add_location(div13, file$4, 431, 6, 11400);
    			attr_dev(div14, "class", "container mt-3");
    			add_location(div14, file$4, 398, 4, 10156);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$4, 397, 2, 10119);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$4, 395, 0, 10076);
    			attr_dev(i1, "class", "mdi mdi-account-search-outline");
    			add_location(i1, file$4, 591, 10, 17627);
    			attr_dev(h50, "class", "modal-title");
    			attr_dev(h50, "id", "modalPacienteLabel");
    			add_location(h50, file$4, 590, 8, 17567);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$4, 599, 10, 17848);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$4, 594, 8, 17716);
    			attr_dev(div15, "class", "modal-header");
    			add_location(div15, file$4, 589, 6, 17531);
    			attr_dev(input1, "type", "hidden");
    			attr_dev(input1, "name", "IdUser");
    			input1.value = "0";
    			add_location(input1, file$4, 604, 10, 18034);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$4, 607, 14, 18179);
    			attr_dev(input2, "type", "name");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "name", "Name");
    			attr_dev(input2, "maxlength", "200");
    			input2.required = true;
    			add_location(input2, file$4, 608, 14, 18223);
    			attr_dev(div16, "class", "form-group col-md-12");
    			add_location(div16, file$4, 606, 12, 18129);
    			attr_dev(div17, "class", "form-row");
    			add_location(div17, file$4, 605, 10, 18093);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$4, 619, 14, 18569);
    			attr_dev(input3, "type", "name");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "name", "Name");
    			attr_dev(input3, "maxlength", "200");
    			input3.required = true;
    			add_location(input3, file$4, 620, 14, 18615);
    			attr_dev(div18, "class", "form-group col-md-12");
    			add_location(div18, file$4, 618, 12, 18519);
    			attr_dev(div19, "class", "form-row");
    			add_location(div19, file$4, 617, 10, 18483);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$4, 631, 14, 18964);
    			attr_dev(input4, "type", "name");
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "name", "Name");
    			attr_dev(input4, "maxlength", "200");
    			add_location(input4, file$4, 632, 14, 19008);
    			attr_dev(div20, "class", "form-group col-md-12");
    			add_location(div20, file$4, 630, 12, 18914);
    			attr_dev(div21, "class", "form-row");
    			add_location(div21, file$4, 629, 10, 18878);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$4, 642, 14, 19328);
    			attr_dev(input5, "type", "tel");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "name", "Name");
    			attr_dev(input5, "maxlength", "200");
    			input5.required = true;
    			add_location(input5, file$4, 643, 14, 19374);
    			attr_dev(div22, "class", "form-group col-md-12");
    			add_location(div22, file$4, 641, 12, 19278);
    			attr_dev(div23, "class", "form-row");
    			add_location(div23, file$4, 640, 10, 19242);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$4, 654, 14, 19721);
    			attr_dev(input6, "type", "email");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "name", "Name");
    			attr_dev(input6, "maxlength", "200");
    			add_location(input6, file$4, 655, 14, 19777);
    			attr_dev(div24, "class", "form-group col-md-12");
    			add_location(div24, file$4, 653, 12, 19671);
    			attr_dev(div25, "class", "form-row");
    			add_location(div25, file$4, 652, 10, 19635);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$4, 665, 14, 20097);
    			option1.__value = "0";
    			option1.value = option1.__value;
    			option1.disabled = true;
    			option1.selected = true;
    			add_location(option1, file$4, 669, 16, 20274);
    			attr_dev(select1, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[9].aseguradoraID === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[49].call(select1));
    			add_location(select1, file$4, 666, 14, 20146);
    			attr_dev(div26, "class", "form-group col-md-12");
    			add_location(div26, file$4, 664, 12, 20047);
    			attr_dev(div27, "class", "form-row");
    			add_location(div27, file$4, 663, 10, 20011);
    			attr_dev(label6, "for", "");
    			add_location(label6, file$4, 678, 14, 20632);
    			attr_dev(input7, "type", "text");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "name", "Name");
    			attr_dev(input7, "maxlength", "200");
    			add_location(input7, file$4, 679, 14, 20680);
    			attr_dev(div28, "class", "form-group col-md-12");
    			add_location(div28, file$4, 677, 12, 20582);
    			attr_dev(div29, "class", "form-row");
    			add_location(div29, file$4, 676, 10, 20546);
    			attr_dev(label7, "for", "");
    			add_location(label7, file$4, 689, 14, 21004);
    			option2.__value = "0";
    			option2.value = option2.__value;
    			option2.disabled = true;
    			option2.selected = true;
    			add_location(option2, file$4, 691, 16, 21139);
    			option3.__value = option3_value_value = "Rep. Dom.";
    			option3.value = option3.__value;
    			add_location(option3, file$4, 692, 16, 21217);
    			option4.__value = option4_value_value = "Haiti";
    			option4.value = option4.__value;
    			add_location(option4, file$4, 693, 16, 21281);
    			option5.__value = option5_value_value = "Venezuela";
    			option5.value = option5.__value;
    			add_location(option5, file$4, 694, 16, 21337);
    			attr_dev(select2, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[9].nacionalidad === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[51].call(select2));
    			add_location(select2, file$4, 690, 14, 21046);
    			attr_dev(div30, "class", "form-group col-md-12");
    			add_location(div30, file$4, 688, 12, 20954);
    			attr_dev(div31, "class", "form-row");
    			add_location(div31, file$4, 687, 10, 20918);
    			attr_dev(label8, "for", "");
    			add_location(label8, file$4, 700, 14, 21544);
    			option6.__value = "0";
    			option6.value = option6.__value;
    			option6.disabled = true;
    			option6.selected = true;
    			add_location(option6, file$4, 704, 16, 21717);
    			attr_dev(select3, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[9].provinciaID === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[52].call(select3));
    			add_location(select3, file$4, 701, 14, 21591);
    			attr_dev(div32, "class", "form-group col-md-12");
    			add_location(div32, file$4, 699, 12, 21494);
    			attr_dev(div33, "class", "form-row");
    			add_location(div33, file$4, 698, 10, 21458);
    			attr_dev(label9, "for", "");
    			add_location(label9, file$4, 713, 14, 22073);
    			attr_dev(textarea0, "class", "form-control");
    			attr_dev(textarea0, "rows", "2");
    			add_location(textarea0, file$4, 714, 14, 22120);
    			attr_dev(div34, "class", "form-group col-md-12");
    			add_location(div34, file$4, 712, 12, 22023);
    			attr_dev(div35, "class", "form-row");
    			add_location(div35, file$4, 711, 10, 21987);
    			attr_dev(label10, "for", "");
    			add_location(label10, file$4, 722, 14, 22381);
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "rows", "3");
    			add_location(textarea1, file$4, 723, 14, 22432);
    			attr_dev(div36, "class", "form-group col-md-12");
    			add_location(div36, file$4, 721, 12, 22331);
    			attr_dev(div37, "class", "form-row");
    			add_location(div37, file$4, 720, 10, 22295);
    			add_location(br, file$4, 730, 10, 22613);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-outline-danger");
    			attr_dev(button1, "data-dismiss", "modal");
    			add_location(button1, file$4, 732, 12, 22671);
    			attr_dev(i2, "class", "mdi mdi-content-save-outline");
    			add_location(i2, file$4, 740, 14, 22942);
    			attr_dev(button2, "type", "submit");
    			attr_dev(button2, "class", "btn btn-outline-primary");
    			add_location(button2, file$4, 738, 12, 22849);
    			attr_dev(div38, "class", "modal-footer");
    			add_location(div38, file$4, 731, 10, 22631);
    			attr_dev(form, "id", "frmPaciente");
    			add_location(form, file$4, 603, 8, 17956);
    			attr_dev(div39, "class", "modal-body svelte-1gvzc7h");
    			add_location(div39, file$4, 602, 6, 17922);
    			attr_dev(div40, "class", "modal-content");
    			add_location(div40, file$4, 588, 4, 17496);
    			attr_dev(div41, "class", "modal-dialog svelte-1gvzc7h");
    			attr_dev(div41, "role", "document");
    			add_location(div41, file$4, 587, 2, 17448);
    			attr_dev(div42, "class", "modal fade modal-slide-right svelte-1gvzc7h");
    			attr_dev(div42, "id", "modalPaciente");
    			attr_dev(div42, "tabindex", "-1");
    			attr_dev(div42, "role", "dialog");
    			attr_dev(div42, "aria-labelledby", "modalPacienteLabel");
    			set_style(div42, "display", "none");
    			set_style(div42, "padding-right", "16px");
    			attr_dev(div42, "aria-modal", "true");
    			add_location(div42, file$4, 579, 0, 17235);
    			attr_dev(i3, "class", "mdi mdi-calendar-plus");
    			add_location(i3, file$4, 772, 10, 23817);
    			attr_dev(h51, "class", "modal-title");
    			attr_dev(h51, "id", "modalCrearCitaLabel");
    			add_location(h51, file$4, 771, 8, 23756);
    			attr_dev(span2, "aria-hidden", "true");
    			add_location(span2, file$4, 780, 10, 24043);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "close");
    			attr_dev(button3, "data-dismiss", "modal");
    			attr_dev(button3, "aria-label", "Close");
    			add_location(button3, file$4, 775, 8, 23911);
    			attr_dev(div43, "class", "modal-header");
    			add_location(div43, file$4, 770, 6, 23720);
    			attr_dev(label11, "for", "inputAddress");
    			add_location(label11, file$4, 788, 14, 24304);
    			attr_dev(input8, "type", "date");
    			attr_dev(input8, "class", "form-control form-control-sm");
    			add_location(input8, file$4, 789, 14, 24359);
    			attr_dev(div44, "class", "form-group");
    			add_location(div44, file$4, 787, 12, 24264);
    			attr_dev(div45, "class", "col-lg-6");
    			add_location(div45, file$4, 786, 10, 24228);
    			attr_dev(label12, "class", "font-secondary");
    			add_location(label12, file$4, 798, 14, 24671);
    			option7.__value = option7_value_value = 0;
    			option7.value = option7.__value;
    			option7.disabled = true;
    			add_location(option7, file$4, 803, 16, 24916);
    			option8.__value = option8_value_value = 1;
    			option8.value = option8.__value;
    			add_location(option8, file$4, 804, 16, 24985);
    			option9.__value = option9_value_value = 2;
    			option9.value = option9.__value;
    			add_location(option9, file$4, 805, 16, 25038);
    			attr_dev(select4, "class", "form-control form-control-sm js-select2");
    			if (/*tandaID*/ ctx[8] === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[56].call(select4));
    			add_location(select4, file$4, 799, 14, 24730);
    			attr_dev(div46, "class", "form-group ");
    			add_location(div46, file$4, 797, 12, 24630);
    			attr_dev(div47, "class", "col-lg-6");
    			add_location(div47, file$4, 796, 10, 24594);
    			attr_dev(div48, "class", "row");
    			add_location(div48, file$4, 785, 8, 24199);
    			attr_dev(div49, "class", "list-group list");
    			add_location(div49, file$4, 810, 8, 25164);
    			attr_dev(div50, "class", "modal-body svelte-1gvzc7h");
    			set_style(div50, "height", "100%");
    			set_style(div50, "top", "0");
    			set_style(div50, "overflow", "auto");
    			add_location(div50, file$4, 783, 6, 24117);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "btn btn-danger");
    			add_location(button4, file$4, 835, 8, 26036);
    			attr_dev(div51, "class", "modal-footer");
    			toggle_class(div51, "d-none", /*cita*/ ctx[10].estadoID == 3);
    			add_location(div51, file$4, 834, 6, 25966);
    			attr_dev(div52, "class", "modal-content");
    			add_location(div52, file$4, 769, 4, 23685);
    			attr_dev(div53, "class", "modal-dialog svelte-1gvzc7h");
    			attr_dev(div53, "role", "document");
    			add_location(div53, file$4, 768, 2, 23637);
    			attr_dev(div54, "class", "modal fade modal-slide-right svelte-1gvzc7h");
    			attr_dev(div54, "id", "modalCrearCita");
    			attr_dev(div54, "tabindex", "-1");
    			attr_dev(div54, "role", "dialog");
    			attr_dev(div54, "aria-labelledby", "modalCrearCitaLabel");
    			set_style(div54, "display", "none");
    			set_style(div54, "padding-right", "16px");
    			attr_dev(div54, "aria-modal", "true");
    			add_location(div54, file$4, 760, 0, 23422);
    			attr_dev(i4, "class", "mdi mdi-calendar-plus");
    			add_location(i4, file$4, 856, 10, 26599);
    			attr_dev(h52, "class", "modal-title");
    			attr_dev(h52, "id", "modalNuevaCitaLabel");
    			add_location(h52, file$4, 855, 8, 26538);
    			attr_dev(span3, "aria-hidden", "true");
    			add_location(span3, file$4, 864, 10, 26819);
    			attr_dev(button5, "type", "button");
    			attr_dev(button5, "class", "close");
    			attr_dev(button5, "data-dismiss", "modal");
    			attr_dev(button5, "aria-label", "Close");
    			add_location(button5, file$4, 859, 8, 26687);
    			attr_dev(div55, "class", "modal-header");
    			add_location(div55, file$4, 854, 6, 26502);
    			attr_dev(label13, "for", "inputAddress");
    			add_location(label13, file$4, 872, 14, 27080);
    			attr_dev(input9, "type", "date");
    			attr_dev(input9, "class", "form-control form-control-sm");
    			add_location(input9, file$4, 873, 14, 27135);
    			attr_dev(div56, "class", "form-group");
    			add_location(div56, file$4, 871, 12, 27040);
    			attr_dev(div57, "class", "col-lg-6");
    			add_location(div57, file$4, 870, 10, 27004);
    			attr_dev(label14, "class", "font-secondary");
    			add_location(label14, file$4, 882, 14, 27447);
    			option10.__value = option10_value_value = 0;
    			option10.value = option10.__value;
    			option10.disabled = true;
    			add_location(option10, file$4, 887, 16, 27692);
    			option11.__value = option11_value_value = 1;
    			option11.value = option11.__value;
    			add_location(option11, file$4, 888, 16, 27761);
    			option12.__value = option12_value_value = 2;
    			option12.value = option12.__value;
    			add_location(option12, file$4, 889, 16, 27814);
    			attr_dev(select5, "class", "form-control form-control-sm js-select2");
    			if (/*tandaID*/ ctx[8] === void 0) add_render_callback(() => /*select5_change_handler*/ ctx[58].call(select5));
    			add_location(select5, file$4, 883, 14, 27506);
    			attr_dev(div58, "class", "form-group ");
    			add_location(div58, file$4, 881, 12, 27406);
    			attr_dev(div59, "class", "col-lg-6");
    			add_location(div59, file$4, 880, 10, 27370);
    			attr_dev(div60, "class", "row");
    			add_location(div60, file$4, 869, 8, 26975);
    			attr_dev(div61, "class", "list-group list");
    			add_location(div61, file$4, 894, 8, 27940);
    			attr_dev(div62, "class", "modal-body svelte-1gvzc7h");
    			set_style(div62, "height", "100%");
    			set_style(div62, "top", "0");
    			set_style(div62, "overflow", "auto");
    			add_location(div62, file$4, 867, 6, 26893);
    			attr_dev(button6, "type", "button");
    			attr_dev(button6, "class", "btn btn-danger");
    			add_location(button6, file$4, 919, 8, 28809);
    			attr_dev(div63, "class", "modal-footer");
    			toggle_class(div63, "d-none", /*cita*/ ctx[10].estadoID == 3);
    			add_location(div63, file$4, 918, 6, 28739);
    			attr_dev(div64, "class", "modal-content");
    			add_location(div64, file$4, 853, 4, 26467);
    			attr_dev(div65, "class", "modal-dialog svelte-1gvzc7h");
    			attr_dev(div65, "role", "document");
    			add_location(div65, file$4, 852, 2, 26419);
    			attr_dev(div66, "class", "modal fade modal-slide-right svelte-1gvzc7h");
    			attr_dev(div66, "id", "modalNuevaCita");
    			attr_dev(div66, "tabindex", "-1");
    			attr_dev(div66, "role", "dialog");
    			attr_dev(div66, "aria-labelledby", "modalNuevaCitaLabel");
    			set_style(div66, "display", "none");
    			set_style(div66, "padding-right", "16px");
    			attr_dev(div66, "aria-modal", "true");
    			add_location(div66, file$4, 844, 0, 26204);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div14);
    			append_dev(div14, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*busqueda*/ ctx[0]);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(select0, null);
    			}

    			append_dev(div5, t5);
    			append_dev(div5, a);
    			append_dev(a, i0);
    			append_dev(a, t6);
    			append_dev(div14, t7);
    			append_dev(div14, div13);
    			append_dev(div13, div8);
    			append_dev(div8, h40);
    			append_dev(div8, t9);
    			append_dev(div8, div7);
    			append_dev(div7, h41);
    			append_dev(div7, t11);
    			if (if_block0) if_block0.m(div7, null);
    			append_dev(div13, t12);
    			append_dev(div13, div10);
    			append_dev(div10, h42);
    			append_dev(div10, t14);
    			append_dev(div10, h43);
    			append_dev(div10, t16);
    			append_dev(div10, div9);
    			if (if_block1) if_block1.m(div9, null);
    			append_dev(div13, t17);
    			append_dev(div13, div12);
    			append_dev(div12, h44);
    			append_dev(div12, t19);
    			append_dev(div12, h45);
    			append_dev(div12, t21);
    			append_dev(div12, div11);
    			if (if_block2) if_block2.m(div11, null);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, div42, anchor);
    			append_dev(div42, div41);
    			append_dev(div41, div40);
    			append_dev(div40, div15);
    			append_dev(div15, h50);
    			append_dev(h50, i1);
    			append_dev(h50, t23);
    			append_dev(div15, t24);
    			append_dev(div15, button0);
    			append_dev(button0, span1);
    			append_dev(div40, t26);
    			append_dev(div40, div39);
    			append_dev(div39, form);
    			append_dev(form, input1);
    			append_dev(form, t27);
    			append_dev(form, div17);
    			append_dev(div17, div16);
    			append_dev(div16, label0);
    			append_dev(div16, t29);
    			append_dev(div16, input2);
    			set_input_value(input2, /*paciente*/ ctx[9].nombre);
    			append_dev(form, t30);
    			append_dev(form, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label1);
    			append_dev(div18, t32);
    			append_dev(div18, input3);
    			set_input_value(input3, /*paciente*/ ctx[9].apellidos);
    			append_dev(form, t33);
    			append_dev(form, div21);
    			append_dev(div21, div20);
    			append_dev(div20, label2);
    			append_dev(div20, t35);
    			append_dev(div20, input4);
    			set_input_value(input4, /*paciente*/ ctx[9].cedula);
    			append_dev(form, t36);
    			append_dev(form, div23);
    			append_dev(div23, div22);
    			append_dev(div22, label3);
    			append_dev(div22, t38);
    			append_dev(div22, input5);
    			set_input_value(input5, /*paciente*/ ctx[9].telefono);
    			append_dev(form, t39);
    			append_dev(form, div25);
    			append_dev(div25, div24);
    			append_dev(div24, label4);
    			append_dev(div24, t41);
    			append_dev(div24, input6);
    			set_input_value(input6, /*paciente*/ ctx[9].correo);
    			append_dev(form, t42);
    			append_dev(form, div27);
    			append_dev(div27, div26);
    			append_dev(div26, label5);
    			append_dev(div26, t44);
    			append_dev(div26, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select1, null);
    			}

    			select_option(select1, /*paciente*/ ctx[9].aseguradoraID);
    			append_dev(form, t46);
    			append_dev(form, div29);
    			append_dev(div29, div28);
    			append_dev(div28, label6);
    			append_dev(div28, t48);
    			append_dev(div28, input7);
    			set_input_value(input7, /*paciente*/ ctx[9].noAfiliado);
    			append_dev(form, t49);
    			append_dev(form, div31);
    			append_dev(div31, div30);
    			append_dev(div30, label7);
    			append_dev(div30, t51);
    			append_dev(div30, select2);
    			append_dev(select2, option2);
    			append_dev(select2, option3);
    			append_dev(select2, option4);
    			append_dev(select2, option5);
    			select_option(select2, /*paciente*/ ctx[9].nacionalidad);
    			append_dev(form, t56);
    			append_dev(form, div33);
    			append_dev(div33, div32);
    			append_dev(div32, label8);
    			append_dev(div32, t58);
    			append_dev(div32, select3);
    			append_dev(select3, option6);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select3, null);
    			}

    			select_option(select3, /*paciente*/ ctx[9].provinciaID);
    			append_dev(form, t60);
    			append_dev(form, div35);
    			append_dev(div35, div34);
    			append_dev(div34, label9);
    			append_dev(div34, t62);
    			append_dev(div34, textarea0);
    			set_input_value(textarea0, /*paciente*/ ctx[9].direccion);
    			append_dev(form, t63);
    			append_dev(form, div37);
    			append_dev(div37, div36);
    			append_dev(div36, label10);
    			append_dev(div36, t65);
    			append_dev(div36, textarea1);
    			set_input_value(textarea1, /*paciente*/ ctx[9].observaciones);
    			append_dev(form, t66);
    			append_dev(form, br);
    			append_dev(form, t67);
    			append_dev(form, div38);
    			append_dev(div38, button1);
    			append_dev(div38, t69);
    			append_dev(div38, button2);
    			append_dev(button2, t70);
    			append_dev(button2, i2);
    			append_dev(div38, t71);
    			if (if_block3) if_block3.m(div38, null);
    			insert_dev(target, t72, anchor);
    			insert_dev(target, div54, anchor);
    			append_dev(div54, div53);
    			append_dev(div53, div52);
    			append_dev(div52, div43);
    			append_dev(div43, h51);
    			append_dev(h51, i3);
    			append_dev(h51, t73);
    			append_dev(div43, t74);
    			append_dev(div43, button3);
    			append_dev(button3, span2);
    			append_dev(div52, t76);
    			append_dev(div52, div50);
    			append_dev(div50, div48);
    			append_dev(div48, div45);
    			append_dev(div45, div44);
    			append_dev(div44, label11);
    			append_dev(div44, t78);
    			append_dev(div44, input8);
    			set_input_value(input8, /*fecha*/ ctx[7]);
    			append_dev(div48, t79);
    			append_dev(div48, div47);
    			append_dev(div47, div46);
    			append_dev(div46, label12);
    			append_dev(div46, t81);
    			append_dev(div46, select4);
    			append_dev(select4, option7);
    			append_dev(select4, option8);
    			append_dev(select4, option9);
    			select_option(select4, /*tandaID*/ ctx[8]);
    			append_dev(div50, t85);
    			append_dev(div50, div49);
    			if (if_block4) if_block4.m(div49, null);
    			append_dev(div49, t86);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div49, null);
    			}

    			append_dev(div52, t87);
    			append_dev(div52, div51);
    			append_dev(div51, button4);
    			insert_dev(target, t89, anchor);
    			insert_dev(target, div66, anchor);
    			append_dev(div66, div65);
    			append_dev(div65, div64);
    			append_dev(div64, div55);
    			append_dev(div55, h52);
    			append_dev(h52, i4);
    			append_dev(h52, t90);
    			append_dev(div55, t91);
    			append_dev(div55, button5);
    			append_dev(button5, span3);
    			append_dev(div64, t93);
    			append_dev(div64, div62);
    			append_dev(div62, div60);
    			append_dev(div60, div57);
    			append_dev(div57, div56);
    			append_dev(div56, label13);
    			append_dev(div56, t95);
    			append_dev(div56, input9);
    			set_input_value(input9, /*fecha*/ ctx[7]);
    			append_dev(div60, t96);
    			append_dev(div60, div59);
    			append_dev(div59, div58);
    			append_dev(div58, label14);
    			append_dev(div58, t98);
    			append_dev(div58, select5);
    			append_dev(select5, option10);
    			append_dev(select5, option11);
    			append_dev(select5, option12);
    			select_option(select5, /*tandaID*/ ctx[8]);
    			append_dev(div62, t102);
    			append_dev(div62, div61);
    			if (if_block5) if_block5.m(div61, null);
    			append_dev(div61, t103);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div61, null);
    			}

    			append_dev(div64, t104);
    			append_dev(div64, div63);
    			append_dev(div63, button6);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[37]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[44]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[45]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[46]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[47]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[48]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[49]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[50]),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[51]),
    					listen_dev(select3, "change", /*select3_change_handler*/ ctx[52]),
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[53]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[54]),
    					listen_dev(form, "submit", prevent_default(/*guardarPaciente*/ ctx[16]), false, true, false),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[55]),
    					listen_dev(input8, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(select4, "change", /*select4_change_handler*/ ctx[56]),
    					listen_dev(select4, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(button4, "click", /*anularCita*/ ctx[19], false, false, false),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[57]),
    					listen_dev(input9, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(select5, "change", /*select5_change_handler*/ ctx[58]),
    					listen_dev(select5, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(button6, "click", /*anularCita*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*busqueda*/ 1) {
    				set_input_value(input0, /*busqueda*/ ctx[0]);
    			}

    			if (dirty[0] & /*medicos*/ 2) {
    				each_value_7 = /*medicos*/ ctx[1];
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_7(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_7.length;
    			}

    			if (dirty[0] & /*citasEnTurno*/ 8) {
    				toggle_class(h41, "d-none", /*citasEnTurno*/ ctx[3].length > 0);
    			}

    			if (/*citasEnTurno*/ ctx[3].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					if_block0.m(div7, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*citasPendientes*/ 4) {
    				toggle_class(h43, "d-none", /*citasPendientes*/ ctx[2].length > 0);
    			}

    			if (/*citasPendientes*/ ctx[2].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(div9, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*citasRealizadas*/ 16) {
    				toggle_class(h45, "d-none", /*citasRealizadas*/ ctx[4].length > 0);
    			}

    			if (/*citasRealizadas*/ ctx[4].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					if_block2.m(div11, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(input2, /*paciente*/ ctx[9].nombre);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(input3, /*paciente*/ ctx[9].apellidos);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(input4, /*paciente*/ ctx[9].cedula);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(input5, /*paciente*/ ctx[9].telefono);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608 && input6.value !== /*paciente*/ ctx[9].correo) {
    				set_input_value(input6, /*paciente*/ ctx[9].correo);
    			}

    			if (dirty[0] & /*aseguradoras*/ 4096) {
    				each_value_3 = /*aseguradoras*/ ctx[12];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				select_option(select1, /*paciente*/ ctx[9].aseguradoraID);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608 && input7.value !== /*paciente*/ ctx[9].noAfiliado) {
    				set_input_value(input7, /*paciente*/ ctx[9].noAfiliado);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				select_option(select2, /*paciente*/ ctx[9].nacionalidad);
    			}

    			if (dirty[0] & /*provincias*/ 2048) {
    				each_value_2 = /*provincias*/ ctx[11];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select3, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				select_option(select3, /*paciente*/ ctx[9].provinciaID);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(textarea0, /*paciente*/ ctx[9].direccion);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 4608) {
    				set_input_value(textarea1, /*paciente*/ ctx[9].observaciones);
    			}

    			if (/*cita*/ ctx[10].estadoID == 2) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_2(ctx);
    					if_block3.c();
    					if_block3.m(div38, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty[0] & /*fecha*/ 128) {
    				set_input_value(input8, /*fecha*/ ctx[7]);
    			}

    			if (dirty[0] & /*tandaID*/ 256) {
    				select_option(select4, /*tandaID*/ ctx[8]);
    			}

    			if (/*horasDisponibles*/ ctx[5].length <= 0) {
    				if (if_block4) ; else {
    					if_block4 = create_if_block_1$1(ctx);
    					if_block4.c();
    					if_block4.m(div49, t86);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (dirty[0] & /*cambiarFechaCita, horasDisponibles*/ 131104) {
    				each_value_1 = /*horasDisponibles*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div49, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*cita*/ 1024) {
    				toggle_class(div51, "d-none", /*cita*/ ctx[10].estadoID == 3);
    			}

    			if (dirty[0] & /*fecha*/ 128) {
    				set_input_value(input9, /*fecha*/ ctx[7]);
    			}

    			if (dirty[0] & /*tandaID*/ 256) {
    				select_option(select5, /*tandaID*/ ctx[8]);
    			}

    			if (/*horasDisponibles*/ ctx[5].length <= 0) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block$2(ctx);
    					if_block5.c();
    					if_block5.m(div61, t103);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (dirty[0] & /*irACita, horasDisponibles*/ 1048608) {
    				each_value = /*horasDisponibles*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div61, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*cita*/ 1024) {
    				toggle_class(div63, "d-none", /*cita*/ ctx[10].estadoID == 3);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_4, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(div42);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			if (if_block3) if_block3.d();
    			if (detaching) detach_dev(t72);
    			if (detaching) detach_dev(div54);
    			if (if_block4) if_block4.d();
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t89);
    			if (detaching) detach_dev(div66);
    			if (if_block5) if_block5.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $session;
    	let $axios;
    	let $activePage;
    	let $connection;
    	let $errorConexion;
    	let $toast;
    	let $dataCita;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(25, $session = $$value));
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(26, $axios = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(27, $activePage = $$value));
    	validate_store(connection, "connection");
    	component_subscribe($$self, connection, $$value => $$invalidate(28, $connection = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(29, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(30, $toast = $$value));
    	validate_store(dataCita, "dataCita");
    	component_subscribe($$self, dataCita, $$value => $$invalidate(31, $dataCita = $$value));
    	let user = {};
    	user = new UserManager($session.authorizationHeader.Authorization);

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "asistente.index");
    	let busqueda = "";
    	let medicos = [];
    	let citasPendientes = [];
    	let citasEnTurno = [];
    	let citasRealizadas = [];
    	let horasDisponibles = [];

    	let provincias = [
    		{ id: 1, nombre: "Duarte" },
    		{ id: 2, nombre: "Santiago" },
    		{ id: 3, nombre: "Distrito Nacional" }
    	];

    	let aseguradoras = [
    		{ id: 1, nombre: "SENASA" },
    		{ id: 2, nombre: "HUMANO SEGURO" },
    		{ id: 3, nombre: "RENACER" },
    		{ id: 4, nombre: "PALIC" },
    		{ id: 5, nombre: "FUTURO" }
    	];

    	let idMedico = "";
    	let pacienteEnviado = "";
    	let userNameMedico = "";
    	let fecha = "";
    	let tandaID = 0;

    	let paciente = {
    		id: "",
    		nombre: "",
    		apellido: "",
    		cedula: "",
    		correo: "",
    		telefono: "",
    		aseguradoraID: 0,
    		nombreAseguradora: "",
    		provinciaID: 0,
    		nacionalidad: "",
    		noAfiliado: "",
    		sexo: "",
    		direccion: "",
    		observaciones: ""
    	};

    	let cita = {
    		id: 0,
    		medicoID: "",
    		pacienteID: "",
    		aseguradoraID: 0,
    		estadoID: 1,
    		fecha: "",
    		observaciones: "",
    		inactivo: false
    	};

    	onMount(() => {
    		jQuery("#sltMedicos").select2();

    		jQuery("#sltMedicos").on("select2:select", e => {
    			let data = e.params.data;
    			idMedico = data.id.split("=")[0];
    			userNameMedico = data.id.split("=")[1];
    			cargarPacienteEnviado();
    			cargarCitas();
    			cargarCitasRealizadas();
    		});

    		cargarMedicos();
    	});

    	$connection.on("RecibirAvisoDelPaciente", (data, paciente) => {
    		if ($activePage == "asistente.index") {
    			if (citasEnTurno.length > 0) {
    				$$invalidate(6, pacienteEnviado = paciente);

    				if (pacienteEnviado == "") {
    					cargarCitas();
    					cargarCitasRealizadas();
    				}
    			}

    			if (paciente == "") {
    				sweetalert2_all.fire({
    					title: "Aviso",
    					text: "El paciente ya fue atendido, favor de mandar otro",
    					icon: "success"
    				});
    			}
    		}
    	});

    	function cargarMedicos() {
    		$axios.get("/MedicosAsistentes/" + user.nameid + "/Medicos").then(res => {
    			$$invalidate(1, medicos = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarCitas() {
    		$axios.get("/Medicos/Citas/" + idMedico).then(res => {
    			let array = res.data.filter(e => moment(e.fecha).format("YYYY-MM-DD") == moment().format("YYYY-MM-DD"));
    			$$invalidate(2, citasPendientes = array.filter(e => e.estadoID == 1));
    			$$invalidate(3, citasEnTurno = array.filter(e => e.estadoID == 2));
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarCitasRealizadas() {
    		$axios.get("/Medicos/CitasRealizadas/" + idMedico).then(res => {
    			$$invalidate(4, citasRealizadas = res.data.filter(e => moment(e.fecha).format("YYYY-MM-DD") == moment().format("YYYY-MM-DD")));
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function buscarDisponibilidadHorario() {
    		if (fecha == "" || tandaID <= 0) {
    			$$invalidate(5, horasDisponibles = []);
    			return;
    		}

    		let params = "date=" + fecha + "&" + "tandiId=" + tandaID;

    		$axios.get("/Medicos/HorasDisponibles/" + idMedico + "?" + params).then(res => {
    			$$invalidate(5, horasDisponibles = res.data.map(x => {
    				return {
    					time: x,
    					hora: moment(x, "LT").format("LT")
    				};
    			}));
    		}).catch(err => {
    			$$invalidate(5, horasDisponibles = []);
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarDatosPaciente(item) {
    		$$invalidate(10, cita = item);

    		$axios.get("/Pacientes/" + item.pacienteID).then(res => {
    			$$invalidate(9, paciente = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function reprogramarCita(item) {
    		$$invalidate(10, cita = item);

    		if (fecha == "" || tandaID <= 0) {
    			$$invalidate(7, fecha = moment().format("YYYY-MM-DD"));
    			$$invalidate(8, tandaID = 1);
    		}

    		buscarDisponibilidadHorario();
    	}

    	function guardarPaciente() {
    		if (paciente.aseguradoraID > 0) {
    			$$invalidate(9, paciente.nombreAseguradora = aseguradoras.find(e => e.id == paciente.aseguradoraID).nombre, paciente);
    		}

    		$axios.put("/Pacientes/" + paciente.id, paciente).then(res => {
    			if (res.data.success) {
    				sweetalert2_all.fire({
    					title: "Actualizado",
    					text: "Paciente actualizado con exito",
    					icon: "success"
    				});

    				jQuery("#modalPaciente").modal("hide");
    			} else {
    				console.log(res);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function guardarEnviarPaciente() {
    		if (paciente.aseguradoraID > 0) {
    			$$invalidate(9, paciente.nombreAseguradora = aseguradoras.find(e => e.id == paciente.aseguradoraID).nombre, paciente);
    		}

    		$axios.put("/Pacientes/" + paciente.id, paciente).then(res => {
    			if (res.data.success) {
    				$$invalidate(6, pacienteEnviado = paciente.id);

    				$toast(5000).fire({
    					icon: "success",
    					title: "Se ha enviado correctamente"
    				});

    				jQuery("#modalPaciente").modal("hide");
    			} else {
    				console.log(res);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cambiarFechaCita(hora) {
    		$$invalidate(10, cita.fecha = fecha + "T" + hora, cita);
    		$$invalidate(10, cita.estadoID = 1, cita);

    		$axios.put("/Citas/" + cita.id, cita).then(res => {
    			if (res.data.success) {
    				$toast(5000).fire({
    					icon: "success",
    					title: "Cambio de cita realizado con exito"
    				});

    				jQuery("#modalCrearCita").modal("hide");
    				cargarCitas();
    			} else {
    				console.log(res);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cambiarEstadoCita(item) {
    		item.estadoID = 2;

    		$axios.put("/Citas/" + item.id, item).then(res => {
    			if (res.data.success) {
    				cargarCitas();
    				$connection.invoke("EnviarPaciente", item.medicoID, item.pacienteID, "encolar").catch(err => console.error(err));
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function anularCita() {
    		sweetalert2_all.fire({
    			title: "Estas seguro que deseas anular la cita?",
    			text: "Este cambio no se puede deshacer!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			cancelButtonText: "No",
    			confirmButtonText: "Si"
    		}).then(result => {
    			if (result.isConfirmed) {
    				$$invalidate(10, cita.inactivo = true, cita);
    				$$invalidate(10, cita.estadoID = 4, cita);

    				$axios.put("/Citas/" + cita.id, cita).then(res => {
    					if (res.data.success) {
    						$toast(5000).fire({
    							title: "Cita anulada con exito",
    							icon: "success"
    						});

    						cargarCitas();
    						jQuery("#modalCrearCita").modal("hide");
    					}
    				}).catch(err => {
    					console.error(err);
    					$errorConexion();
    				});
    			}
    		});
    	}

    	function irACita(time) {
    		set_store_value(dataCita, $dataCita = {
    			fechaCita: fecha,
    			tandaID,
    			hora: time,
    			medicoId: idMedico,
    			pacienteId: cita.pacienteID
    		});

    		push("/Cita/Crear");
    	}

    	function cargarPacienteEnviado() {
    		$axios.get("/Medicos/" + idMedico + "/PacientePendiente").then(res => {
    			$$invalidate(6, pacienteEnviado = res.data.data || "");
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function enviarPaciente() {
    		$axios.post("/Medicos/" + cita.medicoID + "/AsignarPaciente?pacienteId=" + cita.pacienteID).then(res => {
    			if (!res.data.errors) {
    				$connection.invoke("EnviarPaciente", cita.medicoID, cita.pacienteID, "asignar").catch(err => console.error(err));
    				guardarEnviarPaciente();
    			} else {
    				$toast(5000).fire({
    					icon: "error",
    					title: "Error de conexion"
    				});
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Index", $$slots, []);

    	function input0_input_handler() {
    		busqueda = this.value;
    		$$invalidate(0, busqueda);
    	}

    	const click_handler = i => cargarDatosPaciente(i);
    	const click_handler_1 = i => cargarDatosPaciente(i);
    	const click_handler_2 = i => reprogramarCita(i);
    	const click_handler_3 = i => cambiarEstadoCita(i);
    	const click_handler_4 = i => cargarDatosPaciente(i);
    	const click_handler_5 = i => reprogramarCita(i);

    	function input2_input_handler() {
    		paciente.nombre = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input3_input_handler() {
    		paciente.apellidos = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input4_input_handler() {
    		paciente.cedula = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input5_input_handler() {
    		paciente.telefono = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input6_input_handler() {
    		paciente.correo = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function select1_change_handler() {
    		paciente.aseguradoraID = select_value(this);
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input7_input_handler() {
    		paciente.noAfiliado = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function select2_change_handler() {
    		paciente.nacionalidad = select_value(this);
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function select3_change_handler() {
    		paciente.provinciaID = select_value(this);
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function textarea0_input_handler() {
    		paciente.direccion = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function textarea1_input_handler() {
    		paciente.observaciones = this.value;
    		$$invalidate(9, paciente);
    		$$invalidate(12, aseguradoras);
    	}

    	function input8_input_handler() {
    		fecha = this.value;
    		$$invalidate(7, fecha);
    	}

    	function select4_change_handler() {
    		tandaID = select_value(this);
    		$$invalidate(8, tandaID);
    	}

    	function input9_input_handler() {
    		fecha = this.value;
    		$$invalidate(7, fecha);
    	}

    	function select5_change_handler() {
    		tandaID = select_value(this);
    		$$invalidate(8, tandaID);
    	}

    	const click_handler_6 = i => irACita(i.time);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		UserManager,
    		push,
    		session,
    		activePage,
    		host,
    		dataCita,
    		connection,
    		axios: axios$2,
    		errorConexion,
    		toast,
    		onMount,
    		moment,
    		Swal: sweetalert2_all,
    		user,
    		busqueda,
    		medicos,
    		citasPendientes,
    		citasEnTurno,
    		citasRealizadas,
    		horasDisponibles,
    		provincias,
    		aseguradoras,
    		idMedico,
    		pacienteEnviado,
    		userNameMedico,
    		fecha,
    		tandaID,
    		paciente,
    		cita,
    		cargarMedicos,
    		cargarCitas,
    		cargarCitasRealizadas,
    		buscarDisponibilidadHorario,
    		cargarDatosPaciente,
    		reprogramarCita,
    		guardarPaciente,
    		guardarEnviarPaciente,
    		cambiarFechaCita,
    		cambiarEstadoCita,
    		anularCita,
    		irACita,
    		cargarPacienteEnviado,
    		enviarPaciente,
    		$session,
    		$axios,
    		$activePage,
    		$connection,
    		$errorConexion,
    		$toast,
    		$dataCita
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) user = $$props.user;
    		if ("busqueda" in $$props) $$invalidate(0, busqueda = $$props.busqueda);
    		if ("medicos" in $$props) $$invalidate(1, medicos = $$props.medicos);
    		if ("citasPendientes" in $$props) $$invalidate(2, citasPendientes = $$props.citasPendientes);
    		if ("citasEnTurno" in $$props) $$invalidate(3, citasEnTurno = $$props.citasEnTurno);
    		if ("citasRealizadas" in $$props) $$invalidate(4, citasRealizadas = $$props.citasRealizadas);
    		if ("horasDisponibles" in $$props) $$invalidate(5, horasDisponibles = $$props.horasDisponibles);
    		if ("provincias" in $$props) $$invalidate(11, provincias = $$props.provincias);
    		if ("aseguradoras" in $$props) $$invalidate(12, aseguradoras = $$props.aseguradoras);
    		if ("idMedico" in $$props) idMedico = $$props.idMedico;
    		if ("pacienteEnviado" in $$props) $$invalidate(6, pacienteEnviado = $$props.pacienteEnviado);
    		if ("userNameMedico" in $$props) userNameMedico = $$props.userNameMedico;
    		if ("fecha" in $$props) $$invalidate(7, fecha = $$props.fecha);
    		if ("tandaID" in $$props) $$invalidate(8, tandaID = $$props.tandaID);
    		if ("paciente" in $$props) $$invalidate(9, paciente = $$props.paciente);
    		if ("cita" in $$props) $$invalidate(10, cita = $$props.cita);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		busqueda,
    		medicos,
    		citasPendientes,
    		citasEnTurno,
    		citasRealizadas,
    		horasDisponibles,
    		pacienteEnviado,
    		fecha,
    		tandaID,
    		paciente,
    		cita,
    		provincias,
    		aseguradoras,
    		buscarDisponibilidadHorario,
    		cargarDatosPaciente,
    		reprogramarCita,
    		guardarPaciente,
    		cambiarFechaCita,
    		cambiarEstadoCita,
    		anularCita,
    		irACita,
    		enviarPaciente,
    		user,
    		idMedico,
    		userNameMedico,
    		$session,
    		$axios,
    		$activePage,
    		$connection,
    		$errorConexion,
    		$toast,
    		$dataCita,
    		cargarMedicos,
    		cargarCitas,
    		cargarCitasRealizadas,
    		guardarEnviarPaciente,
    		cargarPacienteEnviado,
    		input0_input_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		select1_change_handler,
    		input7_input_handler,
    		select2_change_handler,
    		select3_change_handler,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		input8_input_handler,
    		select4_change_handler,
    		input9_input_handler,
    		select5_change_handler,
    		click_handler_6
    	];
    }

    class Index$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {}, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\Pages\Asistente\CitasProgramadas.svelte generated by Svelte v3.23.0 */

    const { console: console_1$3 } = globals;
    const file$5 = "src\\Pages\\Asistente\\CitasProgramadas.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[50] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[50] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[55] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[55] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[50] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[55] = list[i];
    	return child_ctx;
    }

    function get_each_context_6$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[55] = list[i];
    	return child_ctx;
    }

    // (271:14) {#each medicos as item}
    function create_each_block_6$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[55].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[55].id;
    			option.value = option.__value;
    			add_location(option, file$5, 271, 16, 6631);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*medicos*/ 4 && t_value !== (t_value = /*item*/ ctx[55].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*medicos*/ 4 && option_value_value !== (option_value_value = /*item*/ ctx[55].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6$1.name,
    		type: "each",
    		source: "(271:14) {#each medicos as item}",
    		ctx
    	});

    	return block;
    }

    // (287:22) {#each estados as item}
    function create_each_block_5$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[55].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[55].id;
    			option.value = option.__value;
    			add_location(option, file$5, 287, 24, 7500);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*estados*/ 8 && t_value !== (t_value = /*item*/ ctx[55].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*estados*/ 8 && option_value_value !== (option_value_value = /*item*/ ctx[55].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$1.name,
    		type: "each",
    		source: "(287:22) {#each estados as item}",
    		ctx
    	});

    	return block;
    }

    // (309:16) {#if citasPendientes.length > 0}
    function create_if_block_2$1(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t6;
    	let tbody;
    	let each_value_4 = /*citasPendientes*/ ctx[1];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Nombre";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Estado";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Fecha";
    			t5 = space();
    			th3 = element("th");
    			t6 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$5, 312, 24, 8612);
    			add_location(th1, file$5, 313, 24, 8653);
    			add_location(th2, file$5, 314, 24, 8694);
    			add_location(th3, file$5, 315, 24, 8734);
    			add_location(tr, file$5, 311, 22, 8582);
    			add_location(thead, file$5, 310, 20, 8551);
    			add_location(tbody, file$5, 318, 20, 8821);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$5, 309, 18, 8481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t6);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*citasPendientes, reprogramarCita, idMedico, cargarDatosPaciente*/ 20498) {
    				each_value_4 = /*citasPendientes*/ ctx[1];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(309:16) {#if citasPendientes.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (337:28) {#if idMedico != ""}
    function create_if_block_3$1(ctx) {
    	let button;
    	let i;
    	let t0;

    	let t1_value = (/*i*/ ctx[50].codigoEstado == "r"
    	? "Crear cita"
    	: "Reprogramar") + "";

    	let t1;
    	let button_data_target_value;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[33](/*i*/ ctx[50], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(i, "class", "mdi mdi-calendar-remove");
    			add_location(i, file$5, 342, 30, 10173);
    			attr_dev(button, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button, "data-toggle", "modal");

    			attr_dev(button, "data-target", button_data_target_value = /*i*/ ctx[50].codigoEstado == "r"
    			? "#modalNuevaCita"
    			: "#modalCrearCita");

    			add_location(button, file$5, 337, 28, 9841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*citasPendientes*/ 2 && t1_value !== (t1_value = (/*i*/ ctx[50].codigoEstado == "r"
    			? "Crear cita"
    			: "Reprogramar") + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*citasPendientes*/ 2 && button_data_target_value !== (button_data_target_value = /*i*/ ctx[50].codigoEstado == "r"
    			? "#modalNuevaCita"
    			: "#modalCrearCita")) {
    				attr_dev(button, "data-target", button_data_target_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(337:28) {#if idMedico != \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    // (320:22) {#each citasPendientes as i}
    function create_each_block_4$1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*i*/ ctx[50].nombrePaciente + "";
    	let t0;
    	let t1;
    	let td1;
    	let span;
    	let t2_value = /*i*/ ctx[50].nombreEstado + "";
    	let t2;
    	let span_class_value;
    	let t3;
    	let td2;
    	let t4_value = moment(/*i*/ ctx[50].fecha).format("LLL") + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6;
    	let td4;
    	let button;
    	let i;
    	let t7;
    	let t8;
    	let t9;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[32](/*i*/ ctx[50], ...args);
    	}

    	let if_block = /*idMedico*/ ctx[4] != "" && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = space();
    			td4 = element("td");
    			button = element("button");
    			i = element("i");
    			t7 = text("\r\n                              Ver paciente");
    			t8 = space();
    			if (if_block) if_block.c();
    			t9 = space();
    			add_location(td0, file$5, 321, 26, 8959);
    			attr_dev(span, "class", span_class_value = "badge " + colorEstado(/*i*/ ctx[50].codigoEstado) + " svelte-178y1a3");
    			add_location(span, file$5, 323, 28, 9048);
    			add_location(td1, file$5, 322, 26, 9014);
    			add_location(td2, file$5, 325, 26, 9182);
    			add_location(td3, file$5, 326, 26, 9250);
    			attr_dev(i, "class", "mdi mdi-account-search-outline");
    			add_location(i, file$5, 333, 30, 9634);
    			attr_dev(button, "class", "btn btn-success btn-sm mb-1");
    			attr_dev(button, "data-toggle", "modal");
    			attr_dev(button, "data-target", "#modalPaciente");
    			add_location(button, file$5, 328, 28, 9345);
    			set_style(td4, "text-align", "right");
    			add_location(td4, file$5, 327, 26, 9284);
    			attr_dev(tr, "class", "cursor-table");
    			add_location(tr, file$5, 320, 24, 8906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, span);
    			append_dev(span, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, button);
    			append_dev(button, i);
    			append_dev(button, t7);
    			append_dev(td4, t8);
    			if (if_block) if_block.m(td4, null);
    			append_dev(tr, t9);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*citasPendientes*/ 2 && t0_value !== (t0_value = /*i*/ ctx[50].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citasPendientes*/ 2 && t2_value !== (t2_value = /*i*/ ctx[50].nombreEstado + "")) set_data_dev(t2, t2_value);

    			if (dirty[0] & /*citasPendientes*/ 2 && span_class_value !== (span_class_value = "badge " + colorEstado(/*i*/ ctx[50].codigoEstado) + " svelte-178y1a3")) {
    				attr_dev(span, "class", span_class_value);
    			}

    			if (dirty[0] & /*citasPendientes*/ 2 && t4_value !== (t4_value = moment(/*i*/ ctx[50].fecha).format("LLL") + "")) set_data_dev(t4, t4_value);

    			if (/*idMedico*/ ctx[4] != "") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(td4, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(320:22) {#each citasPendientes as i}",
    		ctx
    	});

    	return block;
    }

    // (454:16) {#each aseguradoras as item}
    function create_each_block_3$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[55].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[55].id;
    			option.value = option.__value;
    			add_location(option, file$5, 454, 18, 13834);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(454:16) {#each aseguradoras as item}",
    		ctx
    	});

    	return block;
    }

    // (489:16) {#each provincias as item}
    function create_each_block_2$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[55].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[55].id;
    			option.value = option.__value;
    			add_location(option, file$5, 489, 18, 15275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(489:16) {#each provincias as item}",
    		ctx
    	});

    	return block;
    }

    // (585:10) {#if horasDisponibles.length <= 0}
    function create_if_block_1$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad en este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$5, 585, 12, 18341);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(585:10) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (590:10) {#each horasDisponibles as i}
    function create_each_block_1$1(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*i*/ ctx[50].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Seleccionar";
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$5, 593, 16, 18665);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$5, 592, 14, 18633);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$5, 596, 16, 18774);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$5, 595, 14, 18735);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$5, 590, 12, 18532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*cambiarFechaCita*/ ctx[16](/*i*/ ctx[50].time))) /*cambiarFechaCita*/ ctx[16](/*i*/ ctx[50].time).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 1 && t0_value !== (t0_value = /*i*/ ctx[50].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(590:10) {#each horasDisponibles as i}",
    		ctx
    	});

    	return block;
    }

    // (663:10) {#if horasDisponibles.length <= 0}
    function create_if_block$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad en este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$5, 663, 12, 20905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(663:10) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (668:10) {#each horasDisponibles as i}
    function create_each_block$1(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*i*/ ctx[50].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[49](/*i*/ ctx[50], ...args);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Seleccionar";
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$5, 671, 16, 21229);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$5, 670, 14, 21197);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$5, 674, 16, 21338);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$5, 673, 14, 21299);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$5, 668, 12, 21096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 1 && t0_value !== (t0_value = /*i*/ ctx[50].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(668:10) {#each horasDisponibles as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div14;
    	let div13;
    	let div12;
    	let div0;
    	let input0;
    	let t2;
    	let div1;
    	let select0;
    	let option0;
    	let option0_value_value;
    	let option1;
    	let option1_value_value;
    	let t5;
    	let div2;
    	let button0;
    	let t7;
    	let div8;
    	let div7;
    	let div6;
    	let div3;
    	let label0;
    	let t9;
    	let select1;
    	let option2;
    	let option3;
    	let option3_value_value;
    	let t12;
    	let div4;
    	let label1;
    	let t14;
    	let input1;
    	let t15;
    	let div5;
    	let label2;
    	let t17;
    	let input2;
    	let t18;
    	let div11;
    	let div10;
    	let h4;
    	let t20;
    	let div9;
    	let t21;
    	let form;
    	let div42;
    	let div41;
    	let div40;
    	let div15;
    	let h50;
    	let i0;
    	let t22;
    	let t23;
    	let button1;
    	let span0;
    	let t25;
    	let div38;
    	let input3;
    	let t26;
    	let div17;
    	let div16;
    	let label3;
    	let t28;
    	let input4;
    	let t29;
    	let div19;
    	let div18;
    	let label4;
    	let t31;
    	let input5;
    	let t32;
    	let div21;
    	let div20;
    	let label5;
    	let t34;
    	let input6;
    	let t35;
    	let div23;
    	let div22;
    	let label6;
    	let t37;
    	let input7;
    	let t38;
    	let div25;
    	let div24;
    	let label7;
    	let t40;
    	let input8;
    	let t41;
    	let div27;
    	let div26;
    	let label8;
    	let t43;
    	let select2;
    	let option4;
    	let t45;
    	let div29;
    	let div28;
    	let label9;
    	let t47;
    	let input9;
    	let t48;
    	let div31;
    	let div30;
    	let label10;
    	let t50;
    	let select3;
    	let option5;
    	let option6;
    	let option6_value_value;
    	let option7;
    	let option7_value_value;
    	let option8;
    	let option8_value_value;
    	let t55;
    	let div33;
    	let div32;
    	let label11;
    	let t57;
    	let select4;
    	let option9;
    	let t59;
    	let div35;
    	let div34;
    	let label12;
    	let t61;
    	let textarea0;
    	let t62;
    	let div37;
    	let div36;
    	let label13;
    	let t64;
    	let textarea1;
    	let t65;
    	let br;
    	let t66;
    	let div39;
    	let button2;
    	let t68;
    	let button3;
    	let t69;
    	let i1;
    	let t70;
    	let div53;
    	let div52;
    	let div51;
    	let div43;
    	let h51;
    	let i2;
    	let t71;
    	let t72;
    	let button4;
    	let span1;
    	let t74;
    	let div50;
    	let div48;
    	let div45;
    	let div44;
    	let label14;
    	let t76;
    	let input10;
    	let t77;
    	let div47;
    	let div46;
    	let label15;
    	let t79;
    	let select5;
    	let option10;
    	let option10_value_value;
    	let option11;
    	let option11_value_value;
    	let option12;
    	let option12_value_value;
    	let t83;
    	let div49;
    	let t84;
    	let t85;
    	let div64;
    	let div63;
    	let div62;
    	let div54;
    	let h52;
    	let i3;
    	let t86;
    	let t87;
    	let button5;
    	let span2;
    	let t89;
    	let div61;
    	let div59;
    	let div56;
    	let div55;
    	let label16;
    	let t91;
    	let input11;
    	let t92;
    	let div58;
    	let div57;
    	let label17;
    	let t94;
    	let select6;
    	let option13;
    	let option13_value_value;
    	let option14;
    	let option14_value_value;
    	let option15;
    	let option15_value_value;
    	let t98;
    	let div60;
    	let t99;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_6 = /*medicos*/ ctx[2];
    	validate_each_argument(each_value_6);
    	let each_blocks_5 = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks_5[i] = create_each_block_6$1(get_each_context_6$1(ctx, each_value_6, i));
    	}

    	let each_value_5 = /*estados*/ ctx[3];
    	validate_each_argument(each_value_5);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_4[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
    	}

    	let if_block0 = /*citasPendientes*/ ctx[1].length > 0 && create_if_block_2$1(ctx);
    	let each_value_3 = /*aseguradoras*/ ctx[10];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*provincias*/ ctx[9];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let if_block1 = /*horasDisponibles*/ ctx[0].length <= 0 && create_if_block_1$2(ctx);
    	let each_value_1 = /*horasDisponibles*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let if_block2 = /*horasDisponibles*/ ctx[0].length <= 0 && create_if_block$3(ctx);
    	let each_value = /*horasDisponibles*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Seleccionar medico -";
    			option1 = element("option");
    			option1.textContent = "Todos";

    			for (let i = 0; i < each_blocks_5.length; i += 1) {
    				each_blocks_5[i].c();
    			}

    			t5 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Filtros";
    			t7 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Estados";
    			t9 = space();
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "- Buscar por estado -";
    			option3 = element("option");
    			option3.textContent = "Todos";

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t12 = space();
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Desde";
    			t14 = space();
    			input1 = element("input");
    			t15 = space();
    			div5 = element("div");
    			label2 = element("label");
    			label2.textContent = "Hasta";
    			t17 = space();
    			input2 = element("input");
    			t18 = space();
    			div11 = element("div");
    			div10 = element("div");
    			h4 = element("h4");
    			h4.textContent = "No hay cita";
    			t20 = space();
    			div9 = element("div");
    			if (if_block0) if_block0.c();
    			t21 = space();
    			form = element("form");
    			div42 = element("div");
    			div41 = element("div");
    			div40 = element("div");
    			div15 = element("div");
    			h50 = element("h5");
    			i0 = element("i");
    			t22 = text("\r\n          Paciente");
    			t23 = space();
    			button1 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t25 = space();
    			div38 = element("div");
    			input3 = element("input");
    			t26 = space();
    			div17 = element("div");
    			div16 = element("div");
    			label3 = element("label");
    			label3.textContent = "Nombre";
    			t28 = space();
    			input4 = element("input");
    			t29 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label4 = element("label");
    			label4.textContent = "Apellido";
    			t31 = space();
    			input5 = element("input");
    			t32 = space();
    			div21 = element("div");
    			div20 = element("div");
    			label5 = element("label");
    			label5.textContent = "Cedula";
    			t34 = space();
    			input6 = element("input");
    			t35 = space();
    			div23 = element("div");
    			div22 = element("div");
    			label6 = element("label");
    			label6.textContent = "Telefono";
    			t37 = space();
    			input7 = element("input");
    			t38 = space();
    			div25 = element("div");
    			div24 = element("div");
    			label7 = element("label");
    			label7.textContent = "Correo electronico";
    			t40 = space();
    			input8 = element("input");
    			t41 = space();
    			div27 = element("div");
    			div26 = element("div");
    			label8 = element("label");
    			label8.textContent = "Aseguradora";
    			t43 = space();
    			select2 = element("select");
    			option4 = element("option");
    			option4.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t45 = space();
    			div29 = element("div");
    			div28 = element("div");
    			label9 = element("label");
    			label9.textContent = "No. Seguro";
    			t47 = space();
    			input9 = element("input");
    			t48 = space();
    			div31 = element("div");
    			div30 = element("div");
    			label10 = element("label");
    			label10.textContent = "Pais";
    			t50 = space();
    			select3 = element("select");
    			option5 = element("option");
    			option5.textContent = "- Seleccionar -";
    			option6 = element("option");
    			option6.textContent = "Rep. Dom.";
    			option7 = element("option");
    			option7.textContent = "Haiti";
    			option8 = element("option");
    			option8.textContent = "Venezuela";
    			t55 = space();
    			div33 = element("div");
    			div32 = element("div");
    			label11 = element("label");
    			label11.textContent = "Provincia";
    			t57 = space();
    			select4 = element("select");
    			option9 = element("option");
    			option9.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t59 = space();
    			div35 = element("div");
    			div34 = element("div");
    			label12 = element("label");
    			label12.textContent = "Direccion";
    			t61 = space();
    			textarea0 = element("textarea");
    			t62 = space();
    			div37 = element("div");
    			div36 = element("div");
    			label13 = element("label");
    			label13.textContent = "Observaciones";
    			t64 = space();
    			textarea1 = element("textarea");
    			t65 = space();
    			br = element("br");
    			t66 = space();
    			div39 = element("div");
    			button2 = element("button");
    			button2.textContent = "Cerrar";
    			t68 = space();
    			button3 = element("button");
    			t69 = text("Guardar\r\n            ");
    			i1 = element("i");
    			t70 = space();
    			div53 = element("div");
    			div52 = element("div");
    			div51 = element("div");
    			div43 = element("div");
    			h51 = element("h5");
    			i2 = element("i");
    			t71 = text("\r\n          Reprogramacion de cita");
    			t72 = space();
    			button4 = element("button");
    			span1 = element("span");
    			span1.textContent = "×";
    			t74 = space();
    			div50 = element("div");
    			div48 = element("div");
    			div45 = element("div");
    			div44 = element("div");
    			label14 = element("label");
    			label14.textContent = "Fecha";
    			t76 = space();
    			input10 = element("input");
    			t77 = space();
    			div47 = element("div");
    			div46 = element("div");
    			label15 = element("label");
    			label15.textContent = "Tanda";
    			t79 = space();
    			select5 = element("select");
    			option10 = element("option");
    			option10.textContent = "- Seleccionar -";
    			option11 = element("option");
    			option11.textContent = "Matutina";
    			option12 = element("option");
    			option12.textContent = "Vespertina";
    			t83 = space();
    			div49 = element("div");
    			if (if_block1) if_block1.c();
    			t84 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t85 = space();
    			div64 = element("div");
    			div63 = element("div");
    			div62 = element("div");
    			div54 = element("div");
    			h52 = element("h5");
    			i3 = element("i");
    			t86 = text("\r\n          Creacion de cita");
    			t87 = space();
    			button5 = element("button");
    			span2 = element("span");
    			span2.textContent = "×";
    			t89 = space();
    			div61 = element("div");
    			div59 = element("div");
    			div56 = element("div");
    			div55 = element("div");
    			label16 = element("label");
    			label16.textContent = "Fecha";
    			t91 = space();
    			input11 = element("input");
    			t92 = space();
    			div58 = element("div");
    			div57 = element("div");
    			label17 = element("label");
    			label17.textContent = "Tanda";
    			t94 = space();
    			select6 = element("select");
    			option13 = element("option");
    			option13.textContent = "- Seleccionar -";
    			option14 = element("option");
    			option14.textContent = "Matutina";
    			option15 = element("option");
    			option15.textContent = "Vespertina";
    			t98 = space();
    			div60 = element("div");
    			if (if_block2) if_block2.c();
    			t99 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Buscar paciente");
    			add_location(input0, file$5, 263, 12, 6164);
    			attr_dev(div0, "class", "col-lg-6 mt-2");
    			add_location(div0, file$5, 262, 10, 6123);
    			option0.__value = option0_value_value = 0;
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			add_location(option0, file$5, 268, 14, 6458);
    			option1.__value = option1_value_value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$5, 269, 14, 6541);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "id", "sltMedicos");
    			set_style(select0, "width", "100%");
    			add_location(select0, file$5, 267, 12, 6377);
    			attr_dev(div1, "class", "col-lg-4 mt-2");
    			add_location(div1, file$5, 266, 10, 6336);
    			attr_dev(button0, "class", "btn btn-primary");
    			attr_dev(button0, "id", "btnFiltro");
    			set_style(button0, "margin-top", "8px");
    			add_location(button0, file$5, 276, 12, 6787);
    			attr_dev(div2, "class", "col-lg-2");
    			add_location(div2, file$5, 275, 10, 6751);
    			add_location(label0, file$5, 282, 20, 7156);
    			option2.__value = "";
    			option2.value = option2.__value;
    			option2.disabled = true;
    			option2.selected = true;
    			add_location(option2, file$5, 284, 22, 7306);
    			option3.__value = option3_value_value = 0;
    			option3.value = option3.__value;
    			add_location(option3, file$5, 285, 22, 7395);
    			attr_dev(select1, "class", "form-control");
    			if (/*filter*/ ctx[8].estadoID === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[29].call(select1));
    			add_location(select1, file$5, 283, 20, 7200);
    			attr_dev(div3, "class", "col-lg-6 col-md-6");
    			add_location(div3, file$5, 281, 18, 7103);
    			add_location(label1, file$5, 292, 20, 7707);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$5, 293, 20, 7749);
    			attr_dev(div4, "class", "col-lg-3 col-md-3");
    			add_location(div4, file$5, 291, 18, 7654);
    			add_location(label2, file$5, 296, 20, 7943);
    			attr_dev(input2, "type", "date");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$5, 297, 20, 7985);
    			attr_dev(div5, "class", "col-lg-3 col-md-3");
    			add_location(div5, file$5, 295, 18, 7890);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$5, 280, 16, 7066);
    			attr_dev(div7, "class", "alert alert-secondary");
    			add_location(div7, file$5, 279, 14, 7013);
    			attr_dev(div8, "id", "filtroAvanzado");
    			attr_dev(div8, "class", "col-lg-12 mt-2");
    			set_style(div8, "display", "none");
    			add_location(div8, file$5, 278, 10, 6926);
    			toggle_class(h4, "d-none", /*citasPendientes*/ ctx[1].length > 0);
    			add_location(h4, file$5, 306, 14, 8303);
    			attr_dev(div9, "class", "table-responsive");
    			add_location(div9, file$5, 307, 14, 8381);
    			attr_dev(div10, "class", "alert alert-primary");
    			attr_dev(div10, "role", "alert");
    			add_location(div10, file$5, 304, 12, 8223);
    			attr_dev(div11, "class", "col-md-12 mt-2");
    			add_location(div11, file$5, 303, 10, 8181);
    			attr_dev(div12, "class", "row");
    			add_location(div12, file$5, 260, 8, 6092);
    			attr_dev(div13, "class", "col-md-12");
    			add_location(div13, file$5, 259, 6, 6059);
    			attr_dev(div14, "class", "container mt-3");
    			add_location(div14, file$5, 258, 4, 6023);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$5, 257, 2, 5986);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$5, 255, 0, 5943);
    			attr_dev(i0, "class", "mdi mdi-account-search-outline");
    			add_location(i0, file$5, 375, 10, 11137);
    			attr_dev(h50, "class", "modal-title");
    			attr_dev(h50, "id", "modalPacienteLabel");
    			add_location(h50, file$5, 374, 8, 11077);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$5, 383, 10, 11358);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "close");
    			attr_dev(button1, "data-dismiss", "modal");
    			attr_dev(button1, "aria-label", "Close");
    			add_location(button1, file$5, 378, 8, 11226);
    			attr_dev(div15, "class", "modal-header");
    			add_location(div15, file$5, 373, 6, 11041);
    			attr_dev(input3, "type", "hidden");
    			attr_dev(input3, "name", "IdUser");
    			input3.value = "0";
    			add_location(input3, file$5, 387, 10, 11468);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$5, 390, 14, 11613);
    			attr_dev(input4, "type", "name");
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "name", "Name");
    			attr_dev(input4, "maxlength", "200");
    			input4.required = true;
    			add_location(input4, file$5, 391, 14, 11657);
    			attr_dev(div16, "class", "form-group col-md-12");
    			add_location(div16, file$5, 389, 12, 11563);
    			attr_dev(div17, "class", "form-row");
    			add_location(div17, file$5, 388, 10, 11527);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$5, 402, 14, 12003);
    			attr_dev(input5, "type", "name");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "name", "Name");
    			attr_dev(input5, "maxlength", "200");
    			input5.required = true;
    			add_location(input5, file$5, 403, 14, 12049);
    			attr_dev(div18, "class", "form-group col-md-12");
    			add_location(div18, file$5, 401, 12, 11953);
    			attr_dev(div19, "class", "form-row");
    			add_location(div19, file$5, 400, 10, 11917);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$5, 414, 14, 12398);
    			attr_dev(input6, "type", "name");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "name", "Name");
    			attr_dev(input6, "maxlength", "200");
    			add_location(input6, file$5, 415, 14, 12442);
    			attr_dev(div20, "class", "form-group col-md-12");
    			add_location(div20, file$5, 413, 12, 12348);
    			attr_dev(div21, "class", "form-row");
    			add_location(div21, file$5, 412, 10, 12312);
    			attr_dev(label6, "for", "");
    			add_location(label6, file$5, 425, 14, 12762);
    			attr_dev(input7, "type", "tel");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "name", "Name");
    			attr_dev(input7, "maxlength", "200");
    			input7.required = true;
    			add_location(input7, file$5, 426, 14, 12808);
    			attr_dev(div22, "class", "form-group col-md-12");
    			add_location(div22, file$5, 424, 12, 12712);
    			attr_dev(div23, "class", "form-row");
    			add_location(div23, file$5, 423, 10, 12676);
    			attr_dev(label7, "for", "");
    			add_location(label7, file$5, 437, 14, 13155);
    			attr_dev(input8, "type", "email");
    			attr_dev(input8, "class", "form-control");
    			attr_dev(input8, "name", "Name");
    			attr_dev(input8, "maxlength", "200");
    			add_location(input8, file$5, 438, 14, 13211);
    			attr_dev(div24, "class", "form-group col-md-12");
    			add_location(div24, file$5, 436, 12, 13105);
    			attr_dev(div25, "class", "form-row");
    			add_location(div25, file$5, 435, 10, 13069);
    			attr_dev(label8, "for", "");
    			add_location(label8, file$5, 448, 14, 13531);
    			option4.__value = "0";
    			option4.value = option4.__value;
    			option4.disabled = true;
    			option4.selected = true;
    			add_location(option4, file$5, 452, 16, 13708);
    			attr_dev(select2, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[7].aseguradoraID === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[39].call(select2));
    			add_location(select2, file$5, 449, 14, 13580);
    			attr_dev(div26, "class", "form-group col-md-12");
    			add_location(div26, file$5, 447, 12, 13481);
    			attr_dev(div27, "class", "form-row");
    			add_location(div27, file$5, 446, 10, 13445);
    			attr_dev(label9, "for", "");
    			add_location(label9, file$5, 461, 14, 14066);
    			attr_dev(input9, "type", "text");
    			attr_dev(input9, "class", "form-control");
    			attr_dev(input9, "name", "Name");
    			attr_dev(input9, "maxlength", "200");
    			add_location(input9, file$5, 462, 14, 14114);
    			attr_dev(div28, "class", "form-group col-md-12");
    			add_location(div28, file$5, 460, 12, 14016);
    			attr_dev(div29, "class", "form-row");
    			add_location(div29, file$5, 459, 10, 13980);
    			attr_dev(label10, "for", "");
    			add_location(label10, file$5, 472, 14, 14438);
    			option5.__value = "0";
    			option5.value = option5.__value;
    			option5.disabled = true;
    			option5.selected = true;
    			add_location(option5, file$5, 474, 16, 14573);
    			option6.__value = option6_value_value = "Rep. Dom.";
    			option6.value = option6.__value;
    			add_location(option6, file$5, 475, 16, 14651);
    			option7.__value = option7_value_value = "Haiti";
    			option7.value = option7.__value;
    			add_location(option7, file$5, 476, 16, 14715);
    			option8.__value = option8_value_value = "Venezuela";
    			option8.value = option8.__value;
    			add_location(option8, file$5, 477, 16, 14771);
    			attr_dev(select3, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[7].nacionalidad === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[41].call(select3));
    			add_location(select3, file$5, 473, 14, 14480);
    			attr_dev(div30, "class", "form-group col-md-12");
    			add_location(div30, file$5, 471, 12, 14388);
    			attr_dev(div31, "class", "form-row");
    			add_location(div31, file$5, 470, 10, 14352);
    			attr_dev(label11, "for", "");
    			add_location(label11, file$5, 483, 14, 14978);
    			option9.__value = "0";
    			option9.value = option9.__value;
    			option9.disabled = true;
    			option9.selected = true;
    			add_location(option9, file$5, 487, 16, 15151);
    			attr_dev(select4, "class", "form-control js-select2");
    			if (/*paciente*/ ctx[7].provinciaID === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[42].call(select4));
    			add_location(select4, file$5, 484, 14, 15025);
    			attr_dev(div32, "class", "form-group col-md-12");
    			add_location(div32, file$5, 482, 12, 14928);
    			attr_dev(div33, "class", "form-row");
    			add_location(div33, file$5, 481, 10, 14892);
    			attr_dev(label12, "for", "");
    			add_location(label12, file$5, 496, 14, 15507);
    			attr_dev(textarea0, "class", "form-control");
    			attr_dev(textarea0, "rows", "2");
    			add_location(textarea0, file$5, 497, 14, 15554);
    			attr_dev(div34, "class", "form-group col-md-12");
    			add_location(div34, file$5, 495, 12, 15457);
    			attr_dev(div35, "class", "form-row");
    			add_location(div35, file$5, 494, 10, 15421);
    			attr_dev(label13, "for", "");
    			add_location(label13, file$5, 505, 14, 15815);
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "rows", "3");
    			add_location(textarea1, file$5, 506, 14, 15866);
    			attr_dev(div36, "class", "form-group col-md-12");
    			add_location(div36, file$5, 504, 12, 15765);
    			attr_dev(div37, "class", "form-row");
    			add_location(div37, file$5, 503, 10, 15729);
    			add_location(br, file$5, 513, 10, 16047);
    			attr_dev(div38, "class", "modal-body svelte-178y1a3");
    			add_location(div38, file$5, 386, 6, 11432);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn btn-outline-danger");
    			attr_dev(button2, "data-dismiss", "modal");
    			add_location(button2, file$5, 516, 10, 16117);
    			attr_dev(i1, "class", "mdi mdi-content-save-outline");
    			add_location(i1, file$5, 524, 12, 16372);
    			attr_dev(button3, "type", "submit");
    			attr_dev(button3, "class", "btn btn-outline-primary");
    			add_location(button3, file$5, 522, 10, 16283);
    			attr_dev(div39, "class", "modal-footer");
    			add_location(div39, file$5, 515, 8, 16079);
    			attr_dev(div40, "class", "modal-content");
    			add_location(div40, file$5, 372, 4, 11006);
    			attr_dev(div41, "class", "modal-dialog svelte-178y1a3");
    			attr_dev(div41, "role", "document");
    			add_location(div41, file$5, 371, 2, 10958);
    			attr_dev(div42, "class", "modal fade modal-slide-right svelte-178y1a3");
    			attr_dev(div42, "id", "modalPaciente");
    			attr_dev(div42, "tabindex", "-1");
    			attr_dev(div42, "role", "dialog");
    			attr_dev(div42, "aria-labelledby", "modalPacienteLabel");
    			set_style(div42, "display", "none");
    			set_style(div42, "padding-right", "16px");
    			attr_dev(div42, "aria-modal", "true");
    			add_location(div42, file$5, 363, 0, 10745);
    			attr_dev(form, "id", "frmPaciente");
    			add_location(form, file$5, 362, 0, 10677);
    			attr_dev(i2, "class", "mdi mdi-calendar-plus");
    			add_location(i2, file$5, 545, 10, 16905);
    			attr_dev(h51, "class", "modal-title");
    			attr_dev(h51, "id", "modalCrearCitaLabel");
    			add_location(h51, file$5, 544, 8, 16844);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$5, 553, 10, 17131);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "close");
    			attr_dev(button4, "data-dismiss", "modal");
    			attr_dev(button4, "aria-label", "Close");
    			add_location(button4, file$5, 548, 8, 16999);
    			attr_dev(div43, "class", "modal-header");
    			add_location(div43, file$5, 543, 6, 16808);
    			attr_dev(label14, "for", "inputAddress");
    			add_location(label14, file$5, 561, 14, 17392);
    			attr_dev(input10, "type", "date");
    			attr_dev(input10, "class", "form-control form-control-sm");
    			add_location(input10, file$5, 562, 14, 17447);
    			attr_dev(div44, "class", "form-group");
    			add_location(div44, file$5, 560, 12, 17352);
    			attr_dev(div45, "class", "col-lg-6");
    			add_location(div45, file$5, 559, 10, 17316);
    			attr_dev(label15, "class", "font-secondary");
    			add_location(label15, file$5, 571, 14, 17759);
    			option10.__value = option10_value_value = 0;
    			option10.value = option10.__value;
    			option10.disabled = true;
    			add_location(option10, file$5, 576, 16, 18004);
    			option11.__value = option11_value_value = 1;
    			option11.value = option11.__value;
    			add_location(option11, file$5, 577, 16, 18073);
    			option12.__value = option12_value_value = 2;
    			option12.value = option12.__value;
    			add_location(option12, file$5, 578, 16, 18126);
    			attr_dev(select5, "class", "form-control form-control-sm js-select2");
    			if (/*tandaID*/ ctx[6] === void 0) add_render_callback(() => /*select5_change_handler*/ ctx[46].call(select5));
    			add_location(select5, file$5, 572, 14, 17818);
    			attr_dev(div46, "class", "form-group ");
    			add_location(div46, file$5, 570, 12, 17718);
    			attr_dev(div47, "class", "col-lg-6");
    			add_location(div47, file$5, 569, 10, 17682);
    			attr_dev(div48, "class", "row");
    			add_location(div48, file$5, 558, 8, 17287);
    			attr_dev(div49, "class", "list-group list");
    			add_location(div49, file$5, 583, 8, 18252);
    			attr_dev(div50, "class", "modal-body svelte-178y1a3");
    			set_style(div50, "height", "100%");
    			set_style(div50, "top", "0");
    			set_style(div50, "overflow", "auto");
    			add_location(div50, file$5, 556, 6, 17205);
    			attr_dev(div51, "class", "modal-content");
    			add_location(div51, file$5, 542, 4, 16773);
    			attr_dev(div52, "class", "modal-dialog svelte-178y1a3");
    			attr_dev(div52, "role", "document");
    			add_location(div52, file$5, 541, 2, 16725);
    			attr_dev(div53, "class", "modal fade modal-slide-right svelte-178y1a3");
    			attr_dev(div53, "id", "modalCrearCita");
    			attr_dev(div53, "tabindex", "-1");
    			attr_dev(div53, "role", "dialog");
    			attr_dev(div53, "aria-labelledby", "modalCrearCitaLabel");
    			set_style(div53, "display", "none");
    			set_style(div53, "padding-right", "16px");
    			attr_dev(div53, "aria-modal", "true");
    			add_location(div53, file$5, 533, 0, 16510);
    			attr_dev(i3, "class", "mdi mdi-calendar-plus");
    			add_location(i3, file$5, 623, 10, 19475);
    			attr_dev(h52, "class", "modal-title");
    			attr_dev(h52, "id", "modalNuevaCitaLabel");
    			add_location(h52, file$5, 622, 8, 19414);
    			attr_dev(span2, "aria-hidden", "true");
    			add_location(span2, file$5, 631, 10, 19695);
    			attr_dev(button5, "type", "button");
    			attr_dev(button5, "class", "close");
    			attr_dev(button5, "data-dismiss", "modal");
    			attr_dev(button5, "aria-label", "Close");
    			add_location(button5, file$5, 626, 8, 19563);
    			attr_dev(div54, "class", "modal-header");
    			add_location(div54, file$5, 621, 6, 19378);
    			attr_dev(label16, "for", "inputAddress");
    			add_location(label16, file$5, 639, 14, 19956);
    			attr_dev(input11, "type", "date");
    			attr_dev(input11, "class", "form-control form-control-sm");
    			add_location(input11, file$5, 640, 14, 20011);
    			attr_dev(div55, "class", "form-group");
    			add_location(div55, file$5, 638, 12, 19916);
    			attr_dev(div56, "class", "col-lg-6");
    			add_location(div56, file$5, 637, 10, 19880);
    			attr_dev(label17, "class", "font-secondary");
    			add_location(label17, file$5, 649, 14, 20323);
    			option13.__value = option13_value_value = 0;
    			option13.value = option13.__value;
    			option13.disabled = true;
    			add_location(option13, file$5, 654, 16, 20568);
    			option14.__value = option14_value_value = 1;
    			option14.value = option14.__value;
    			add_location(option14, file$5, 655, 16, 20637);
    			option15.__value = option15_value_value = 2;
    			option15.value = option15.__value;
    			add_location(option15, file$5, 656, 16, 20690);
    			attr_dev(select6, "class", "form-control form-control-sm js-select2");
    			if (/*tandaID*/ ctx[6] === void 0) add_render_callback(() => /*select6_change_handler*/ ctx[48].call(select6));
    			add_location(select6, file$5, 650, 14, 20382);
    			attr_dev(div57, "class", "form-group ");
    			add_location(div57, file$5, 648, 12, 20282);
    			attr_dev(div58, "class", "col-lg-6");
    			add_location(div58, file$5, 647, 10, 20246);
    			attr_dev(div59, "class", "row");
    			add_location(div59, file$5, 636, 8, 19851);
    			attr_dev(div60, "class", "list-group list");
    			add_location(div60, file$5, 661, 8, 20816);
    			attr_dev(div61, "class", "modal-body svelte-178y1a3");
    			set_style(div61, "height", "100%");
    			set_style(div61, "top", "0");
    			set_style(div61, "overflow", "auto");
    			add_location(div61, file$5, 634, 6, 19769);
    			attr_dev(div62, "class", "modal-content");
    			add_location(div62, file$5, 620, 4, 19343);
    			attr_dev(div63, "class", "modal-dialog svelte-178y1a3");
    			attr_dev(div63, "role", "document");
    			add_location(div63, file$5, 619, 2, 19295);
    			attr_dev(div64, "class", "modal fade modal-slide-right svelte-178y1a3");
    			attr_dev(div64, "id", "modalNuevaCita");
    			attr_dev(div64, "tabindex", "-1");
    			attr_dev(div64, "role", "dialog");
    			attr_dev(div64, "aria-labelledby", "modalNuevaCitaLabel");
    			set_style(div64, "display", "none");
    			set_style(div64, "padding-right", "16px");
    			attr_dev(div64, "aria-modal", "true");
    			add_location(div64, file$5, 611, 0, 19080);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*filter*/ ctx[8].nombrePaciente);
    			append_dev(div12, t2);
    			append_dev(div12, div1);
    			append_dev(div1, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);

    			for (let i = 0; i < each_blocks_5.length; i += 1) {
    				each_blocks_5[i].m(select0, null);
    			}

    			append_dev(div12, t5);
    			append_dev(div12, div2);
    			append_dev(div2, button0);
    			append_dev(div12, t7);
    			append_dev(div12, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t9);
    			append_dev(div3, select1);
    			append_dev(select1, option2);
    			append_dev(select1, option3);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(select1, null);
    			}

    			select_option(select1, /*filter*/ ctx[8].estadoID);
    			append_dev(div6, t12);
    			append_dev(div6, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t14);
    			append_dev(div4, input1);
    			set_input_value(input1, /*filter*/ ctx[8].fechaInicio);
    			append_dev(div6, t15);
    			append_dev(div6, div5);
    			append_dev(div5, label2);
    			append_dev(div5, t17);
    			append_dev(div5, input2);
    			set_input_value(input2, /*filter*/ ctx[8].fechaFin);
    			append_dev(div12, t18);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, h4);
    			append_dev(div10, t20);
    			append_dev(div10, div9);
    			if (if_block0) if_block0.m(div9, null);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div42);
    			append_dev(div42, div41);
    			append_dev(div41, div40);
    			append_dev(div40, div15);
    			append_dev(div15, h50);
    			append_dev(h50, i0);
    			append_dev(h50, t22);
    			append_dev(div15, t23);
    			append_dev(div15, button1);
    			append_dev(button1, span0);
    			append_dev(div40, t25);
    			append_dev(div40, div38);
    			append_dev(div38, input3);
    			append_dev(div38, t26);
    			append_dev(div38, div17);
    			append_dev(div17, div16);
    			append_dev(div16, label3);
    			append_dev(div16, t28);
    			append_dev(div16, input4);
    			set_input_value(input4, /*paciente*/ ctx[7].nombre);
    			append_dev(div38, t29);
    			append_dev(div38, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label4);
    			append_dev(div18, t31);
    			append_dev(div18, input5);
    			set_input_value(input5, /*paciente*/ ctx[7].apellidos);
    			append_dev(div38, t32);
    			append_dev(div38, div21);
    			append_dev(div21, div20);
    			append_dev(div20, label5);
    			append_dev(div20, t34);
    			append_dev(div20, input6);
    			set_input_value(input6, /*paciente*/ ctx[7].cedula);
    			append_dev(div38, t35);
    			append_dev(div38, div23);
    			append_dev(div23, div22);
    			append_dev(div22, label6);
    			append_dev(div22, t37);
    			append_dev(div22, input7);
    			set_input_value(input7, /*paciente*/ ctx[7].telefono);
    			append_dev(div38, t38);
    			append_dev(div38, div25);
    			append_dev(div25, div24);
    			append_dev(div24, label7);
    			append_dev(div24, t40);
    			append_dev(div24, input8);
    			set_input_value(input8, /*paciente*/ ctx[7].correo);
    			append_dev(div38, t41);
    			append_dev(div38, div27);
    			append_dev(div27, div26);
    			append_dev(div26, label8);
    			append_dev(div26, t43);
    			append_dev(div26, select2);
    			append_dev(select2, option4);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select2, null);
    			}

    			select_option(select2, /*paciente*/ ctx[7].aseguradoraID);
    			append_dev(div38, t45);
    			append_dev(div38, div29);
    			append_dev(div29, div28);
    			append_dev(div28, label9);
    			append_dev(div28, t47);
    			append_dev(div28, input9);
    			set_input_value(input9, /*paciente*/ ctx[7].noAfiliado);
    			append_dev(div38, t48);
    			append_dev(div38, div31);
    			append_dev(div31, div30);
    			append_dev(div30, label10);
    			append_dev(div30, t50);
    			append_dev(div30, select3);
    			append_dev(select3, option5);
    			append_dev(select3, option6);
    			append_dev(select3, option7);
    			append_dev(select3, option8);
    			select_option(select3, /*paciente*/ ctx[7].nacionalidad);
    			append_dev(div38, t55);
    			append_dev(div38, div33);
    			append_dev(div33, div32);
    			append_dev(div32, label11);
    			append_dev(div32, t57);
    			append_dev(div32, select4);
    			append_dev(select4, option9);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select4, null);
    			}

    			select_option(select4, /*paciente*/ ctx[7].provinciaID);
    			append_dev(div38, t59);
    			append_dev(div38, div35);
    			append_dev(div35, div34);
    			append_dev(div34, label12);
    			append_dev(div34, t61);
    			append_dev(div34, textarea0);
    			set_input_value(textarea0, /*paciente*/ ctx[7].direccion);
    			append_dev(div38, t62);
    			append_dev(div38, div37);
    			append_dev(div37, div36);
    			append_dev(div36, label13);
    			append_dev(div36, t64);
    			append_dev(div36, textarea1);
    			set_input_value(textarea1, /*paciente*/ ctx[7].observaciones);
    			append_dev(div38, t65);
    			append_dev(div38, br);
    			append_dev(div40, t66);
    			append_dev(div40, div39);
    			append_dev(div39, button2);
    			append_dev(div39, t68);
    			append_dev(div39, button3);
    			append_dev(button3, t69);
    			append_dev(button3, i1);
    			insert_dev(target, t70, anchor);
    			insert_dev(target, div53, anchor);
    			append_dev(div53, div52);
    			append_dev(div52, div51);
    			append_dev(div51, div43);
    			append_dev(div43, h51);
    			append_dev(h51, i2);
    			append_dev(h51, t71);
    			append_dev(div43, t72);
    			append_dev(div43, button4);
    			append_dev(button4, span1);
    			append_dev(div51, t74);
    			append_dev(div51, div50);
    			append_dev(div50, div48);
    			append_dev(div48, div45);
    			append_dev(div45, div44);
    			append_dev(div44, label14);
    			append_dev(div44, t76);
    			append_dev(div44, input10);
    			set_input_value(input10, /*fecha*/ ctx[5]);
    			append_dev(div48, t77);
    			append_dev(div48, div47);
    			append_dev(div47, div46);
    			append_dev(div46, label15);
    			append_dev(div46, t79);
    			append_dev(div46, select5);
    			append_dev(select5, option10);
    			append_dev(select5, option11);
    			append_dev(select5, option12);
    			select_option(select5, /*tandaID*/ ctx[6]);
    			append_dev(div50, t83);
    			append_dev(div50, div49);
    			if (if_block1) if_block1.m(div49, null);
    			append_dev(div49, t84);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div49, null);
    			}

    			insert_dev(target, t85, anchor);
    			insert_dev(target, div64, anchor);
    			append_dev(div64, div63);
    			append_dev(div63, div62);
    			append_dev(div62, div54);
    			append_dev(div54, h52);
    			append_dev(h52, i3);
    			append_dev(h52, t86);
    			append_dev(div54, t87);
    			append_dev(div54, button5);
    			append_dev(button5, span2);
    			append_dev(div62, t89);
    			append_dev(div62, div61);
    			append_dev(div61, div59);
    			append_dev(div59, div56);
    			append_dev(div56, div55);
    			append_dev(div55, label16);
    			append_dev(div55, t91);
    			append_dev(div55, input11);
    			set_input_value(input11, /*fecha*/ ctx[5]);
    			append_dev(div59, t92);
    			append_dev(div59, div58);
    			append_dev(div58, div57);
    			append_dev(div57, label17);
    			append_dev(div57, t94);
    			append_dev(div57, select6);
    			append_dev(select6, option13);
    			append_dev(select6, option14);
    			append_dev(select6, option15);
    			select_option(select6, /*tandaID*/ ctx[6]);
    			append_dev(div61, t98);
    			append_dev(div61, div60);
    			if (if_block2) if_block2.m(div60, null);
    			append_dev(div60, t99);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div60, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[28]),
    					listen_dev(input0, "input", /*cargarCitas*/ ctx[11], false, false, false),
    					listen_dev(button0, "click", btnFiltro, false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[29]),
    					listen_dev(select1, "change", /*cargarCitas*/ ctx[11], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[30]),
    					listen_dev(input1, "input", /*cargarCitas*/ ctx[11], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[31]),
    					listen_dev(input2, "input", /*cargarCitas*/ ctx[11], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[34]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[35]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[36]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[37]),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[38]),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[39]),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[40]),
    					listen_dev(select3, "change", /*select3_change_handler*/ ctx[41]),
    					listen_dev(select4, "change", /*select4_change_handler*/ ctx[42]),
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[43]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[44]),
    					listen_dev(form, "submit", prevent_default(/*guardarPaciente*/ ctx[15]), false, true, false),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[45]),
    					listen_dev(input10, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(select5, "change", /*select5_change_handler*/ ctx[46]),
    					listen_dev(select5, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(input11, "input", /*input11_input_handler*/ ctx[47]),
    					listen_dev(input11, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false),
    					listen_dev(select6, "change", /*select6_change_handler*/ ctx[48]),
    					listen_dev(select6, "change", /*buscarDisponibilidadHorario*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filter, estados*/ 264 && input0.value !== /*filter*/ ctx[8].nombrePaciente) {
    				set_input_value(input0, /*filter*/ ctx[8].nombrePaciente);
    			}

    			if (dirty[0] & /*medicos*/ 4) {
    				each_value_6 = /*medicos*/ ctx[2];
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6$1(ctx, each_value_6, i);

    					if (each_blocks_5[i]) {
    						each_blocks_5[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_5[i] = create_each_block_6$1(child_ctx);
    						each_blocks_5[i].c();
    						each_blocks_5[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_5.length; i += 1) {
    					each_blocks_5[i].d(1);
    				}

    				each_blocks_5.length = each_value_6.length;
    			}

    			if (dirty[0] & /*estados*/ 8) {
    				each_value_5 = /*estados*/ ctx[3];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_5$1(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_5.length;
    			}

    			if (dirty[0] & /*filter, estados*/ 264) {
    				select_option(select1, /*filter*/ ctx[8].estadoID);
    			}

    			if (dirty[0] & /*filter, estados*/ 264) {
    				set_input_value(input1, /*filter*/ ctx[8].fechaInicio);
    			}

    			if (dirty[0] & /*filter, estados*/ 264) {
    				set_input_value(input2, /*filter*/ ctx[8].fechaFin);
    			}

    			if (dirty[0] & /*citasPendientes*/ 2) {
    				toggle_class(h4, "d-none", /*citasPendientes*/ ctx[1].length > 0);
    			}

    			if (/*citasPendientes*/ ctx[1].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(div9, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(input4, /*paciente*/ ctx[7].nombre);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(input5, /*paciente*/ ctx[7].apellidos);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(input6, /*paciente*/ ctx[7].cedula);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(input7, /*paciente*/ ctx[7].telefono);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152 && input8.value !== /*paciente*/ ctx[7].correo) {
    				set_input_value(input8, /*paciente*/ ctx[7].correo);
    			}

    			if (dirty[0] & /*aseguradoras*/ 1024) {
    				each_value_3 = /*aseguradoras*/ ctx[10];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$1(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				select_option(select2, /*paciente*/ ctx[7].aseguradoraID);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152 && input9.value !== /*paciente*/ ctx[7].noAfiliado) {
    				set_input_value(input9, /*paciente*/ ctx[7].noAfiliado);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				select_option(select3, /*paciente*/ ctx[7].nacionalidad);
    			}

    			if (dirty[0] & /*provincias*/ 512) {
    				each_value_2 = /*provincias*/ ctx[9];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select4, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				select_option(select4, /*paciente*/ ctx[7].provinciaID);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(textarea0, /*paciente*/ ctx[7].direccion);
    			}

    			if (dirty[0] & /*paciente, aseguradoras*/ 1152) {
    				set_input_value(textarea1, /*paciente*/ ctx[7].observaciones);
    			}

    			if (dirty[0] & /*fecha*/ 32) {
    				set_input_value(input10, /*fecha*/ ctx[5]);
    			}

    			if (dirty[0] & /*tandaID*/ 64) {
    				select_option(select5, /*tandaID*/ ctx[6]);
    			}

    			if (/*horasDisponibles*/ ctx[0].length <= 0) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$2(ctx);
    					if_block1.c();
    					if_block1.m(div49, t84);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*cambiarFechaCita, horasDisponibles*/ 65537) {
    				each_value_1 = /*horasDisponibles*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div49, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*fecha*/ 32) {
    				set_input_value(input11, /*fecha*/ ctx[5]);
    			}

    			if (dirty[0] & /*tandaID*/ 64) {
    				select_option(select6, /*tandaID*/ ctx[6]);
    			}

    			if (/*horasDisponibles*/ ctx[0].length <= 0) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$3(ctx);
    					if_block2.c();
    					if_block2.m(div60, t99);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*irACita, horasDisponibles*/ 131073) {
    				each_value = /*horasDisponibles*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div60, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_5, detaching);
    			destroy_each(each_blocks_4, detaching);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(form);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			if (detaching) detach_dev(t70);
    			if (detaching) detach_dev(div53);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t85);
    			if (detaching) detach_dev(div64);
    			if (if_block2) if_block2.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function colorEstado(code) {
    	if (code == "p") {
    		return "badge-secondary";
    	}

    	if (code == "t") {
    		return "badge-primary";
    	}

    	if (code == "r") {
    		return "badge-success";
    	}

    	if (code == "a") {
    		return "badge-danger";
    	}
    }

    function btnFiltro() {
    	jQuery("#filtroAvanzado").slideToggle(500);
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $axios;
    	let $session;
    	let $activePage;
    	let $errorConexion;
    	let $toast;
    	let $dataCita;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(19, $axios = $$value));
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(20, $session = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(21, $activePage = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(22, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(23, $toast = $$value));
    	validate_store(dataCita, "dataCita");
    	component_subscribe($$self, dataCita, $$value => $$invalidate(24, $dataCita = $$value));

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "citasProgramadas");

    	onMount(() => {
    		moment.locale("es-DO");
    		jQuery("#sltMedicos").select2();

    		jQuery("#sltMedicos").on("select2:select", e => {
    			let data = e.params.data;
    			$$invalidate(4, idMedico = data.id);
    			cargarCitas();
    		});

    		cargarEstados();
    		cargarMedicos();
    		cargarCitas();
    	});

    	let horasDisponibles = [];
    	let citasPendientes = [];
    	let citasRealizadas = [];
    	let medicos = [];
    	let estados = [];
    	let idMedico = "";
    	let fecha = "";
    	let tandaID = 0;

    	let paciente = {
    		id: "",
    		nombre: "",
    		apellido: "",
    		cedula: "",
    		correo: "",
    		telefono: "",
    		aseguradoraID: 0,
    		nombreAseguradora: "",
    		provinciaID: 0,
    		nacionalidad: "",
    		noAfiliado: "",
    		sexo: "",
    		direccion: "",
    		observaciones: ""
    	};

    	let cita = {
    		id: 0,
    		medicoID: "",
    		pacienteID: "",
    		aseguradoraID: 0,
    		estadoID: 1,
    		fecha: "",
    		observaciones: "",
    		inactivo: false
    	};

    	let filter = {
    		medicoID: "",
    		fechaInicio: "",
    		fechaFin: "",
    		estadoID: "",
    		nombrePaciente: ""
    	};

    	let provincias = [
    		{ id: 1, nombre: "Duarte" },
    		{ id: 2, nombre: "Santiago" },
    		{ id: 3, nombre: "Distrito Nacional" }
    	];

    	let aseguradoras = [
    		{ id: 1, nombre: "SENASA" },
    		{ id: 2, nombre: "HUMANO SEGURO" },
    		{ id: 3, nombre: "RENACER" },
    		{ id: 4, nombre: "PALIC" },
    		{ id: 5, nombre: "FUTURO" }
    	];

    	function cargarMedicos() {
    		$axios.get("/Medicos/Query?").then(res => {
    			$$invalidate(2, medicos = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarEstados() {
    		$axios.get("/Citas/Estados").then(res => {
    			$$invalidate(3, estados = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarCitas() {
    		$$invalidate(8, filter.medicoID = idMedico, filter);
    		let qs = new URLSearchParams(filter).toString();

    		$axios.get("/Medicos/CitasFiltrada?" + qs).then(res => {
    			$$invalidate(1, citasPendientes = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarDatosPaciente(item) {
    		$axios.get("/Pacientes/" + item.pacienteID).then(res => {
    			$$invalidate(7, paciente = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function buscarDisponibilidadHorario() {
    		if (fecha == "" || tandaID <= 0) {
    			$$invalidate(0, horasDisponibles = []);
    			return;
    		}

    		let params = "date=" + fecha + "&" + "tandiId=" + tandaID;

    		$axios.get("/Medicos/HorasDisponibles/" + idMedico + "?" + params).then(res => {
    			$$invalidate(0, horasDisponibles = res.data.map(x => {
    				return {
    					time: x,
    					hora: moment(x, "LT").format("LT")
    				};
    			}));
    		}).catch(err => {
    			$$invalidate(0, horasDisponibles = []);
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function reprogramarCita(item) {
    		cita = item;

    		if (fecha == "" || tandaID <= 0) {
    			$$invalidate(5, fecha = moment().format("YYYY-MM-DD"));
    			$$invalidate(6, tandaID = 1);
    		}

    		buscarDisponibilidadHorario();
    	}

    	function guardarPaciente() {
    		if (paciente.aseguradoraID > 0) {
    			$$invalidate(7, paciente.nombreAseguradora = aseguradoras.find(e => e.id == paciente.aseguradoraID).nombre, paciente);
    		}

    		$axios.put("/Pacientes/" + paciente.id, paciente).then(res => {
    			if (res.data.success) {
    				$toast(5000).fire({
    					icon: "success",
    					title: "Paciente actualizado con exito"
    				});

    				jQuery("#modalPaciente").modal("hide");
    			} else {
    				console.log(res);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cambiarFechaCita(hora) {
    		cita.fecha = fecha + "T" + hora;
    		cita.estadoID = 1;
    		cita.inactivo = false;

    		$axios.put("/Citas/" + cita.id, cita).then(res => {
    			if (res.data.success) {
    				$toast(5000).fire({
    					icon: "success",
    					title: "Cambio de cita realizado con exito"
    				});

    				cargarCitas();
    				jQuery("#modalCrearCita").modal("hide");
    			} else {
    				console.log(res);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function irACita(time) {
    		set_store_value(dataCita, $dataCita = {
    			fechaCita: fecha,
    			tandaID,
    			hora: time,
    			medicoId: idMedico,
    			pacienteId: cita.pacienteID
    		});

    		push("/Cita/Crear");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<CitasProgramadas> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("CitasProgramadas", $$slots, []);

    	function input0_input_handler() {
    		filter.nombrePaciente = this.value;
    		$$invalidate(8, filter);
    		$$invalidate(3, estados);
    	}

    	function select1_change_handler() {
    		filter.estadoID = select_value(this);
    		$$invalidate(8, filter);
    		$$invalidate(3, estados);
    	}

    	function input1_input_handler() {
    		filter.fechaInicio = this.value;
    		$$invalidate(8, filter);
    		$$invalidate(3, estados);
    	}

    	function input2_input_handler() {
    		filter.fechaFin = this.value;
    		$$invalidate(8, filter);
    		$$invalidate(3, estados);
    	}

    	const click_handler = i => cargarDatosPaciente(i);
    	const click_handler_1 = i => reprogramarCita(i);

    	function input4_input_handler() {
    		paciente.nombre = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input5_input_handler() {
    		paciente.apellidos = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input6_input_handler() {
    		paciente.cedula = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input7_input_handler() {
    		paciente.telefono = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input8_input_handler() {
    		paciente.correo = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function select2_change_handler() {
    		paciente.aseguradoraID = select_value(this);
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input9_input_handler() {
    		paciente.noAfiliado = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function select3_change_handler() {
    		paciente.nacionalidad = select_value(this);
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function select4_change_handler() {
    		paciente.provinciaID = select_value(this);
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function textarea0_input_handler() {
    		paciente.direccion = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function textarea1_input_handler() {
    		paciente.observaciones = this.value;
    		$$invalidate(7, paciente);
    		$$invalidate(10, aseguradoras);
    	}

    	function input10_input_handler() {
    		fecha = this.value;
    		$$invalidate(5, fecha);
    	}

    	function select5_change_handler() {
    		tandaID = select_value(this);
    		$$invalidate(6, tandaID);
    	}

    	function input11_input_handler() {
    		fecha = this.value;
    		$$invalidate(5, fecha);
    	}

    	function select6_change_handler() {
    		tandaID = select_value(this);
    		$$invalidate(6, tandaID);
    	}

    	const click_handler_2 = i => irACita(i.time);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		connection,
    		activePage,
    		session,
    		axios: axios$2,
    		dataCita,
    		errorConexion,
    		toast,
    		onMount,
    		push,
    		moment,
    		horasDisponibles,
    		citasPendientes,
    		citasRealizadas,
    		medicos,
    		estados,
    		idMedico,
    		fecha,
    		tandaID,
    		paciente,
    		cita,
    		filter,
    		provincias,
    		aseguradoras,
    		colorEstado,
    		cargarMedicos,
    		cargarEstados,
    		cargarCitas,
    		cargarDatosPaciente,
    		buscarDisponibilidadHorario,
    		reprogramarCita,
    		guardarPaciente,
    		cambiarFechaCita,
    		irACita,
    		btnFiltro,
    		$axios,
    		$session,
    		$activePage,
    		$errorConexion,
    		$toast,
    		$dataCita
    	});

    	$$self.$inject_state = $$props => {
    		if ("horasDisponibles" in $$props) $$invalidate(0, horasDisponibles = $$props.horasDisponibles);
    		if ("citasPendientes" in $$props) $$invalidate(1, citasPendientes = $$props.citasPendientes);
    		if ("citasRealizadas" in $$props) citasRealizadas = $$props.citasRealizadas;
    		if ("medicos" in $$props) $$invalidate(2, medicos = $$props.medicos);
    		if ("estados" in $$props) $$invalidate(3, estados = $$props.estados);
    		if ("idMedico" in $$props) $$invalidate(4, idMedico = $$props.idMedico);
    		if ("fecha" in $$props) $$invalidate(5, fecha = $$props.fecha);
    		if ("tandaID" in $$props) $$invalidate(6, tandaID = $$props.tandaID);
    		if ("paciente" in $$props) $$invalidate(7, paciente = $$props.paciente);
    		if ("cita" in $$props) cita = $$props.cita;
    		if ("filter" in $$props) $$invalidate(8, filter = $$props.filter);
    		if ("provincias" in $$props) $$invalidate(9, provincias = $$props.provincias);
    		if ("aseguradoras" in $$props) $$invalidate(10, aseguradoras = $$props.aseguradoras);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		horasDisponibles,
    		citasPendientes,
    		medicos,
    		estados,
    		idMedico,
    		fecha,
    		tandaID,
    		paciente,
    		filter,
    		provincias,
    		aseguradoras,
    		cargarCitas,
    		cargarDatosPaciente,
    		buscarDisponibilidadHorario,
    		reprogramarCita,
    		guardarPaciente,
    		cambiarFechaCita,
    		irACita,
    		cita,
    		$axios,
    		$session,
    		$activePage,
    		$errorConexion,
    		$toast,
    		$dataCita,
    		citasRealizadas,
    		cargarMedicos,
    		cargarEstados,
    		input0_input_handler,
    		select1_change_handler,
    		input1_input_handler,
    		input2_input_handler,
    		click_handler,
    		click_handler_1,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		input8_input_handler,
    		select2_change_handler,
    		input9_input_handler,
    		select3_change_handler,
    		select4_change_handler,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		input10_input_handler,
    		select5_change_handler,
    		input11_input_handler,
    		select6_change_handler,
    		click_handler_2
    	];
    }

    class CitasProgramadas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {}, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CitasProgramadas",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\Pages\Cita\Crear.svelte generated by Svelte v3.23.0 */

    const { console: console_1$4 } = globals;
    const file$6 = "src\\Pages\\Cita\\Crear.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    // (320:26) {#each tandas as item}
    function create_each_block_3$2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[36].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[36].id;
    			option.value = option.__value;
    			add_location(option, file$6, 320, 26, 10273);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tandas*/ 2 && t_value !== (t_value = /*item*/ ctx[36].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*tandas*/ 2 && option_value_value !== (option_value_value = /*item*/ ctx[36].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(320:26) {#each tandas as item}",
    		ctx
    	});

    	return block;
    }

    // (333:26) {#each medicos as item}
    function create_each_block_2$2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[36].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[36].id;
    			option.value = option.__value;
    			add_location(option, file$6, 333, 26, 10950);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*medicos*/ 16 && t_value !== (t_value = /*item*/ ctx[36].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*medicos*/ 16 && option_value_value !== (option_value_value = /*item*/ ctx[36].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(333:26) {#each medicos as item}",
    		ctx
    	});

    	return block;
    }

    // (345:26) {#each horas as item}
    function create_each_block_1$2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[36].hora + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[36].time;
    			option.value = option.__value;
    			add_location(option, file$6, 345, 26, 11585);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*horas*/ 4 && t_value !== (t_value = /*item*/ ctx[36].hora + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*horas*/ 4 && option_value_value !== (option_value_value = /*item*/ ctx[36].time)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(345:26) {#each horas as item}",
    		ctx
    	});

    	return block;
    }

    // (416:10) {#each pacientes as i}
    function create_each_block$2(ctx) {
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let span0;
    	let t0_value = /*i*/ ctx[33].nombre + "";
    	let t0;
    	let t1;
    	let t2_value = /*i*/ ctx[33].apellidos + "";
    	let t2;
    	let t3;
    	let span1;
    	let t4;
    	let t5_value = /*i*/ ctx[33].telefono + "";
    	let t5;
    	let t6;
    	let span2;
    	let t7;
    	let t8_value = (/*i*/ ctx[33].cedula || "\"Ningulo\"") + "";
    	let t8;
    	let t9;
    	let div1;
    	let t10_value = /*i*/ ctx[33].direccion + "";
    	let t10;
    	let t11;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = text("\r\n                  »\r\n                  ");
    			span1 = element("span");
    			t4 = text("Tel.: ");
    			t5 = text(t5_value);
    			t6 = text("\r\n                  »\r\n                  ");
    			span2 = element("span");
    			t7 = text("ID: ");
    			t8 = text(t8_value);
    			t9 = space();
    			div1 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			attr_dev(span0, "class", "nombre-apellido svelte-1rn2xak");
    			set_style(span0, "font-weight", "bold");
    			add_location(span0, file$6, 423, 18, 14514);
    			add_location(span1, file$6, 425, 18, 14643);
    			add_location(span2, file$6, 427, 18, 14715);
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$6, 422, 16, 14476);
    			attr_dev(div1, "class", "text-muted");
    			add_location(div1, file$6, 429, 16, 14801);
    			attr_dev(div2, "class", "text-primary");
    			add_location(div2, file$6, 421, 14, 14432);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$6, 420, 12, 14399);
    			set_style(div4, "cursor", "pointer");
    			attr_dev(div4, "class", "list-group-item d-flex align-items-center link-pacientes svelte-1rn2xak");
    			add_location(div4, file$6, 416, 10, 14218);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(span0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, span1);
    			append_dev(span1, t4);
    			append_dev(span1, t5);
    			append_dev(div0, t6);
    			append_dev(div0, span2);
    			append_dev(span2, t7);
    			append_dev(span2, t8);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			append_dev(div1, t10);
    			append_dev(div4, t11);

    			if (!mounted) {
    				dispose = listen_dev(
    					div4,
    					"click",
    					function () {
    						if (is_function(/*seleccionarPaciente*/ ctx[9](/*i*/ ctx[33]))) /*seleccionarPaciente*/ ctx[9](/*i*/ ctx[33]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*pacientes*/ 8 && t0_value !== (t0_value = /*i*/ ctx[33].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*pacientes*/ 8 && t2_value !== (t2_value = /*i*/ ctx[33].apellidos + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*pacientes*/ 8 && t5_value !== (t5_value = /*i*/ ctx[33].telefono + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*pacientes*/ 8 && t8_value !== (t8_value = (/*i*/ ctx[33].cedula || "\"Ningulo\"") + "")) set_data_dev(t8, t8_value);
    			if (dirty[0] & /*pacientes*/ 8 && t10_value !== (t10_value = /*i*/ ctx[33].direccion + "")) set_data_dev(t10, t10_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(416:10) {#each pacientes as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div28;
    	let div27;
    	let div26;
    	let div25;
    	let div1;
    	let h50;
    	let i0;
    	let t2;
    	let t3;
    	let div0;
    	let t4;
    	let div24;
    	let form;
    	let div8;
    	let div2;
    	let button0;
    	let i1;
    	let t5;
    	let t6;
    	let div3;
    	let label0;
    	let t7;
    	let span0;
    	let t9;
    	let input0;
    	let t10;
    	let div4;
    	let label1;
    	let t11;
    	let span1;
    	let t13;
    	let input1;
    	let t14;
    	let div5;
    	let label2;
    	let t15;
    	let span2;
    	let t17;
    	let input2;
    	let t18;
    	let div6;
    	let label3;
    	let t20;
    	let input3;
    	let t21;
    	let div7;
    	let label4;
    	let t23;
    	let textarea0;
    	let t24;
    	let p;
    	let t25;
    	let span3;
    	let t27;
    	let t28;
    	let div23;
    	let div22;
    	let div10;
    	let div9;
    	let label5;
    	let t30;
    	let input4;
    	let t31;
    	let div12;
    	let div11;
    	let label6;
    	let t33;
    	let select0;
    	let option0;
    	let option0_value_value;
    	let t35;
    	let div14;
    	let div13;
    	let label7;
    	let t37;
    	let select1;
    	let option1;
    	let option1_value_value;
    	let t39;
    	let div16;
    	let div15;
    	let label8;
    	let t41;
    	let select2;
    	let option2;
    	let option2_value_value;
    	let t43;
    	let div18;
    	let div17;
    	let label9;
    	let t45;
    	let input5;
    	let t46;
    	let div20;
    	let div19;
    	let label10;
    	let t48;
    	let textarea1;
    	let t49;
    	let div21;
    	let button1;
    	let i2;
    	let t50;
    	let div40;
    	let div39;
    	let div38;
    	let div29;
    	let h51;
    	let t52;
    	let button2;
    	let span4;
    	let t54;
    	let div34;
    	let div32;
    	let input6;
    	let t55;
    	let div31;
    	let div30;
    	let span5;
    	let t56;
    	let div33;
    	let t57;
    	let div37;
    	let div36;
    	let div35;
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_3 = /*tandas*/ ctx[1];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*medicos*/ ctx[4];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*horas*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let each_value = /*pacientes*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div28 = element("div");
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			div1 = element("div");
    			h50 = element("h5");
    			i0 = element("i");
    			t2 = text("\r\n                Creando cita");
    			t3 = space();
    			div0 = element("div");
    			t4 = space();
    			div24 = element("div");
    			form = element("form");
    			div8 = element("div");
    			div2 = element("div");
    			button0 = element("button");
    			i1 = element("i");
    			t5 = text("\r\n                    Buscar paciente");
    			t6 = space();
    			div3 = element("div");
    			label0 = element("label");
    			t7 = text("Nombre paciente ");
    			span0 = element("span");
    			span0.textContent = "*";
    			t9 = space();
    			input0 = element("input");
    			t10 = space();
    			div4 = element("div");
    			label1 = element("label");
    			t11 = text("Apellidos paciente ");
    			span1 = element("span");
    			span1.textContent = "*";
    			t13 = space();
    			input1 = element("input");
    			t14 = space();
    			div5 = element("div");
    			label2 = element("label");
    			t15 = text("Telefono / Celular ");
    			span2 = element("span");
    			span2.textContent = "*";
    			t17 = space();
    			input2 = element("input");
    			t18 = space();
    			div6 = element("div");
    			label3 = element("label");
    			label3.textContent = "Correo electronico";
    			t20 = space();
    			input3 = element("input");
    			t21 = space();
    			div7 = element("div");
    			label4 = element("label");
    			label4.textContent = "Direccion";
    			t23 = space();
    			textarea0 = element("textarea");
    			t24 = space();
    			p = element("p");
    			t25 = text("Los campos con un ( ");
    			span3 = element("span");
    			span3.textContent = "*";
    			t27 = text(" ) son obligatorios");
    			t28 = space();
    			div23 = element("div");
    			div22 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			label5 = element("label");
    			label5.textContent = "Fecha cita";
    			t30 = space();
    			input4 = element("input");
    			t31 = space();
    			div12 = element("div");
    			div11 = element("div");
    			label6 = element("label");
    			label6.textContent = "Tanda";
    			t33 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t35 = space();
    			div14 = element("div");
    			div13 = element("div");
    			label7 = element("label");
    			label7.textContent = "Médico";
    			t37 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t39 = space();
    			div16 = element("div");
    			div15 = element("div");
    			label8 = element("label");
    			label8.textContent = "Hora";
    			t41 = space();
    			select2 = element("select");
    			option2 = element("option");
    			option2.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t43 = space();
    			div18 = element("div");
    			div17 = element("div");
    			label9 = element("label");
    			label9.textContent = "Ubicación del Médico en el centro";
    			t45 = space();
    			input5 = element("input");
    			t46 = space();
    			div20 = element("div");
    			div19 = element("div");
    			label10 = element("label");
    			label10.textContent = "Observaciones";
    			t48 = space();
    			textarea1 = element("textarea");
    			t49 = space();
    			div21 = element("div");
    			button1 = element("button");
    			i2 = element("i");
    			t50 = space();
    			div40 = element("div");
    			div39 = element("div");
    			div38 = element("div");
    			div29 = element("div");
    			h51 = element("h5");
    			h51.textContent = "Buscar pacientes";
    			t52 = space();
    			button2 = element("button");
    			span4 = element("span");
    			span4.textContent = "×";
    			t54 = space();
    			div34 = element("div");
    			div32 = element("div");
    			input6 = element("input");
    			t55 = space();
    			div31 = element("div");
    			div30 = element("div");
    			span5 = element("span");
    			t56 = space();
    			div33 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t57 = space();
    			div37 = element("div");
    			div36 = element("div");
    			div35 = element("div");
    			a = element("a");
    			a.textContent = "Cerrar";
    			attr_dev(i0, "class", "mdi mdi-checkbox-intermediate");
    			add_location(i0, file$6, 224, 16, 5523);
    			add_location(h50, file$6, 223, 14, 5501);
    			attr_dev(div0, "class", "card-controls");
    			add_location(div0, file$6, 227, 14, 5633);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$6, 222, 12, 5460);
    			attr_dev(i1, "class", "mdi mdi-search-web");
    			add_location(i1, file$6, 234, 20, 6132);
    			attr_dev(button0, "class", "btn btn-primary btn-sm");
    			attr_dev(button0, "data-toggle", "modal");
    			set_style(button0, "position", "absolute");
    			set_style(button0, "top", "-30px");
    			set_style(button0, "right", "0");
    			attr_dev(button0, "data-target", "#modalPacientes");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$6, 233, 22, 5957);
    			attr_dev(div2, "class", "col-lg-12 mt-2");
    			set_style(div2, "padding", "0");
    			set_style(div2, "margin", "0");
    			add_location(div2, file$6, 232, 18, 5874);
    			attr_dev(span0, "class", "text-danger");
    			add_location(span0, file$6, 240, 59, 6363);
    			attr_dev(label0, "for", "inpNombre");
    			add_location(label0, file$6, 240, 20, 6324);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "inpNombre");
    			input0.required = true;
    			add_location(input0, file$6, 241, 20, 6428);
    			attr_dev(div3, "class", "form-group");
    			add_location(div3, file$6, 239, 18, 6278);
    			attr_dev(span1, "class", "text-danger");
    			add_location(span1, file$6, 248, 64, 6746);
    			attr_dev(label1, "for", "inpApellido");
    			add_location(label1, file$6, 248, 20, 6702);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "id", "inpApellido");
    			input1.required = true;
    			add_location(input1, file$6, 249, 20, 6810);
    			attr_dev(div4, "class", "form-group");
    			add_location(div4, file$6, 247, 18, 6656);
    			attr_dev(span2, "class", "text-danger");
    			add_location(span2, file$6, 256, 64, 7133);
    			attr_dev(label2, "for", "inpTelefono");
    			add_location(label2, file$6, 256, 20, 7089);
    			attr_dev(input2, "type", "tel");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "id", "inpTelefono");
    			input2.required = true;
    			add_location(input2, file$6, 257, 20, 7197);
    			attr_dev(div5, "class", "form-group");
    			add_location(div5, file$6, 255, 18, 7043);
    			attr_dev(label3, "for", "inpCorreo");
    			add_location(label3, file$6, 264, 20, 7474);
    			attr_dev(input3, "type", "email");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "id", "inpCorreo");
    			add_location(input3, file$6, 265, 20, 7545);
    			attr_dev(div6, "class", "form-group");
    			add_location(div6, file$6, 263, 18, 7428);
    			attr_dev(label4, "class", "font-secondary");
    			add_location(label4, file$6, 290, 20, 8840);
    			attr_dev(textarea0, "class", "form-control");
    			attr_dev(textarea0, "rows", "3");
    			add_location(textarea0, file$6, 291, 20, 8909);
    			attr_dev(div7, "class", "form-group ");
    			add_location(div7, file$6, 289, 18, 8793);
    			attr_dev(span3, "class", "text-danger");
    			add_location(span3, file$6, 296, 41, 9116);
    			add_location(p, file$6, 296, 18, 9093);
    			attr_dev(div8, "class", "col-lg-5 borde-derecho svelte-1rn2xak");
    			add_location(div8, file$6, 231, 16, 5818);
    			attr_dev(label5, "for", "Fecha");
    			add_location(label5, file$6, 303, 24, 9394);
    			attr_dev(input4, "type", "date");
    			attr_dev(input4, "class", "form-control mb-2");
    			attr_dev(input4, "id", "Fecha");
    			input4.required = true;
    			add_location(input4, file$6, 304, 24, 9457);
    			attr_dev(div9, "class", "form-group");
    			add_location(div9, file$6, 302, 22, 9344);
    			attr_dev(div10, "class", "col-lg-6");
    			add_location(div10, file$6, 301, 20, 9298);
    			attr_dev(label6, "class", "font-secondary");
    			add_location(label6, file$6, 315, 24, 9924);
    			option0.__value = option0_value_value = 0;
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			add_location(option0, file$6, 318, 26, 10135);
    			attr_dev(select0, "class", "form-control");
    			select0.required = true;
    			if (/*obj*/ ctx[0].tandaID === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[28].call(select0));
    			add_location(select0, file$6, 316, 24, 9993);
    			attr_dev(div11, "class", "form-group ");
    			add_location(div11, file$6, 314, 22, 9873);
    			attr_dev(div12, "class", "col-lg-6");
    			add_location(div12, file$6, 313, 20, 9827);
    			attr_dev(label7, "class", "font-secondary");
    			add_location(label7, file$6, 328, 24, 10568);
    			option1.__value = option1_value_value = 0;
    			option1.value = option1.__value;
    			option1.disabled = true;
    			option1.selected = true;
    			add_location(option1, file$6, 331, 26, 10811);
    			attr_dev(select1, "class", "form-control js-select2");
    			attr_dev(select1, "id", "sltMedicos");
    			select1.disabled = /*faltaLaTanda*/ ctx[6];
    			select1.required = true;
    			if (/*obj*/ ctx[0].MedicoID === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[29].call(select1));
    			add_location(select1, file$6, 329, 24, 10638);
    			attr_dev(div13, "class", "form-group ");
    			add_location(div13, file$6, 327, 22, 10517);
    			attr_dev(div14, "class", "col-lg-6");
    			add_location(div14, file$6, 326, 20, 10471);
    			attr_dev(label8, "class", "font-secondary");
    			add_location(label8, file$6, 340, 24, 11240);
    			option2.__value = option2_value_value = "";
    			option2.value = option2.__value;
    			option2.disabled = true;
    			option2.selected = true;
    			add_location(option2, file$6, 343, 26, 11447);
    			attr_dev(select2, "class", "form-control");
    			select2.disabled = /*faltaLaTanda*/ ctx[6];
    			select2.required = true;
    			if (/*obj*/ ctx[0].hora === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[30].call(select2));
    			add_location(select2, file$6, 341, 24, 11308);
    			attr_dev(div15, "class", "form-group");
    			add_location(div15, file$6, 339, 22, 11190);
    			attr_dev(div16, "class", "col-lg-6");
    			add_location(div16, file$6, 338, 20, 11144);
    			attr_dev(label9, "class", "font-secondary");
    			add_location(label9, file$6, 352, 24, 11879);
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "class", "form-control");
    			input5.readOnly = true;
    			add_location(input5, file$6, 353, 24, 11990);
    			attr_dev(div17, "class", "form-group ");
    			add_location(div17, file$6, 351, 22, 11828);
    			attr_dev(div18, "class", "col-lg-12");
    			add_location(div18, file$6, 350, 20, 11781);
    			attr_dev(label10, "class", "font-secondary");
    			add_location(label10, file$6, 358, 24, 12217);
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "rows", "5");
    			add_location(textarea1, file$6, 359, 24, 12294);
    			attr_dev(div19, "class", "form-group ");
    			add_location(div19, file$6, 357, 22, 12166);
    			attr_dev(div20, "class", "col-lg-12");
    			add_location(div20, file$6, 356, 20, 12119);
    			attr_dev(i2, "class", "mdi mdi-content-save-outline");
    			set_style(i2, "font-size", "23px");
    			add_location(i2, file$6, 364, 24, 12714);
    			attr_dev(button1, "type", "submit");
    			attr_dev(button1, "class", "btn btn-success");
    			set_style(button1, "position", "fixed");
    			set_style(button1, "height", "50px");
    			set_style(button1, "width", "50px");
    			set_style(button1, "border-radius", "50%");
    			set_style(button1, "right", "40px");
    			set_style(button1, "bottom", "40px");
    			attr_dev(button1, "title", "Guardar");
    			add_location(button1, file$6, 363, 22, 12527);
    			attr_dev(div21, "class", "col-lg-12 p-t-80");
    			set_style(div21, "text-align", "right");
    			add_location(div21, file$6, 362, 20, 12446);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$6, 300, 18, 9259);
    			attr_dev(div23, "class", "col-lg-7");
    			add_location(div23, file$6, 299, 16, 9217);
    			attr_dev(form, "class", "row");
    			add_location(form, file$6, 230, 14, 5739);
    			attr_dev(div24, "class", "card-body");
    			add_location(div24, file$6, 229, 12, 5700);
    			attr_dev(div25, "class", "card");
    			add_location(div25, file$6, 221, 10, 5428);
    			attr_dev(div26, "class", "col-lg-12 mb-5");
    			add_location(div26, file$6, 220, 8, 5388);
    			attr_dev(div27, "class", "row");
    			add_location(div27, file$6, 219, 6, 5361);
    			attr_dev(div28, "class", "container mt-3");
    			add_location(div28, file$6, 218, 4, 5325);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$6, 217, 2, 5288);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$6, 215, 0, 5245);
    			attr_dev(h51, "class", "modal-title");
    			attr_dev(h51, "id", "modalPacientes");
    			add_location(h51, file$6, 390, 8, 13366);
    			attr_dev(span4, "aria-hidden", "true");
    			add_location(span4, file$6, 396, 10, 13573);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "close");
    			attr_dev(button2, "data-dismiss", "modal");
    			attr_dev(button2, "aria-label", "Close");
    			add_location(button2, file$6, 391, 8, 13441);
    			attr_dev(div29, "class", "modal-header");
    			add_location(div29, file$6, 389, 6, 13330);
    			attr_dev(input6, "type", "search");
    			attr_dev(input6, "class", "form-control form-control-appended");
    			attr_dev(input6, "placeholder", "Buscar");
    			add_location(input6, file$6, 402, 10, 13743);
    			attr_dev(span5, "class", "mdi mdi-magnify");
    			add_location(span5, file$6, 409, 14, 14044);
    			attr_dev(div30, "class", " input-group-text");
    			add_location(div30, file$6, 408, 12, 13997);
    			attr_dev(div31, "class", "input-group-append");
    			add_location(div31, file$6, 407, 10, 13951);
    			attr_dev(div32, "class", "input-group input-group-flush mb-3");
    			add_location(div32, file$6, 401, 8, 13683);
    			attr_dev(div33, "class", "list-group list ");
    			add_location(div33, file$6, 414, 8, 14142);
    			attr_dev(div34, "class", "modal-body svelte-1rn2xak");
    			add_location(div34, file$6, 399, 6, 13647);
    			attr_dev(a, "href", "#!");
    			attr_dev(a, "class", "btn btn-secondary");
    			attr_dev(a, "data-dismiss", "modal");
    			add_location(a, file$6, 441, 12, 15113);
    			attr_dev(div35, "class", "col");
    			add_location(div35, file$6, 440, 10, 15082);
    			attr_dev(div36, "class", "row text-center p-b-5");
    			add_location(div36, file$6, 439, 8, 15035);
    			attr_dev(div37, "class", "modal-footer");
    			add_location(div37, file$6, 438, 6, 14999);
    			attr_dev(div38, "class", "modal-content");
    			add_location(div38, file$6, 388, 4, 13295);
    			attr_dev(div39, "class", "modal-dialog");
    			attr_dev(div39, "role", "document");
    			add_location(div39, file$6, 387, 2, 13247);
    			attr_dev(div40, "class", "modal fade modal-slide-right svelte-1rn2xak");
    			attr_dev(div40, "id", "modalPacientes");
    			attr_dev(div40, "tabindex", "-1");
    			attr_dev(div40, "role", "dialog");
    			attr_dev(div40, "aria-labelledby", "modalPacientes");
    			set_style(div40, "display", "none");
    			set_style(div40, "padding-right", "16px");
    			attr_dev(div40, "aria-modal", "true");
    			add_location(div40, file$6, 379, 0, 13037);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div28);
    			append_dev(div28, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div1);
    			append_dev(div1, h50);
    			append_dev(h50, i0);
    			append_dev(h50, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div25, t4);
    			append_dev(div25, div24);
    			append_dev(div24, form);
    			append_dev(form, div8);
    			append_dev(div8, div2);
    			append_dev(div2, button0);
    			append_dev(button0, i1);
    			append_dev(button0, t5);
    			append_dev(div8, t6);
    			append_dev(div8, div3);
    			append_dev(div3, label0);
    			append_dev(label0, t7);
    			append_dev(label0, span0);
    			append_dev(div3, t9);
    			append_dev(div3, input0);
    			set_input_value(input0, /*obj*/ ctx[0].Nombre);
    			append_dev(div8, t10);
    			append_dev(div8, div4);
    			append_dev(div4, label1);
    			append_dev(label1, t11);
    			append_dev(label1, span1);
    			append_dev(div4, t13);
    			append_dev(div4, input1);
    			set_input_value(input1, /*obj*/ ctx[0].Apellidos);
    			append_dev(div8, t14);
    			append_dev(div8, div5);
    			append_dev(div5, label2);
    			append_dev(label2, t15);
    			append_dev(label2, span2);
    			append_dev(div5, t17);
    			append_dev(div5, input2);
    			set_input_value(input2, /*obj*/ ctx[0].Telefono);
    			append_dev(div8, t18);
    			append_dev(div8, div6);
    			append_dev(div6, label3);
    			append_dev(div6, t20);
    			append_dev(div6, input3);
    			set_input_value(input3, /*obj*/ ctx[0].Correo);
    			append_dev(div8, t21);
    			append_dev(div8, div7);
    			append_dev(div7, label4);
    			append_dev(div7, t23);
    			append_dev(div7, textarea0);
    			set_input_value(textarea0, /*obj*/ ctx[0].Direccion);
    			append_dev(div8, t24);
    			append_dev(div8, p);
    			append_dev(p, t25);
    			append_dev(p, span3);
    			append_dev(p, t27);
    			append_dev(form, t28);
    			append_dev(form, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div10);
    			append_dev(div10, div9);
    			append_dev(div9, label5);
    			append_dev(div9, t30);
    			append_dev(div9, input4);
    			set_input_value(input4, /*obj*/ ctx[0].Fecha);
    			append_dev(div22, t31);
    			append_dev(div22, div12);
    			append_dev(div12, div11);
    			append_dev(div11, label6);
    			append_dev(div11, t33);
    			append_dev(div11, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select0, null);
    			}

    			select_option(select0, /*obj*/ ctx[0].tandaID);
    			append_dev(div22, t35);
    			append_dev(div22, div14);
    			append_dev(div14, div13);
    			append_dev(div13, label7);
    			append_dev(div13, t37);
    			append_dev(div13, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select1, null);
    			}

    			select_option(select1, /*obj*/ ctx[0].MedicoID);
    			append_dev(div22, t39);
    			append_dev(div22, div16);
    			append_dev(div16, div15);
    			append_dev(div15, label8);
    			append_dev(div15, t41);
    			append_dev(div15, select2);
    			append_dev(select2, option2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select2, null);
    			}

    			select_option(select2, /*obj*/ ctx[0].hora);
    			append_dev(div22, t43);
    			append_dev(div22, div18);
    			append_dev(div18, div17);
    			append_dev(div17, label9);
    			append_dev(div17, t45);
    			append_dev(div17, input5);
    			append_dev(div22, t46);
    			append_dev(div22, div20);
    			append_dev(div20, div19);
    			append_dev(div19, label10);
    			append_dev(div19, t48);
    			append_dev(div19, textarea1);
    			set_input_value(textarea1, /*obj*/ ctx[0].Observaciones);
    			append_dev(div22, t49);
    			append_dev(div22, div21);
    			append_dev(div21, button1);
    			append_dev(button1, i2);
    			insert_dev(target, t50, anchor);
    			insert_dev(target, div40, anchor);
    			append_dev(div40, div39);
    			append_dev(div39, div38);
    			append_dev(div38, div29);
    			append_dev(div29, h51);
    			append_dev(div29, t52);
    			append_dev(div29, button2);
    			append_dev(button2, span4);
    			append_dev(div38, t54);
    			append_dev(div38, div34);
    			append_dev(div34, div32);
    			append_dev(div32, input6);
    			set_input_value(input6, /*busquedaPacientes*/ ctx[5]);
    			append_dev(div32, t55);
    			append_dev(div32, div31);
    			append_dev(div31, div30);
    			append_dev(div30, span5);
    			append_dev(div34, t56);
    			append_dev(div34, div33);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div33, null);
    			}

    			append_dev(div38, t57);
    			append_dev(div38, div37);
    			append_dev(div37, div36);
    			append_dev(div36, div35);
    			append_dev(div35, a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[21]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[22]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[23]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[24]),
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[25]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[26]),
    					listen_dev(input4, "change", /*change_handler*/ ctx[27], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[28]),
    					listen_dev(select0, "change", /*cargarHoras*/ ctx[8], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[29]),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[30]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[31]),
    					listen_dev(form, "submit", prevent_default(/*guardarPaciente*/ ctx[10]), false, true, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[32]),
    					listen_dev(input6, "input", /*cargarPacientes*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*obj, tandas*/ 3 && input0.value !== /*obj*/ ctx[0].Nombre) {
    				set_input_value(input0, /*obj*/ ctx[0].Nombre);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3 && input1.value !== /*obj*/ ctx[0].Apellidos) {
    				set_input_value(input1, /*obj*/ ctx[0].Apellidos);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				set_input_value(input2, /*obj*/ ctx[0].Telefono);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3 && input3.value !== /*obj*/ ctx[0].Correo) {
    				set_input_value(input3, /*obj*/ ctx[0].Correo);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				set_input_value(textarea0, /*obj*/ ctx[0].Direccion);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				set_input_value(input4, /*obj*/ ctx[0].Fecha);
    			}

    			if (dirty[0] & /*tandas*/ 2) {
    				each_value_3 = /*tandas*/ ctx[1];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$2(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				select_option(select0, /*obj*/ ctx[0].tandaID);
    			}

    			if (dirty[0] & /*medicos*/ 16) {
    				each_value_2 = /*medicos*/ ctx[4];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (!current || dirty[0] & /*faltaLaTanda*/ 64) {
    				prop_dev(select1, "disabled", /*faltaLaTanda*/ ctx[6]);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				select_option(select1, /*obj*/ ctx[0].MedicoID);
    			}

    			if (dirty[0] & /*horas*/ 4) {
    				each_value_1 = /*horas*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (!current || dirty[0] & /*faltaLaTanda*/ 64) {
    				prop_dev(select2, "disabled", /*faltaLaTanda*/ ctx[6]);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				select_option(select2, /*obj*/ ctx[0].hora);
    			}

    			if (dirty[0] & /*obj, tandas*/ 3) {
    				set_input_value(textarea1, /*obj*/ ctx[0].Observaciones);
    			}

    			if (dirty[0] & /*busquedaPacientes*/ 32) {
    				set_input_value(input6, /*busquedaPacientes*/ ctx[5]);
    			}

    			if (dirty[0] & /*seleccionarPaciente, pacientes*/ 520) {
    				each_value = /*pacientes*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div33, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t50);
    			if (detaching) detach_dev(div40);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $axios;
    	let $session;
    	let $activePage;
    	let $dataCita;
    	let $errorConexion;
    	let $toast;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(11, $axios = $$value));
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(12, $session = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(13, $activePage = $$value));
    	validate_store(dataCita, "dataCita");
    	component_subscribe($$self, dataCita, $$value => $$invalidate(14, $dataCita = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(15, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(16, $toast = $$value));

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "citas.crear");

    	onMount(() => {
    		jQuery("#sltMedicos").select2();

    		jQuery("#sltMedicos").on("select2:select", e => {
    			let data = e.params.data;
    			$$invalidate(0, obj.MedicoID = data.id, obj);
    			cargarHoras();
    		});

    		cargarPacientes();
    		cargarTandas();
    		cargarHoras();
    		cargarMedicos();
    	});

    	let data = $dataCita;

    	let obj = {
    		Observaciones: "",
    		Fecha: data.fechaCita || "",
    		MedicoID: data.medicoId,
    		PacienteID: data.pacienteId || "",
    		AseguradoraID: 1,
    		EstadoID: 1,
    		Nombre: "",
    		Apellidos: "",
    		Telefono: "",
    		Correo: "",
    		Sexo: "",
    		Direccion: "",
    		tandaID: data.tandaID,
    		hora: ""
    	};

    	let tandas = [];
    	let horas = [];
    	let pacientes = [];
    	let medicos = [];
    	let busquedaPacientes = "";

    	function cargarMedicos() {
    		$axios.get("/Medicos/Query").then(res => {
    			$$invalidate(4, medicos = res.data);
    			setTimeout(x => jQuery("#sltMedicos").val(obj.MedicoID).trigger("change"), 10);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarPacientes() {
    		let qs = busquedaPacientes != ""
    		? "?keyword=" + busquedaPacientes
    		: "";

    		$axios.get("/Pacientes/Query" + qs).then(res => {
    			$$invalidate(3, pacientes = res.data);

    			if (obj.PacienteID != "") {
    				let select = pacientes.find(x => x.id == obj.PacienteID);
    				seleccionarPaciente(select);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarTandas() {
    		$axios.get("/Tandas/GetAll").then(res => {
    			$$invalidate(1, tandas = res.data);
    			$$invalidate(0, obj.tandaID = $dataCita.tandaID || 0, obj);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarHoras() {
    		let params = "?date=" + obj.Fecha + "&" + "tandiID=" + obj.tandaID;

    		if (obj.Fecha == "" || obj.tandaID <= 0 || obj.MedicoID == "" || obj.MedicoID == 0) {
    			$$invalidate(2, horas = []);
    			return;
    		}

    		$axios.get("/Medicos/HorasDisponibles/" + obj.MedicoID + params).then(res => {
    			$$invalidate(2, horas = res.data.map(x => {
    				return {
    					time: x,
    					hora: moment(x, "LT").format("LT")
    				};
    			}));

    			$$invalidate(0, obj.hora = $dataCita.hora || "", obj);
    		}).catch(err => {
    			$$invalidate(2, horas = []);
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function seleccionarPaciente(item) {
    		$$invalidate(0, obj.PacienteID = item.id, obj);
    		$$invalidate(0, obj.Nombre = item.nombre, obj);
    		$$invalidate(0, obj.Apellidos = item.apellidos, obj);
    		$$invalidate(0, obj.Telefono = item.telefono, obj);
    		$$invalidate(0, obj.Direccion = item.direccion, obj);
    		jQuery("#modalPacientes").modal("hide");
    	}

    	function guardarPaciente() {

    		if (obj.PacienteID == "") {
    			$axios.post("/Pacientes", obj).then(res => {
    				$$invalidate(0, obj.PacienteID = res.data.data, obj);
    				crearCita();
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		} else {
    			$axios.put("/Pacientes/" + obj.PacienteID, obj).then(res => {
    				if (res.data.success) {
    					$$invalidate(0, obj.PacienteID = res.data.data, obj);
    					crearCita();
    				} else {
    					console.log(res);
    				}
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	function crearCita() {
    		$$invalidate(0, obj.Fecha = obj.Fecha + "T" + obj.hora, obj);

    		$axios.post("/Citas", obj).then(res => {
    			if (res.data.success) {
    				set_store_value(dataCita, $dataCita = {});

    				$toast(5000).fire({
    					icon: "success",
    					title: "La cita fue creada con exito"
    				});

    				push("/Cita/Gestionar");
    			} else {
    				console.log(res);

    				sweetalert2_all.fire({
    					title: "Error",
    					text: "Ocurrio un error al crear la cita, intente de nuevo",
    					icon: "error"
    				});
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<Crear> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Crear", $$slots, []);

    	function input0_input_handler() {
    		obj.Nombre = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function input1_input_handler() {
    		obj.Apellidos = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function input2_input_handler() {
    		obj.Telefono = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function input3_input_handler() {
    		obj.Correo = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function textarea0_input_handler() {
    		obj.Direccion = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function input4_input_handler() {
    		obj.Fecha = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	const change_handler = () => {
    		cargarHoras();
    	};

    	function select0_change_handler() {
    		obj.tandaID = select_value(this);
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function select1_change_handler() {
    		obj.MedicoID = select_value(this);
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function select2_change_handler() {
    		obj.hora = select_value(this);
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function textarea1_input_handler() {
    		obj.Observaciones = this.value;
    		$$invalidate(0, obj);
    		$$invalidate(1, tandas);
    	}

    	function input6_input_handler() {
    		busquedaPacientes = this.value;
    		$$invalidate(5, busquedaPacientes);
    	}

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		push,
    		activePage,
    		dataCita,
    		axios: axios$2,
    		session,
    		errorConexion,
    		toast,
    		onMount,
    		moment,
    		Swal: sweetalert2_all,
    		data,
    		obj,
    		tandas,
    		horas,
    		pacientes,
    		medicos,
    		busquedaPacientes,
    		cargarMedicos,
    		cargarPacientes,
    		cargarTandas,
    		cargarHoras,
    		seleccionarPaciente,
    		guardarPaciente,
    		crearCita,
    		$axios,
    		$session,
    		$activePage,
    		$dataCita,
    		faltaLaTanda,
    		$errorConexion,
    		$toast
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) data = $$props.data;
    		if ("obj" in $$props) $$invalidate(0, obj = $$props.obj);
    		if ("tandas" in $$props) $$invalidate(1, tandas = $$props.tandas);
    		if ("horas" in $$props) $$invalidate(2, horas = $$props.horas);
    		if ("pacientes" in $$props) $$invalidate(3, pacientes = $$props.pacientes);
    		if ("medicos" in $$props) $$invalidate(4, medicos = $$props.medicos);
    		if ("busquedaPacientes" in $$props) $$invalidate(5, busquedaPacientes = $$props.busquedaPacientes);
    		if ("faltaLaTanda" in $$props) $$invalidate(6, faltaLaTanda = $$props.faltaLaTanda);
    	};

    	let faltaLaTanda;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*obj*/ 1) {
    			 $$invalidate(6, faltaLaTanda = obj.tandaID == 0 || obj.tandaID == undefined);
    		}
    	};

    	return [
    		obj,
    		tandas,
    		horas,
    		pacientes,
    		medicos,
    		busquedaPacientes,
    		faltaLaTanda,
    		cargarPacientes,
    		cargarHoras,
    		seleccionarPaciente,
    		guardarPaciente,
    		$axios,
    		$session,
    		$activePage,
    		$dataCita,
    		$errorConexion,
    		$toast,
    		data,
    		cargarMedicos,
    		cargarTandas,
    		crearCita,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		textarea0_input_handler,
    		input4_input_handler,
    		change_handler,
    		select0_change_handler,
    		select1_change_handler,
    		select2_change_handler,
    		textarea1_input_handler,
    		input6_input_handler
    	];
    }

    class Crear extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Crear",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\Pages\Cita\Gestion.svelte generated by Svelte v3.23.0 */

    const { console: console_1$5 } = globals;
    const file$7 = "src\\Pages\\Cita\\Gestion.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[47] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[47] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[47] = list[i];
    	return child_ctx;
    }

    // (207:18) {#each especialidades as item}
    function create_each_block_4$2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[47].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[47].id;
    			option.value = option.__value;
    			add_location(option, file$7, 207, 18, 5527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*especialidades*/ 2 && t_value !== (t_value = /*item*/ ctx[47].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*especialidades*/ 2 && option_value_value !== (option_value_value = /*item*/ ctx[47].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$2.name,
    		type: "each",
    		source: "(207:18) {#each especialidades as item}",
    		ctx
    	});

    	return block;
    }

    // (263:18) {#each tandas as item}
    function create_each_block_3$3(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[47].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[47].id;
    			option.value = option.__value;
    			add_location(option, file$7, 263, 18, 8017);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tandas*/ 8 && t_value !== (t_value = /*item*/ ctx[47].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*tandas*/ 8 && option_value_value !== (option_value_value = /*item*/ ctx[47].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$3.name,
    		type: "each",
    		source: "(263:18) {#each tandas as item}",
    		ctx
    	});

    	return block;
    }

    // (285:16) {#each listado as item}
    function create_each_block_2$3(ctx) {
    	let tr;
    	let td0;
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let td1;
    	let t1_value = /*item*/ ctx[47].name + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = /*item*/ ctx[47].perfil + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5_value = /*item*/ ctx[47].phoneNumber + "";
    	let t5;
    	let t6;
    	let td4;
    	let button0;
    	let i0;
    	let t7;
    	let t8;
    	let button1;
    	let i1;
    	let t9;
    	let t10;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[37](/*item*/ ctx[47], ...args);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[38](/*item*/ ctx[47], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = text(t5_value);
    			t6 = space();
    			td4 = element("td");
    			button0 = element("button");
    			i0 = element("i");
    			t7 = text("\r\n                        Perfil");
    			t8 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t9 = text("\r\n                        Crear cita");
    			t10 = space();
    			if (img.src !== (img_src_value = "assets/img/products/item%20(1).jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "avatar-img avatar-sm rounded-circle");
    			attr_dev(img, "alt", "");
    			add_location(img, file$7, 289, 24, 8923);
    			attr_dev(div, "class", "avatar avatar-sm ");
    			add_location(div, file$7, 288, 22, 8866);
    			add_location(td0, file$7, 287, 20, 8838);
    			add_location(td1, file$7, 295, 20, 9182);
    			add_location(td2, file$7, 296, 20, 9224);
    			add_location(td3, file$7, 297, 20, 9268);
    			attr_dev(i0, "class", "mdi mdi-contacts");
    			add_location(i0, file$7, 301, 24, 9507);
    			attr_dev(button0, "class", "btn btn-outline-primary btn-sm");
    			add_location(button0, file$7, 299, 22, 9372);
    			attr_dev(i1, "class", "mdi mdi-calendar-plus");
    			add_location(i1, file$7, 306, 24, 9761);
    			attr_dev(button1, "class", "btn btn-outline-success btn-sm");
    			add_location(button1, file$7, 304, 22, 9626);
    			set_style(td4, "text-align", "right");
    			add_location(td4, file$7, 298, 20, 9317);
    			add_location(tr, file$7, 286, 18, 8812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div);
    			append_dev(div, img);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, button0);
    			append_dev(button0, i0);
    			append_dev(button0, t7);
    			append_dev(td4, t8);
    			append_dev(td4, button1);
    			append_dev(button1, i1);
    			append_dev(button1, t9);
    			append_dev(tr, t10);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", click_handler, false, false, false),
    					listen_dev(button1, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*listado*/ 4 && t1_value !== (t1_value = /*item*/ ctx[47].name + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*listado*/ 4 && t3_value !== (t3_value = /*item*/ ctx[47].perfil + "")) set_data_dev(t3, t3_value);
    			if (dirty[0] & /*listado*/ 4 && t5_value !== (t5_value = /*item*/ ctx[47].phoneNumber + "")) set_data_dev(t5, t5_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(285:16) {#each listado as item}",
    		ctx
    	});

    	return block;
    }

    // (365:16) {#each tandas as i}
    function create_each_block_1$3(ctx) {
    	let option;
    	let t_value = /*i*/ ctx[42].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*i*/ ctx[42].id;
    			option.value = option.__value;
    			add_location(option, file$7, 365, 16, 11604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tandas*/ 8 && t_value !== (t_value = /*i*/ ctx[42].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*tandas*/ 8 && option_value_value !== (option_value_value = /*i*/ ctx[42].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(365:16) {#each tandas as i}",
    		ctx
    	});

    	return block;
    }

    // (373:10) {#if horasDisponibles.length <= 0}
    function create_if_block$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad con este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$7, 373, 12, 11849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(373:10) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (378:10) {#each horasDisponibles as i}
    function create_each_block$3(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*i*/ ctx[42].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[41](/*i*/ ctx[42], ...args);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Seleccionar";
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$7, 380, 14, 12153);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$7, 379, 12, 12123);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$7, 383, 14, 12256);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$7, 382, 12, 12219);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$7, 378, 10, 12039);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 16 && t0_value !== (t0_value = /*i*/ ctx[42].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(378:10) {#each horasDisponibles as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div14;
    	let h4;
    	let t3;
    	let div13;
    	let div10;
    	let div9;
    	let div8;
    	let div0;
    	let label0;
    	let t5;
    	let input0;
    	let t6;
    	let div1;
    	let label1;
    	let t8;
    	let select0;
    	let option0;
    	let option0_value_value;
    	let t10;
    	let div6;
    	let label2;
    	let t12;
    	let input1;
    	let t13;
    	let div5;
    	let div2;
    	let input2;
    	let input2_value_value;
    	let t14;
    	let label3;
    	let span1;
    	let span0;
    	let t16;
    	let div3;
    	let input3;
    	let input3_value_value;
    	let t17;
    	let label4;
    	let span3;
    	let span2;
    	let t19;
    	let div4;
    	let input4;
    	let input4_value_value;
    	let t20;
    	let label5;
    	let span5;
    	let span4;
    	let t22;
    	let div7;
    	let label6;
    	let t24;
    	let select1;
    	let option1;
    	let option1_value_value;
    	let t26;
    	let button0;
    	let t28;
    	let div12;
    	let div11;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t29;
    	let th1;
    	let t31;
    	let th2;
    	let t33;
    	let th3;
    	let t35;
    	let th4;
    	let t36;
    	let tbody;
    	let t37;
    	let div25;
    	let div24;
    	let div23;
    	let div15;
    	let h5;
    	let i;
    	let t38;
    	let t39;
    	let button1;
    	let span6;
    	let t41;
    	let div22;
    	let div20;
    	let div17;
    	let div16;
    	let label7;
    	let t43;
    	let input5;
    	let t44;
    	let div19;
    	let div18;
    	let label8;
    	let t46;
    	let select2;
    	let option2;
    	let option2_value_value;
    	let t48;
    	let div21;
    	let t49;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_4 = /*especialidades*/ ctx[1];
    	validate_each_argument(each_value_4);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_4[i] = create_each_block_4$2(get_each_context_4$2(ctx, each_value_4, i));
    	}

    	let each_value_3 = /*tandas*/ ctx[3];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$3(get_each_context_3$3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*listado*/ ctx[2];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*tandas*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	let if_block = /*horasDisponibles*/ ctx[4].length <= 0 && create_if_block$4(ctx);
    	let each_value = /*horasDisponibles*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div14 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Gestión de citas";
    			t3 = space();
    			div13 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Médico";
    			t5 = space();
    			input0 = element("input");
    			t6 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Especialidad";
    			t8 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Todas";

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t10 = space();
    			div6 = element("div");
    			label2 = element("label");
    			label2.textContent = "Fecha";
    			t12 = space();
    			input1 = element("input");
    			t13 = space();
    			div5 = element("div");
    			div2 = element("div");
    			input2 = element("input");
    			t14 = space();
    			label3 = element("label");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "Hoy";
    			t16 = space();
    			div3 = element("div");
    			input3 = element("input");
    			t17 = space();
    			label4 = element("label");
    			span3 = element("span");
    			span2 = element("span");
    			span2.textContent = "Mañana";
    			t19 = space();
    			div4 = element("div");
    			input4 = element("input");
    			t20 = space();
    			label5 = element("label");
    			span5 = element("span");
    			span4 = element("span");
    			span4.textContent = "En dos días";
    			t22 = space();
    			div7 = element("div");
    			label6 = element("label");
    			label6.textContent = "Tanda";
    			t24 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "Todas";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t26 = space();
    			button0 = element("button");
    			button0.textContent = "Limpiar";
    			t28 = space();
    			div12 = element("div");
    			div11 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t29 = space();
    			th1 = element("th");
    			th1.textContent = "Nombre";
    			t31 = space();
    			th2 = element("th");
    			th2.textContent = "Especialidad";
    			t33 = space();
    			th3 = element("th");
    			th3.textContent = "Telefono";
    			t35 = space();
    			th4 = element("th");
    			t36 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t37 = space();
    			div25 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			div15 = element("div");
    			h5 = element("h5");
    			i = element("i");
    			t38 = text("\r\n          Crear cita");
    			t39 = space();
    			button1 = element("button");
    			span6 = element("span");
    			span6.textContent = "×";
    			t41 = space();
    			div22 = element("div");
    			div20 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			label7 = element("label");
    			label7.textContent = "Fecha";
    			t43 = space();
    			input5 = element("input");
    			t44 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label8 = element("label");
    			label8.textContent = "Tanda";
    			t46 = space();
    			select2 = element("select");
    			option2 = element("option");
    			option2.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t48 = space();
    			div21 = element("div");
    			if (if_block) if_block.c();
    			t49 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h4, file$7, 192, 6, 4713);
    			attr_dev(label0, "class", "font-secondary");
    			add_location(label0, file$7, 198, 16, 4921);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$7, 199, 16, 4983);
    			attr_dev(div0, "class", "form-group ");
    			add_location(div0, file$7, 197, 14, 4878);
    			attr_dev(label1, "class", "font-secondary");
    			add_location(label1, file$7, 202, 16, 5168);
    			option0.__value = option0_value_value = 0;
    			option0.value = option0.__value;
    			add_location(option0, file$7, 205, 18, 5425);
    			attr_dev(select0, "class", "form-control select2");
    			set_style(select0, "width", "100%");
    			attr_dev(select0, "id", "sltEspecialidad");
    			if (/*filter*/ ctx[5].PerfilID === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[27].call(select0));
    			add_location(select0, file$7, 203, 16, 5236);
    			attr_dev(div1, "class", "form-group ");
    			add_location(div1, file$7, 201, 14, 5125);
    			attr_dev(label2, "for", "inputAddress2");
    			add_location(label2, file$7, 212, 16, 5707);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control mb-2");
    			attr_dev(input1, "id", "inputAddress2");
    			add_location(input1, file$7, 213, 16, 5765);
    			attr_dev(input2, "id", "radio-new1");
    			attr_dev(input2, "name", "tiempo");
    			attr_dev(input2, "type", "radio");
    			input2.__value = input2_value_value = 0;
    			input2.value = input2.__value;
    			/*$$binding_groups*/ ctx[32][0].push(input2);
    			add_location(input2, file$7, 221, 20, 6086);
    			attr_dev(span0, "class", "h6 d-block");
    			add_location(span0, file$7, 227, 24, 6425);
    			attr_dev(span1, "class", "radio-content");
    			add_location(span1, file$7, 226, 22, 6371);
    			attr_dev(label3, "for", "radio-new1");
    			set_style(label3, "height", "40px");
    			set_style(label3, "padding", "3px 10px");
    			attr_dev(label3, "class", "svelte-ytmxyb");
    			add_location(label3, file$7, 223, 20, 6236);
    			attr_dev(div2, "class", "option-box svelte-ytmxyb");
    			add_location(div2, file$7, 220, 18, 6040);
    			attr_dev(input3, "id", "radio-new2");
    			attr_dev(input3, "name", "tiempo");
    			attr_dev(input3, "type", "radio");
    			input3.__value = input3_value_value = 1;
    			input3.value = input3.__value;
    			/*$$binding_groups*/ ctx[32][0].push(input3);
    			add_location(input3, file$7, 232, 20, 6613);
    			attr_dev(span2, "class", "h6 d-block");
    			add_location(span2, file$7, 238, 24, 6952);
    			attr_dev(span3, "class", "radio-content");
    			add_location(span3, file$7, 237, 22, 6898);
    			attr_dev(label4, "for", "radio-new2");
    			set_style(label4, "height", "40px");
    			set_style(label4, "padding", "3px 10px");
    			attr_dev(label4, "class", "svelte-ytmxyb");
    			add_location(label4, file$7, 234, 20, 6763);
    			attr_dev(div3, "class", "option-box svelte-ytmxyb");
    			add_location(div3, file$7, 231, 18, 6567);
    			attr_dev(input4, "id", "radio-new3");
    			attr_dev(input4, "name", "tiempo");
    			attr_dev(input4, "type", "radio");
    			input4.__value = input4_value_value = 2;
    			input4.value = input4.__value;
    			/*$$binding_groups*/ ctx[32][0].push(input4);
    			add_location(input4, file$7, 243, 20, 7143);
    			attr_dev(span4, "class", "h6 d-block");
    			add_location(span4, file$7, 249, 24, 7482);
    			attr_dev(span5, "class", "radio-content");
    			add_location(span5, file$7, 248, 22, 7428);
    			attr_dev(label5, "for", "radio-new3");
    			set_style(label5, "height", "40px");
    			set_style(label5, "padding", "3px 10px");
    			attr_dev(label5, "class", "svelte-ytmxyb");
    			add_location(label5, file$7, 245, 20, 7293);
    			attr_dev(div4, "class", "option-box svelte-ytmxyb");
    			add_location(div4, file$7, 242, 18, 7097);
    			attr_dev(div5, "class", "contenedor-dias");
    			add_location(div5, file$7, 219, 16, 5991);
    			attr_dev(div6, "class", "form-group");
    			add_location(div6, file$7, 211, 14, 5665);
    			attr_dev(label6, "class", "font-secondary");
    			add_location(label6, file$7, 258, 16, 7721);
    			option1.__value = option1_value_value = 0;
    			option1.value = option1.__value;
    			option1.selected = true;
    			add_location(option1, file$7, 261, 18, 7914);
    			attr_dev(select1, "class", "form-control");
    			if (/*filter*/ ctx[5].TandaID === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[35].call(select1));
    			add_location(select1, file$7, 259, 16, 7782);
    			attr_dev(div7, "class", "form-group ");
    			add_location(div7, file$7, 257, 14, 7678);
    			attr_dev(button0, "class", "btn btn-secondary btn-block");
    			add_location(button0, file$7, 267, 14, 8155);
    			attr_dev(div8, "class", "card-body");
    			add_location(div8, file$7, 196, 12, 4839);
    			attr_dev(div9, "class", "card");
    			add_location(div9, file$7, 195, 10, 4807);
    			attr_dev(div10, "class", "col-lg-4");
    			add_location(div10, file$7, 194, 8, 4773);
    			add_location(th0, file$7, 276, 18, 8495);
    			add_location(th1, file$7, 277, 18, 8521);
    			add_location(th2, file$7, 278, 18, 8556);
    			add_location(th3, file$7, 279, 18, 8597);
    			add_location(th4, file$7, 280, 18, 8634);
    			add_location(tr, file$7, 275, 16, 8471);
    			add_location(thead, file$7, 274, 14, 8446);
    			add_location(tbody, file$7, 283, 14, 8703);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$7, 273, 12, 8382);
    			attr_dev(div11, "class", "table-responsive");
    			add_location(div11, file$7, 272, 10, 8338);
    			attr_dev(div12, "class", "col-lg-8");
    			add_location(div12, file$7, 271, 8, 8304);
    			attr_dev(div13, "class", "row");
    			add_location(div13, file$7, 193, 6, 4746);
    			attr_dev(div14, "class", "container-fluid mt-3");
    			add_location(div14, file$7, 191, 4, 4671);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$7, 190, 2, 4634);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$7, 188, 0, 4591);
    			attr_dev(i, "class", "mdi mdi-calendar-plus");
    			add_location(i, file$7, 337, 10, 10479);
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalCrearCitaLabel");
    			add_location(h5, file$7, 336, 8, 10418);
    			attr_dev(span6, "aria-hidden", "true");
    			add_location(span6, file$7, 345, 10, 10695);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "close");
    			attr_dev(button1, "data-dismiss", "modal");
    			attr_dev(button1, "aria-label", "Close");
    			add_location(button1, file$7, 340, 8, 10563);
    			attr_dev(div15, "class", "modal-header");
    			add_location(div15, file$7, 335, 6, 10382);
    			attr_dev(label7, "for", "inputAddress");
    			add_location(label7, file$7, 353, 14, 10956);
    			attr_dev(input5, "type", "date");
    			attr_dev(input5, "class", "form-control form-control-sm");
    			add_location(input5, file$7, 354, 14, 11012);
    			attr_dev(div16, "class", "form-group");
    			add_location(div16, file$7, 352, 12, 10916);
    			attr_dev(div17, "class", "col-lg-6");
    			add_location(div17, file$7, 351, 10, 10880);
    			attr_dev(label8, "class", "font-secondary");
    			add_location(label8, file$7, 360, 14, 11287);
    			option2.__value = option2_value_value = 0;
    			option2.value = option2.__value;
    			option2.disabled = true;
    			add_location(option2, file$7, 363, 16, 11498);
    			attr_dev(select2, "class", "form-control form-control-sm");
    			if (/*filterCita*/ ctx[6].TandaID === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[40].call(select2));
    			add_location(select2, file$7, 361, 14, 11346);
    			attr_dev(div18, "class", "form-group ");
    			add_location(div18, file$7, 359, 12, 11246);
    			attr_dev(div19, "class", "col-lg-6");
    			add_location(div19, file$7, 358, 10, 11210);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$7, 350, 8, 10851);
    			attr_dev(div21, "class", "list-group list");
    			add_location(div21, file$7, 371, 8, 11760);
    			attr_dev(div22, "class", "modal-body");
    			set_style(div22, "height", "100%");
    			set_style(div22, "top", "0");
    			set_style(div22, "overflow", "auto");
    			add_location(div22, file$7, 348, 6, 10769);
    			attr_dev(div23, "class", "modal-content");
    			add_location(div23, file$7, 334, 4, 10347);
    			attr_dev(div24, "class", "modal-dialog");
    			attr_dev(div24, "role", "document");
    			add_location(div24, file$7, 333, 2, 10298);
    			attr_dev(div25, "class", "modal fade modal-slide-right");
    			attr_dev(div25, "id", "modalCrearCita");
    			attr_dev(div25, "tabindex", "-1");
    			attr_dev(div25, "role", "dialog");
    			attr_dev(div25, "aria-labelledby", "modalCrearCitaLabel");
    			set_style(div25, "display", "none");
    			set_style(div25, "padding-right", "16px");
    			attr_dev(div25, "aria-modal", "true");
    			add_location(div25, file$7, 325, 0, 10083);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div14);
    			append_dev(div14, h4);
    			append_dev(div14, t3);
    			append_dev(div14, div13);
    			append_dev(div13, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div0);
    			append_dev(div0, label0);
    			append_dev(div0, t5);
    			append_dev(div0, input0);
    			set_input_value(input0, /*filter*/ ctx[5].Nombre);
    			append_dev(div8, t6);
    			append_dev(div8, div1);
    			append_dev(div1, label1);
    			append_dev(div1, t8);
    			append_dev(div1, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(select0, null);
    			}

    			select_option(select0, /*filter*/ ctx[5].PerfilID);
    			append_dev(div8, t10);
    			append_dev(div8, div6);
    			append_dev(div6, label2);
    			append_dev(div6, t12);
    			append_dev(div6, input1);
    			set_input_value(input1, /*filter*/ ctx[5].FechaCita);
    			append_dev(div6, t13);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, input2);
    			input2.checked = input2.__value === /*dia*/ ctx[0];
    			append_dev(div2, t14);
    			append_dev(div2, label3);
    			append_dev(label3, span1);
    			append_dev(span1, span0);
    			append_dev(div5, t16);
    			append_dev(div5, div3);
    			append_dev(div3, input3);
    			input3.checked = input3.__value === /*dia*/ ctx[0];
    			append_dev(div3, t17);
    			append_dev(div3, label4);
    			append_dev(label4, span3);
    			append_dev(span3, span2);
    			append_dev(div5, t19);
    			append_dev(div5, div4);
    			append_dev(div4, input4);
    			input4.checked = input4.__value === /*dia*/ ctx[0];
    			append_dev(div4, t20);
    			append_dev(div4, label5);
    			append_dev(label5, span5);
    			append_dev(span5, span4);
    			append_dev(div8, t22);
    			append_dev(div8, div7);
    			append_dev(div7, label6);
    			append_dev(div7, t24);
    			append_dev(div7, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select1, null);
    			}

    			select_option(select1, /*filter*/ ctx[5].TandaID);
    			append_dev(div8, t26);
    			append_dev(div8, button0);
    			append_dev(div13, t28);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t29);
    			append_dev(tr, th1);
    			append_dev(tr, t31);
    			append_dev(tr, th2);
    			append_dev(tr, t33);
    			append_dev(tr, th3);
    			append_dev(tr, t35);
    			append_dev(tr, th4);
    			append_dev(table, t36);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(tbody, null);
    			}

    			insert_dev(target, t37, anchor);
    			insert_dev(target, div25, anchor);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div15);
    			append_dev(div15, h5);
    			append_dev(h5, i);
    			append_dev(h5, t38);
    			append_dev(div15, t39);
    			append_dev(div15, button1);
    			append_dev(button1, span6);
    			append_dev(div23, t41);
    			append_dev(div23, div22);
    			append_dev(div22, div20);
    			append_dev(div20, div17);
    			append_dev(div17, div16);
    			append_dev(div16, label7);
    			append_dev(div16, t43);
    			append_dev(div16, input5);
    			set_input_value(input5, /*filterCita*/ ctx[6].FechaCita);
    			append_dev(div20, t44);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label8);
    			append_dev(div18, t46);
    			append_dev(div18, select2);
    			append_dev(select2, option2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select2, null);
    			}

    			select_option(select2, /*filterCita*/ ctx[6].TandaID);
    			append_dev(div22, t48);
    			append_dev(div22, div21);
    			if (if_block) if_block.m(div21, null);
    			append_dev(div21, t49);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div21, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[25]),
    					listen_dev(input0, "input", /*input_handler*/ ctx[26], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[27]),
    					listen_dev(select0, "change", /*change_handler*/ ctx[28], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[29]),
    					listen_dev(input1, "input", /*input_handler_1*/ ctx[30], false, false, false),
    					listen_dev(input2, "change", /*elegirTiempo*/ ctx[8], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[31]),
    					listen_dev(input3, "change", /*elegirTiempo*/ ctx[8], false, false, false),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[33]),
    					listen_dev(input4, "change", /*elegirTiempo*/ ctx[8], false, false, false),
    					listen_dev(input4, "change", /*input4_change_handler*/ ctx[34]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[35]),
    					listen_dev(select1, "change", /*change_handler_1*/ ctx[36], false, false, false),
    					listen_dev(button0, "click", /*limpiarFiltro*/ ctx[13], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[39]),
    					listen_dev(input5, "change", /*buscarDisponibilidadHorario*/ ctx[7], false, false, false),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[40]),
    					listen_dev(select2, "change", /*buscarDisponibilidadHorario*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filter, especialidades*/ 34 && input0.value !== /*filter*/ ctx[5].Nombre) {
    				set_input_value(input0, /*filter*/ ctx[5].Nombre);
    			}

    			if (dirty[0] & /*especialidades*/ 2) {
    				each_value_4 = /*especialidades*/ ctx[1];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$2(ctx, each_value_4, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_4$2(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_4.length;
    			}

    			if (dirty[0] & /*filter, especialidades*/ 34) {
    				select_option(select0, /*filter*/ ctx[5].PerfilID);
    			}

    			if (dirty[0] & /*filter, especialidades*/ 34) {
    				set_input_value(input1, /*filter*/ ctx[5].FechaCita);
    			}

    			if (dirty[0] & /*dia*/ 1) {
    				input2.checked = input2.__value === /*dia*/ ctx[0];
    			}

    			if (dirty[0] & /*dia*/ 1) {
    				input3.checked = input3.__value === /*dia*/ ctx[0];
    			}

    			if (dirty[0] & /*dia*/ 1) {
    				input4.checked = input4.__value === /*dia*/ ctx[0];
    			}

    			if (dirty[0] & /*tandas*/ 8) {
    				each_value_3 = /*tandas*/ ctx[3];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$3(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$3(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*filter, especialidades*/ 34) {
    				select_option(select1, /*filter*/ ctx[5].TandaID);
    			}

    			if (dirty[0] & /*crearCita, listado, irAlPerfil*/ 2564) {
    				each_value_2 = /*listado*/ ctx[2];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$3(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*filterCita, tandas*/ 72) {
    				set_input_value(input5, /*filterCita*/ ctx[6].FechaCita);
    			}

    			if (dirty[0] & /*tandas*/ 8) {
    				each_value_1 = /*tandas*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*filterCita, tandas*/ 72) {
    				select_option(select2, /*filterCita*/ ctx[6].TandaID);
    			}

    			if (/*horasDisponibles*/ ctx[4].length <= 0) {
    				if (if_block) ; else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(div21, t49);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*irACita, horasDisponibles*/ 1040) {
    				each_value = /*horasDisponibles*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div21, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_4, detaching);
    			/*$$binding_groups*/ ctx[32][0].splice(/*$$binding_groups*/ ctx[32][0].indexOf(input2), 1);
    			/*$$binding_groups*/ ctx[32][0].splice(/*$$binding_groups*/ ctx[32][0].indexOf(input3), 1);
    			/*$$binding_groups*/ ctx[32][0].splice(/*$$binding_groups*/ ctx[32][0].indexOf(input4), 1);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			if (detaching) detach_dev(t37);
    			if (detaching) detach_dev(div25);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $axios;
    	let $session;
    	let $activePage;
    	let $dataCita;
    	let $errorConexion;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(14, $axios = $$value));
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(15, $session = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(16, $activePage = $$value));
    	validate_store(dataCita, "dataCita");
    	component_subscribe($$self, dataCita, $$value => $$invalidate(17, $dataCita = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(18, $errorConexion = $$value));

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	let busqueda = "";
    	let dia = -1;
    	let especialidades = [];
    	let listado = [];
    	let tandas = [];
    	let horasDisponibles = [];
    	let horasCompleta = [];

    	let filter = {
    		Nombre: "",
    		PerfilID: 0,
    		FechaCita: "",
    		TandaID: 0
    	};

    	let filterCita = { MedicoId: "", FechaCita: "", TandaID: 0 };

    	if ($activePage == "citas.crear") {
    		limpiarFiltro();
    	}

    	set_store_value(activePage, $activePage = "gestor");

    	onMount(() => {
    		if ($dataCita.fechaCita != undefined) {
    			$$invalidate(5, filter.FechaCita = $dataCita.fechaCita, filter);
    			$$invalidate(5, filter.TandaID = $dataCita.tandaID, filter);
    		}

    		jQuery("#sltEspecialidad").select2();

    		jQuery("#sltEspecialidad").on("select2:select", e => {
    			let data = e.params.data;
    			$$invalidate(5, filter.PerfilID = parseInt(data.id), filter);
    			filtrar("general");
    		});

    		marcarFecha();
    		cargarMedicos();
    		cargarEspecialidades();
    		cargarTandas();
    	});

    	function cargarMedicos() {
    		var qs = new URLSearchParams(filter).toString();

    		$axios.get("/Medicos/Query?" + qs).then(res => {
    			$$invalidate(2, listado = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarEspecialidades() {
    		$axios.get("/Perfiles/GetAll").then(res => {
    			$$invalidate(1, especialidades = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarTandas() {
    		$axios.get("/Tandas/GetAll").then(res => {
    			$$invalidate(3, tandas = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function buscarDisponibilidadHorario(idMedico) {
    		if (typeof idMedico === "string") {
    			$$invalidate(6, filterCita.MedicoId = idMedico, filterCita);
    		}

    		if (filterCita.FechaCita == "") {
    			$$invalidate(4, horasDisponibles = []);
    			return;
    		}

    		let params = "date=" + filterCita.FechaCita + "&" + "tandiId=" + filterCita.TandaID;

    		$axios.get("/Medicos/HorasDisponibles/" + filterCita.MedicoId + "?" + params).then(res => {
    			$$invalidate(4, horasDisponibles = res.data.map(e => {
    				return {
    					time: e,
    					hora: moment(e, "LT").format("LT")
    				};
    			}));
    		}).catch(err => {
    			$$invalidate(4, horasDisponibles = []);
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function elegirTiempo(e) {
    		let countDia = parseInt(e.target.value);
    		let date = moment();
    		date.add(moment.duration(countDia, "d"));
    		$$invalidate(5, filter.FechaCita = date.format("YYYY-MM-DD"), filter);
    		cargarMedicos();
    	}

    	function crearCita(id) {
    		$$invalidate(6, filterCita.TandaID = filter.TandaID, filterCita);
    		$$invalidate(6, filterCita.FechaCita = filter.FechaCita || moment().format("YYYY-MM-DD"), filterCita);
    		buscarDisponibilidadHorario(id);
    		jQuery("#modalCrearCita").modal("show");
    	}

    	function irACita(time) {
    		set_store_value(dataCita, $dataCita = {
    			fechaCita: filterCita.FechaCita,
    			tandaID: filterCita.TandaID,
    			hora: time,
    			medicoId: filterCita.MedicoId,
    			pacienteId: ""
    		});

    		push("/Cita/Crear");
    	}

    	function irAlPerfil(id) {
    		set_store_value(dataCita, $dataCita = {
    			fechaCita: filter.FechaCita,
    			tandaID: filter.TandaID,
    			hora: "",
    			medicoId: id,
    			pacienteId: ""
    		});

    		push("/Medico/Perfil/" + id);
    	}

    	function filtrar(tipo) {
    		if (tipo == "limpiar") {
    			$$invalidate(0, dia = -1);
    		}

    		if (tipo == "fecha") {
    			marcarFecha();
    		}

    		cargarMedicos();
    	}

    	function marcarFecha() {
    		if (filter.FechaCita == moment().format("YYYY-MM-DD")) {
    			$$invalidate(0, dia = 0);
    		} else if (filter.FechaCita == moment().add(moment.duration(1, "d")).format("YYYY-MM-DD")) {
    			$$invalidate(0, dia = 1);
    		} else if (filter.FechaCita == moment().add(moment.duration(2, "d")).format("YYYY-MM-DD")) {
    			$$invalidate(0, dia = 2);
    		} else {
    			$$invalidate(0, dia = -1);
    		}
    	}

    	function limpiarFiltro() {
    		$$invalidate(5, filter.Nombre = "", filter);
    		$$invalidate(5, filter.PerfilID = 0, filter);
    		$$invalidate(5, filter.FechaCita = "", filter);
    		$$invalidate(5, filter.TandaID = 0, filter);
    		set_store_value(dataCita, $dataCita = {});
    		jQuery("#sltEspecialidad").val(0).trigger("change");
    		filtrar("limpiar");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Gestion> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Gestion", $$slots, []);
    	const $$binding_groups = [[]];

    	function input0_input_handler() {
    		filter.Nombre = this.value;
    		$$invalidate(5, filter);
    		$$invalidate(1, especialidades);
    	}

    	const input_handler = () => filtrar("medico");

    	function select0_change_handler() {
    		filter.PerfilID = select_value(this);
    		$$invalidate(5, filter);
    		$$invalidate(1, especialidades);
    	}

    	const change_handler = () => filtrar("especialidad");

    	function input1_input_handler() {
    		filter.FechaCita = this.value;
    		$$invalidate(5, filter);
    		$$invalidate(1, especialidades);
    	}

    	const input_handler_1 = () => filtrar("fecha");

    	function input2_change_handler() {
    		dia = this.__value;
    		$$invalidate(0, dia);
    	}

    	function input3_change_handler() {
    		dia = this.__value;
    		$$invalidate(0, dia);
    	}

    	function input4_change_handler() {
    		dia = this.__value;
    		$$invalidate(0, dia);
    	}

    	function select1_change_handler() {
    		filter.TandaID = select_value(this);
    		$$invalidate(5, filter);
    		$$invalidate(1, especialidades);
    	}

    	const change_handler_1 = () => filtrar("tanda");
    	const click_handler = item => irAlPerfil(item.id);
    	const click_handler_1 = item => crearCita(item.id);

    	function input5_input_handler() {
    		filterCita.FechaCita = this.value;
    		$$invalidate(6, filterCita);
    		$$invalidate(3, tandas);
    	}

    	function select2_change_handler() {
    		filterCita.TandaID = select_value(this);
    		$$invalidate(6, filterCita);
    		$$invalidate(3, tandas);
    	}

    	const click_handler_2 = i => irACita(i.time);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		push,
    		onMount,
    		activePage,
    		dataCita,
    		axios: axios$2,
    		session,
    		errorConexion,
    		moment,
    		Swal: sweetalert2_all,
    		busqueda,
    		dia,
    		especialidades,
    		listado,
    		tandas,
    		horasDisponibles,
    		horasCompleta,
    		filter,
    		filterCita,
    		cargarMedicos,
    		cargarEspecialidades,
    		cargarTandas,
    		buscarDisponibilidadHorario,
    		elegirTiempo,
    		crearCita,
    		irACita,
    		irAlPerfil,
    		filtrar,
    		marcarFecha,
    		limpiarFiltro,
    		$axios,
    		$session,
    		$activePage,
    		$dataCita,
    		$errorConexion
    	});

    	$$self.$inject_state = $$props => {
    		if ("busqueda" in $$props) busqueda = $$props.busqueda;
    		if ("dia" in $$props) $$invalidate(0, dia = $$props.dia);
    		if ("especialidades" in $$props) $$invalidate(1, especialidades = $$props.especialidades);
    		if ("listado" in $$props) $$invalidate(2, listado = $$props.listado);
    		if ("tandas" in $$props) $$invalidate(3, tandas = $$props.tandas);
    		if ("horasDisponibles" in $$props) $$invalidate(4, horasDisponibles = $$props.horasDisponibles);
    		if ("horasCompleta" in $$props) horasCompleta = $$props.horasCompleta;
    		if ("filter" in $$props) $$invalidate(5, filter = $$props.filter);
    		if ("filterCita" in $$props) $$invalidate(6, filterCita = $$props.filterCita);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dia,
    		especialidades,
    		listado,
    		tandas,
    		horasDisponibles,
    		filter,
    		filterCita,
    		buscarDisponibilidadHorario,
    		elegirTiempo,
    		crearCita,
    		irACita,
    		irAlPerfil,
    		filtrar,
    		limpiarFiltro,
    		$axios,
    		$session,
    		$activePage,
    		$dataCita,
    		$errorConexion,
    		busqueda,
    		horasCompleta,
    		cargarMedicos,
    		cargarEspecialidades,
    		cargarTandas,
    		marcarFecha,
    		input0_input_handler,
    		input_handler,
    		select0_change_handler,
    		change_handler,
    		input1_input_handler,
    		input_handler_1,
    		input2_change_handler,
    		$$binding_groups,
    		input3_change_handler,
    		input4_change_handler,
    		select1_change_handler,
    		change_handler_1,
    		click_handler,
    		click_handler_1,
    		input5_input_handler,
    		select2_change_handler,
    		click_handler_2
    	];
    }

    class Gestion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gestion",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\Pages\Usuario\Index.svelte generated by Svelte v3.23.0 */

    const { Object: Object_1$1, console: console_1$6 } = globals;
    const file$8 = "src\\Pages\\Usuario\\Index.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	child_ctx[47] = list;
    	child_ctx[48] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[46] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[57] = list[i];
    	return child_ctx;
    }

    // (302:30) {#if i.isDoctor}
    function create_if_block_2$2(ctx) {
    	let a;
    	let i;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			i = element("i");
    			attr_dev(i, "class", " mdi-24px mdi mdi-doctor");
    			add_location(i, file$8, 303, 32, 8202);
    			attr_dev(a, "href", a_href_value = "#/Medico/Perfil/" + /*i*/ ctx[57].id);
    			add_location(a, file$8, 302, 30, 8135);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*list*/ 8 && a_href_value !== (a_href_value = "#/Medico/Perfil/" + /*i*/ ctx[57].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(302:30) {#if i.isDoctor}",
    		ctx
    	});

    	return block;
    }

    // (289:22) {#each list as i}
    function create_each_block_5$2(ctx) {
    	let tr;
    	let td0;
    	let div1;
    	let div0;
    	let span0;
    	let t0_value = /*i*/ ctx[57].name[0] + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*i*/ ctx[57].name + "";
    	let t2;
    	let t3;
    	let td1;
    	let t4_value = /*i*/ ctx[57].email + "";
    	let t4;
    	let t5;
    	let td2;
    	let div2;
    	let t6;
    	let a0;
    	let i0;
    	let t7;
    	let a1;
    	let i1;
    	let t8;
    	let mounted;
    	let dispose;
    	let if_block = /*i*/ ctx[57].isDoctor && create_if_block_2$2(ctx);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[31](/*i*/ ctx[57], ...args);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[32](/*i*/ ctx[57], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			td1 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td2 = element("td");
    			div2 = element("div");
    			if (if_block) if_block.c();
    			t6 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t7 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t8 = space();
    			attr_dev(span0, "class", "avatar-title rounded-circle ");
    			add_location(span0, file$8, 293, 32, 7666);
    			attr_dev(div0, "class", "avatar avatar-sm");
    			add_location(div0, file$8, 292, 30, 7602);
    			attr_dev(div1, "class", "avatar avatar-sm mr-2 d-block-sm");
    			add_location(div1, file$8, 291, 28, 7524);
    			add_location(span1, file$8, 296, 28, 7831);
    			add_location(td0, file$8, 290, 26, 7490);
    			add_location(td1, file$8, 298, 26, 7913);
    			attr_dev(i0, "class", " mdi-24px mdi mdi-circle-edit-outline");
    			add_location(i0, file$8, 314, 32, 8826);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "data-toggle", "modal");
    			set_style(a0, "cursor", "pointer");
    			attr_dev(a0, "data-placement", "top");
    			attr_dev(a0, "data-target", "#modalUsuario");
    			attr_dev(a0, "data-original-title", "Modificar usuario");
    			attr_dev(a0, "class", "icon-table hover-cursor");
    			add_location(a0, file$8, 306, 30, 8345);
    			attr_dev(i1, "class", " mdi-24px mdi mdi-security");
    			add_location(i1, file$8, 323, 32, 9338);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "data-toggle", "modal");
    			attr_dev(a1, "data-target", "#modalRoles");
    			attr_dev(a1, "data-placement", "bottom");
    			attr_dev(a1, "title", "Asignar Roles");
    			attr_dev(a1, "class", "icon-rol svelte-lim7lj");
    			add_location(a1, file$8, 316, 30, 8945);
    			set_style(div2, "width", "150px");
    			set_style(div2, "text-align", "right");
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$8, 300, 28, 7993);
    			add_location(td2, file$8, 299, 26, 7959);
    			add_location(tr, file$8, 289, 24, 7458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(td0, t1);
    			append_dev(td0, span1);
    			append_dev(span1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td1);
    			append_dev(td1, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td2);
    			append_dev(td2, div2);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t6);
    			append_dev(div2, a0);
    			append_dev(a0, i0);
    			append_dev(div2, t7);
    			append_dev(div2, a1);
    			append_dev(a1, i1);
    			append_dev(tr, t8);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", click_handler, false, false, false),
    					listen_dev(a1, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*list*/ 8 && t0_value !== (t0_value = /*i*/ ctx[57].name[0] + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*list*/ 8 && t2_value !== (t2_value = /*i*/ ctx[57].name + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*list*/ 8 && t4_value !== (t4_value = /*i*/ ctx[57].email + "")) set_data_dev(t4, t4_value);

    			if (/*i*/ ctx[57].isDoctor) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					if_block.m(div2, t6);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$2.name,
    		type: "each",
    		source: "(289:22) {#each list as i}",
    		ctx
    	});

    	return block;
    }

    // (378:18) {#each prefijos as item}
    function create_each_block_4$3(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[46].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[46].value;
    			option.value = option.__value;
    			add_location(option, file$8, 378, 20, 11062);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$3.name,
    		type: "each",
    		source: "(378:18) {#each prefijos as item}",
    		ctx
    	});

    	return block;
    }

    // (422:12) {#if userID == ""}
    function create_if_block_1$3(ctx) {
    	let div1;
    	let div0;
    	let label;
    	let t1;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Contraseña";
    			t1 = space();
    			input = element("input");
    			attr_dev(label, "for", "");
    			add_location(label, file$8, 424, 16, 12711);
    			attr_dev(input, "type", "password");
    			attr_dev(input, "class", "form-control");
    			input.required = true;
    			attr_dev(input, "name", "PasswordHash");
    			attr_dev(input, "maxlength", "50");
    			add_location(input, file$8, 425, 16, 12761);
    			attr_dev(div0, "class", "form-group col-md-12");
    			add_location(div0, file$8, 423, 14, 12659);
    			attr_dev(div1, "class", "form-row");
    			add_location(div1, file$8, 422, 12, 12621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*obj*/ ctx[4].passwordHash);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[36]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*obj, prefijos*/ 1040 && input.value !== /*obj*/ ctx[4].passwordHash) {
    				set_input_value(input, /*obj*/ ctx[4].passwordHash);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(422:12) {#if userID == \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    // (462:14) {#if obj.isDoctor}
    function create_if_block$5(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let select0;
    	let option0;
    	let t6;
    	let div2;
    	let label2;
    	let t8;
    	let select1;
    	let option1;
    	let t10;
    	let div3;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*perfiles*/ ctx[2];
    	validate_each_argument(each_value_3);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_2[i] = create_each_block_3$4(get_each_context_3$4(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*asistentes*/ ctx[1];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*asistentesAsignado*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Ubicacion";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Perfil";
    			t4 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t6 = space();
    			div2 = element("div");
    			label2 = element("label");
    			label2.textContent = "Asistentes";
    			t8 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "- Agregar -";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t10 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(label0, "for", "");
    			add_location(label0, file$8, 463, 18, 14192);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control");
    			input.required = true;
    			add_location(input, file$8, 464, 18, 14243);
    			attr_dev(div0, "class", "form-group col-md-12");
    			add_location(div0, file$8, 462, 16, 14138);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$8, 470, 18, 14479);
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			add_location(option0, file$8, 473, 20, 14648);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "name", "perfil");
    			select0.required = true;
    			if (/*obj*/ ctx[4].perfilID === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[40].call(select0));
    			add_location(select0, file$8, 471, 18, 14527);
    			attr_dev(div1, "class", "form-group col-md-12");
    			add_location(div1, file$8, 469, 16, 14425);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$8, 480, 18, 14977);
    			option1.__value = "";
    			option1.value = option1.__value;
    			option1.disabled = true;
    			add_location(option1, file$8, 486, 20, 15236);
    			attr_dev(select1, "class", "form-control");
    			attr_dev(select1, "name", "asistentes");
    			if (/*asistenteID*/ ctx[8] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[41].call(select1));
    			add_location(select1, file$8, 481, 18, 15029);
    			attr_dev(div2, "class", "form-group col-md-12");
    			add_location(div2, file$8, 479, 16, 14923);
    			attr_dev(div3, "class", "agregados col-lg-12");
    			add_location(div3, file$8, 492, 16, 15496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*obj*/ ctx[4].ubicacion);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select0, null);
    			}

    			select_option(select0, /*obj*/ ctx[4].perfilID);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(div2, t8);
    			append_dev(div2, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select1, null);
    			}

    			select_option(select1, /*asistenteID*/ ctx[8]);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div3, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[39]),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[40]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[41]),
    					listen_dev(select1, "change", /*agregarAsistente*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*obj, prefijos*/ 1040 && input.value !== /*obj*/ ctx[4].ubicacion) {
    				set_input_value(input, /*obj*/ ctx[4].ubicacion);
    			}

    			if (dirty[0] & /*perfiles*/ 4) {
    				each_value_3 = /*perfiles*/ ctx[2];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$4(ctx, each_value_3, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_3$4(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_3.length;
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040) {
    				select_option(select0, /*obj*/ ctx[4].perfilID);
    			}

    			if (dirty[0] & /*asistentes*/ 2) {
    				each_value_2 = /*asistentes*/ ctx[1];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$4(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*asistenteID, asistentes*/ 258) {
    				select_option(select1, /*asistenteID*/ ctx[8]);
    			}

    			if (dirty[0] & /*eliminarAsistente, asistentesAsignado*/ 131073) {
    				each_value_1 = /*asistentesAsignado*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks_2, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(462:14) {#if obj.isDoctor}",
    		ctx
    	});

    	return block;
    }

    // (475:20) {#each perfiles as item}
    function create_each_block_3$4(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[46].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[46].id;
    			option.value = option.__value;
    			add_location(option, file$8, 475, 22, 14777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*perfiles*/ 4 && t_value !== (t_value = /*item*/ ctx[46].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*perfiles*/ 4 && option_value_value !== (option_value_value = /*item*/ ctx[46].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$4.name,
    		type: "each",
    		source: "(475:20) {#each perfiles as item}",
    		ctx
    	});

    	return block;
    }

    // (488:20) {#each asistentes as item}
    function create_each_block_2$4(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[46].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[46].id;
    			option.value = option.__value;
    			add_location(option, file$8, 488, 20, 15352);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*asistentes*/ 2 && t_value !== (t_value = /*item*/ ctx[46].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*asistentes*/ 2 && option_value_value !== (option_value_value = /*item*/ ctx[46].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(488:20) {#each asistentes as item}",
    		ctx
    	});

    	return block;
    }

    // (494:18) {#each asistentesAsignado as item}
    function create_each_block_1$4(ctx) {
    	let button;
    	let t_value = /*item*/ ctx[46].nombreAsistente + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[42](/*item*/ ctx[46], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-primary btn-block");
    			add_location(button, file$8, 494, 18, 15603);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*asistentesAsignado*/ 1 && t_value !== (t_value = /*item*/ ctx[46].nombreAsistente + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(494:18) {#each asistentesAsignado as item}",
    		ctx
    	});

    	return block;
    }

    // (600:12) {#each filterRoles as item}
    function create_each_block$4(ctx) {
    	let div;
    	let label;
    	let span0;
    	let t0_value = /*item*/ ctx[46].displayName + "";
    	let t0;
    	let t1;
    	let input;
    	let input_value_value;
    	let t2;
    	let span1;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[44].call(input, /*item*/ ctx[46]);
    	}

    	function click_handler_3(...args) {
    		return /*click_handler_3*/ ctx[45](/*item*/ ctx[46], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			span1 = element("span");
    			t3 = space();
    			attr_dev(span0, "class", "cstm-switch-description mr-auto bd-highlight");
    			add_location(span0, file$8, 602, 16, 19637);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", "option");
    			input.__value = input_value_value = /*item*/ ctx[46].id;
    			input.value = input.__value;
    			attr_dev(input, "class", "cstm-switch-input");
    			add_location(input, file$8, 605, 16, 19777);
    			attr_dev(span1, "class", "cstm-switch-indicator bg-success bd-highlight");
    			add_location(span1, file$8, 612, 16, 20071);
    			attr_dev(label, "class", "cstm-switch d-flex bd-highlight");
    			add_location(label, file$8, 601, 14, 19572);
    			attr_dev(div, "class", "lista-rol m-b-10");
    			add_location(div, file$8, 600, 12, 19526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, span0);
    			append_dev(span0, t0);
    			append_dev(label, t1);
    			append_dev(label, input);
    			input.checked = /*item*/ ctx[46].checked;
    			append_dev(label, t2);
    			append_dev(label, span1);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", input_change_handler),
    					listen_dev(input, "click", click_handler_3, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*filterRoles*/ 512 && t0_value !== (t0_value = /*item*/ ctx[46].displayName + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*filterRoles*/ 512 && input_value_value !== (input_value_value = /*item*/ ctx[46].id)) {
    				prop_dev(input, "__value", input_value_value);
    			}

    			input.value = input.__value;

    			if (dirty[0] & /*filterRoles*/ 512) {
    				input.checked = /*item*/ ctx[46].checked;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(600:12) {#each filterRoles as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div13;
    	let div12;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let input0;
    	let t2;
    	let div1;
    	let div0;
    	let span0;
    	let t3;
    	let button0;
    	let i;
    	let t4;
    	let t5;
    	let div11;
    	let div10;
    	let div6;
    	let h50;
    	let t7;
    	let div9;
    	let div8;
    	let div7;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t9;
    	let th1;
    	let t11;
    	let th2;
    	let t12;
    	let tbody;
    	let t13;
    	let form0;
    	let div29;
    	let div28;
    	let div27;
    	let div14;
    	let h51;
    	let t15;
    	let button1;
    	let span1;
    	let t17;
    	let div25;
    	let input1;
    	let t18;
    	let div16;
    	let div15;
    	let label0;
    	let t20;
    	let select;
    	let option;
    	let t22;
    	let div18;
    	let div17;
    	let label1;
    	let t24;
    	let input2;
    	let t25;
    	let div21;
    	let div19;
    	let label2;
    	let t27;
    	let input3;
    	let t28;
    	let div20;
    	let label3;
    	let t30;
    	let input4;
    	let t31;
    	let t32;
    	let div24;
    	let div22;
    	let label4;
    	let t34;
    	let input5;
    	let t35;
    	let div23;
    	let label5;
    	let input6;
    	let t36;
    	let span2;
    	let t37;
    	let span3;
    	let t39;
    	let t40;
    	let br;
    	let t41;
    	let div26;
    	let button2;
    	let t43;
    	let button3;
    	let t45;
    	let div36;
    	let div35;
    	let div34;
    	let div30;
    	let h52;
    	let t47;
    	let button4;
    	let span4;
    	let t49;
    	let div33;
    	let form1;
    	let input7;
    	let t50;
    	let p;
    	let span5;
    	let t51;
    	let div31;
    	let label6;
    	let t53;
    	let input8;
    	let t54;
    	let div32;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_5 = /*list*/ ctx[3];
    	validate_each_argument(each_value_5);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_2[i] = create_each_block_5$2(get_each_context_5$2(ctx, each_value_5, i));
    	}

    	let each_value_4 = /*prefijos*/ ctx[10];
    	validate_each_argument(each_value_4);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_1[i] = create_each_block_4$3(get_each_context_4$3(ctx, each_value_4, i));
    	}

    	let if_block0 = /*userID*/ ctx[5] == "" && create_if_block_1$3(ctx);
    	let if_block1 = /*obj*/ ctx[4].isDoctor && create_if_block$5(ctx);
    	let each_value = /*filterRoles*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div13 = element("div");
    			div12 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t3 = space();
    			button0 = element("button");
    			i = element("i");
    			t4 = text("\r\n              Nuevo usuario");
    			t5 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div6 = element("div");
    			h50 = element("h5");
    			h50.textContent = "Usuarios";
    			t7 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Nombres";
    			t9 = space();
    			th1 = element("th");
    			th1.textContent = "Correo";
    			t11 = space();
    			th2 = element("th");
    			t12 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t13 = space();
    			form0 = element("form");
    			div29 = element("div");
    			div28 = element("div");
    			div27 = element("div");
    			div14 = element("div");
    			h51 = element("h5");
    			h51.textContent = "Usuario";
    			t15 = space();
    			button1 = element("button");
    			span1 = element("span");
    			span1.textContent = "×";
    			t17 = space();
    			div25 = element("div");
    			input1 = element("input");
    			t18 = space();
    			div16 = element("div");
    			div15 = element("div");
    			label0 = element("label");
    			label0.textContent = "Prefijo";
    			t20 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t22 = space();
    			div18 = element("div");
    			div17 = element("div");
    			label1 = element("label");
    			label1.textContent = "Nombre Completo";
    			t24 = space();
    			input2 = element("input");
    			t25 = space();
    			div21 = element("div");
    			div19 = element("div");
    			label2 = element("label");
    			label2.textContent = "Usuario";
    			t27 = space();
    			input3 = element("input");
    			t28 = space();
    			div20 = element("div");
    			label3 = element("label");
    			label3.textContent = "Email";
    			t30 = space();
    			input4 = element("input");
    			t31 = space();
    			if (if_block0) if_block0.c();
    			t32 = space();
    			div24 = element("div");
    			div22 = element("div");
    			label4 = element("label");
    			label4.textContent = "Telefono";
    			t34 = space();
    			input5 = element("input");
    			t35 = space();
    			div23 = element("div");
    			label5 = element("label");
    			input6 = element("input");
    			t36 = space();
    			span2 = element("span");
    			t37 = space();
    			span3 = element("span");
    			span3.textContent = "Es Medico";
    			t39 = space();
    			if (if_block1) if_block1.c();
    			t40 = space();
    			br = element("br");
    			t41 = space();
    			div26 = element("div");
    			button2 = element("button");
    			button2.textContent = "Cerrar";
    			t43 = space();
    			button3 = element("button");
    			button3.textContent = "Guardar";
    			t45 = space();
    			div36 = element("div");
    			div35 = element("div");
    			div34 = element("div");
    			div30 = element("div");
    			h52 = element("h5");
    			h52.textContent = "Roles";
    			t47 = space();
    			button4 = element("button");
    			span4 = element("span");
    			span4.textContent = "×";
    			t49 = space();
    			div33 = element("div");
    			form1 = element("form");
    			input7 = element("input");
    			t50 = space();
    			p = element("p");
    			span5 = element("span");
    			t51 = space();
    			div31 = element("div");
    			label6 = element("label");
    			label6.textContent = "Buscar";
    			t53 = space();
    			input8 = element("input");
    			t54 = space();
    			div32 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "class", "form-control form-control-appended");
    			attr_dev(input0, "placeholder", "Buscar");
    			add_location(input0, file$8, 246, 16, 5933);
    			attr_dev(span0, "class", "mdi mdi-magnify");
    			add_location(span0, file$8, 254, 20, 6277);
    			attr_dev(div0, "class", "input-group-text");
    			add_location(div0, file$8, 253, 18, 6225);
    			attr_dev(div1, "class", "input-group-append");
    			add_location(div1, file$8, 252, 16, 6173);
    			attr_dev(div2, "class", "input-group input-group-flush mb-3");
    			add_location(div2, file$8, 245, 14, 5867);
    			attr_dev(div3, "class", "col-md-5");
    			add_location(div3, file$8, 244, 12, 5829);
    			attr_dev(i, "class", "mdi mdi-account-plus");
    			add_location(i, file$8, 263, 14, 6602);
    			attr_dev(button0, "class", "btn m-b-30 ml-2 mr-2 ml-3 btn-primary");
    			attr_dev(button0, "data-toggle", "modal");
    			attr_dev(button0, "data-target", "#modalUsuario");
    			add_location(button0, file$8, 259, 12, 6415);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$8, 243, 10, 5798);
    			attr_dev(div5, "class", "mt-4 col-md-12");
    			add_location(div5, file$8, 242, 8, 5758);
    			attr_dev(h50, "class", "m-b-0");
    			add_location(h50, file$8, 272, 14, 6849);
    			attr_dev(div6, "class", "card-header");
    			add_location(div6, file$8, 271, 12, 6808);
    			add_location(th0, file$8, 281, 24, 7163);
    			add_location(th1, file$8, 283, 24, 7256);
    			add_location(th2, file$8, 284, 24, 7297);
    			add_location(tr, file$8, 280, 22, 7133);
    			add_location(thead, file$8, 279, 20, 7102);
    			add_location(tbody, file$8, 287, 20, 7384);
    			attr_dev(table, "class", "table align-td-middle");
    			add_location(table, file$8, 278, 18, 7043);
    			attr_dev(div7, "class", "table-responsive");
    			add_location(div7, file$8, 277, 16, 6993);
    			attr_dev(div8, "class", "m-b-30");
    			add_location(div8, file$8, 276, 14, 6955);
    			attr_dev(div9, "class", "card-body");
    			add_location(div9, file$8, 275, 12, 6916);
    			attr_dev(div10, "class", "card m-b-30");
    			add_location(div10, file$8, 270, 10, 6769);
    			attr_dev(div11, "class", "col-lg-12");
    			add_location(div11, file$8, 269, 8, 6734);
    			attr_dev(div12, "class", "row");
    			add_location(div12, file$8, 240, 6, 5729);
    			attr_dev(div13, "class", "container");
    			add_location(div13, file$8, 239, 4, 5698);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$8, 238, 2, 5661);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$8, 236, 0, 5618);
    			attr_dev(h51, "class", "modal-title");
    			attr_dev(h51, "id", "modalUsuarioLabel");
    			add_location(h51, file$8, 357, 10, 10204);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$8, 363, 12, 10417);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "close");
    			attr_dev(button1, "data-dismiss", "modal");
    			attr_dev(button1, "aria-label", "Close");
    			add_location(button1, file$8, 358, 10, 10275);
    			attr_dev(div14, "class", "modal-header");
    			add_location(div14, file$8, 356, 8, 10166);
    			attr_dev(input1, "type", "hidden");
    			attr_dev(input1, "name", "IdUser");
    			input1.value = "0";
    			add_location(input1, file$8, 368, 12, 10594);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$8, 371, 16, 10745);
    			option.__value = "";
    			option.value = option.__value;
    			option.disabled = true;
    			add_location(option, file$8, 376, 18, 10946);
    			attr_dev(select, "class", "form-control");
    			attr_dev(select, "name", "prefijo");
    			select.required = true;
    			if (/*obj*/ ctx[4].prefix === void 0) add_render_callback(() => /*select_change_handler*/ ctx[33].call(select));
    			add_location(select, file$8, 372, 16, 10792);
    			attr_dev(div15, "class", "form-group col-md-12");
    			add_location(div15, file$8, 370, 14, 10693);
    			attr_dev(div16, "class", "form-row");
    			add_location(div16, file$8, 369, 12, 10655);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$8, 385, 16, 11309);
    			attr_dev(input2, "type", "name");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "placeholder", "Ing. John Doe");
    			attr_dev(input2, "name", "Name");
    			attr_dev(input2, "maxlength", "200");
    			input2.required = true;
    			add_location(input2, file$8, 386, 16, 11364);
    			attr_dev(div17, "class", "form-group col-md-12");
    			add_location(div17, file$8, 384, 14, 11257);
    			attr_dev(div18, "class", "form-row");
    			add_location(div18, file$8, 383, 12, 11219);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$8, 398, 16, 11795);
    			attr_dev(input3, "type", "email");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "autocomplete", "off");
    			attr_dev(input3, "name", "UserName");
    			attr_dev(input3, "id", "");
    			attr_dev(input3, "maxlength", "100");
    			add_location(input3, file$8, 399, 16, 11842);
    			attr_dev(div19, "class", "form-group col-md-12");
    			set_style(div19, "display", "none");
    			add_location(div19, file$8, 397, 14, 11720);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$8, 408, 16, 12146);
    			attr_dev(input4, "type", "email");
    			input4.required = true;
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "placeholder", "usuario@correo.com");
    			attr_dev(input4, "autocomplete", "off");
    			attr_dev(input4, "name", "Email");
    			attr_dev(input4, "id", "txtCorreo");
    			attr_dev(input4, "maxlength", "100");
    			add_location(input4, file$8, 409, 16, 12191);
    			attr_dev(div20, "class", "form-group col-md-12");
    			add_location(div20, file$8, 407, 14, 12094);
    			attr_dev(div21, "class", "form-row");
    			add_location(div21, file$8, 396, 12, 11682);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$8, 438, 16, 13162);
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "data-mask", "(000) 000-0000");
    			attr_dev(input5, "data-mask-clearifnotmatch", "true");
    			attr_dev(input5, "autocomplete", "off");
    			attr_dev(input5, "maxlength", "14");
    			attr_dev(input5, "placeholder", "(809) 000-0000");
    			add_location(input5, file$8, 439, 16, 13210);
    			attr_dev(div22, "class", "form-group col-md-12");
    			add_location(div22, file$8, 437, 14, 13110);
    			attr_dev(input6, "type", "checkbox");
    			input6.__value = "true";
    			input6.value = input6.__value;
    			attr_dev(input6, "name", "EsMedico");
    			attr_dev(input6, "class", "cstm-switch-input");
    			add_location(input6, file$8, 451, 18, 13692);
    			attr_dev(span2, "class", "cstm-switch-indicator ");
    			add_location(span2, file$8, 457, 18, 13925);
    			attr_dev(span3, "class", "cstm-switch-description");
    			add_location(span3, file$8, 458, 18, 13984);
    			attr_dev(label5, "class", "cstm-switch");
    			add_location(label5, file$8, 450, 16, 13645);
    			attr_dev(div23, "class", "form-group col-md-12");
    			add_location(div23, file$8, 449, 14, 13593);
    			attr_dev(div24, "class", "form-row");
    			add_location(div24, file$8, 436, 12, 13072);
    			add_location(br, file$8, 548, 12, 17987);
    			attr_dev(div25, "class", "modal-body");
    			set_style(div25, "height", "100%", 1);
    			set_style(div25, "top", "0");
    			set_style(div25, "overflow", "auto");
    			add_location(div25, file$8, 366, 8, 10497);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn btn-secondary");
    			attr_dev(button2, "data-dismiss", "modal");
    			add_location(button2, file$8, 551, 12, 18063);
    			attr_dev(button3, "type", "submit");
    			attr_dev(button3, "class", "btn btn-success");
    			add_location(button3, file$8, 556, 12, 18221);
    			attr_dev(div26, "class", "modal-footer");
    			add_location(div26, file$8, 550, 10, 18023);
    			attr_dev(div27, "class", "modal-content");
    			add_location(div27, file$8, 355, 6, 10129);
    			attr_dev(div28, "class", "modal-dialog");
    			attr_dev(div28, "role", "document");
    			add_location(div28, file$8, 354, 4, 10079);
    			attr_dev(div29, "class", "modal fade modal-slide-right");
    			attr_dev(div29, "id", "modalUsuario");
    			attr_dev(div29, "tabindex", "-1");
    			attr_dev(div29, "role", "dialog");
    			attr_dev(div29, "aria-labelledby", "modalUsuarioLabel");
    			set_style(div29, "display", "none");
    			set_style(div29, "padding-right", "16px");
    			attr_dev(div29, "aria-modal", "true");
    			add_location(div29, file$8, 347, 2, 9857);
    			attr_dev(form0, "id", "frmUsuario");
    			add_location(form0, file$8, 346, 0, 9796);
    			attr_dev(h52, "class", "modal-title");
    			attr_dev(h52, "id", "modalRolesLabel");
    			add_location(h52, file$8, 574, 8, 18674);
    			attr_dev(span4, "aria-hidden", "true");
    			add_location(span4, file$8, 580, 10, 18871);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "close");
    			attr_dev(button4, "data-dismiss", "modal");
    			attr_dev(button4, "aria-label", "Close");
    			add_location(button4, file$8, 575, 8, 18739);
    			attr_dev(div30, "class", "modal-header");
    			add_location(div30, file$8, 573, 6, 18638);
    			attr_dev(input7, "type", "hidden");
    			attr_dev(input7, "name", "idPaciente");
    			input7.value = "";
    			add_location(input7, file$8, 586, 10, 19005);
    			attr_dev(span5, "class", "badge badge-soft-primary");
    			set_style(span5, "font-size", "17px");
    			add_location(span5, file$8, 588, 12, 19084);
    			add_location(p, file$8, 587, 10, 19067);
    			add_location(label6, file$8, 591, 12, 19231);
    			attr_dev(input8, "type", "text");
    			attr_dev(input8, "class", "form-control");
    			attr_dev(input8, "placeholder", "Buscar roles");
    			add_location(input8, file$8, 592, 12, 19266);
    			attr_dev(div31, "class", "form-group floating-label");
    			add_location(div31, file$8, 590, 10, 19178);
    			attr_dev(div32, "class", "roles");
    			add_location(div32, file$8, 598, 10, 19452);
    			attr_dev(form1, "id", "");
    			add_location(form1, file$8, 585, 8, 18981);
    			attr_dev(div33, "class", "modal-body");
    			add_location(div33, file$8, 583, 6, 18945);
    			attr_dev(div34, "class", "modal-content");
    			add_location(div34, file$8, 572, 4, 18603);
    			attr_dev(div35, "class", "modal-dialog");
    			attr_dev(div35, "role", "document");
    			add_location(div35, file$8, 571, 2, 18555);
    			attr_dev(div36, "class", "modal fade modal-slide-right");
    			attr_dev(div36, "id", "modalRoles");
    			attr_dev(div36, "tabindex", "-1");
    			attr_dev(div36, "role", "dialog");
    			attr_dev(div36, "aria-labelledby", "modalRolesLabel");
    			set_style(div36, "display", "none");
    			set_style(div36, "padding-right", "16px");
    			attr_dev(div36, "aria-modal", "true");
    			add_location(div36, file$8, 563, 0, 18348);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*busqueda*/ ctx[6]);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(div4, t3);
    			append_dev(div4, button0);
    			append_dev(button0, i);
    			append_dev(button0, t4);
    			append_dev(div12, t5);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div6);
    			append_dev(div6, h50);
    			append_dev(div10, t7);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t9);
    			append_dev(tr, th1);
    			append_dev(tr, t11);
    			append_dev(tr, th2);
    			append_dev(table, t12);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(tbody, null);
    			}

    			insert_dev(target, t13, anchor);
    			insert_dev(target, form0, anchor);
    			append_dev(form0, div29);
    			append_dev(div29, div28);
    			append_dev(div28, div27);
    			append_dev(div27, div14);
    			append_dev(div14, h51);
    			append_dev(div14, t15);
    			append_dev(div14, button1);
    			append_dev(button1, span1);
    			append_dev(div27, t17);
    			append_dev(div27, div25);
    			append_dev(div25, input1);
    			append_dev(div25, t18);
    			append_dev(div25, div16);
    			append_dev(div16, div15);
    			append_dev(div15, label0);
    			append_dev(div15, t20);
    			append_dev(div15, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select, null);
    			}

    			select_option(select, /*obj*/ ctx[4].prefix);
    			append_dev(div25, t22);
    			append_dev(div25, div18);
    			append_dev(div18, div17);
    			append_dev(div17, label1);
    			append_dev(div17, t24);
    			append_dev(div17, input2);
    			set_input_value(input2, /*obj*/ ctx[4].name);
    			append_dev(div25, t25);
    			append_dev(div25, div21);
    			append_dev(div21, div19);
    			append_dev(div19, label2);
    			append_dev(div19, t27);
    			append_dev(div19, input3);
    			append_dev(div21, t28);
    			append_dev(div21, div20);
    			append_dev(div20, label3);
    			append_dev(div20, t30);
    			append_dev(div20, input4);
    			set_input_value(input4, /*obj*/ ctx[4].email);
    			append_dev(div25, t31);
    			if (if_block0) if_block0.m(div25, null);
    			append_dev(div25, t32);
    			append_dev(div25, div24);
    			append_dev(div24, div22);
    			append_dev(div22, label4);
    			append_dev(div22, t34);
    			append_dev(div22, input5);
    			set_input_value(input5, /*obj*/ ctx[4].phoneNumber);
    			append_dev(div24, t35);
    			append_dev(div24, div23);
    			append_dev(div23, label5);
    			append_dev(label5, input6);
    			input6.checked = /*obj*/ ctx[4].isDoctor;
    			append_dev(label5, t36);
    			append_dev(label5, span2);
    			append_dev(label5, t37);
    			append_dev(label5, span3);
    			append_dev(div24, t39);
    			if (if_block1) if_block1.m(div24, null);
    			append_dev(div25, t40);
    			append_dev(div25, br);
    			append_dev(div27, t41);
    			append_dev(div27, div26);
    			append_dev(div26, button2);
    			append_dev(div26, t43);
    			append_dev(div26, button3);
    			insert_dev(target, t45, anchor);
    			insert_dev(target, div36, anchor);
    			append_dev(div36, div35);
    			append_dev(div35, div34);
    			append_dev(div34, div30);
    			append_dev(div30, h52);
    			append_dev(div30, t47);
    			append_dev(div30, button4);
    			append_dev(button4, span4);
    			append_dev(div34, t49);
    			append_dev(div34, div33);
    			append_dev(div33, form1);
    			append_dev(form1, input7);
    			append_dev(form1, t50);
    			append_dev(form1, p);
    			append_dev(p, span5);
    			append_dev(form1, t51);
    			append_dev(form1, div31);
    			append_dev(div31, label6);
    			append_dev(div31, t53);
    			append_dev(div31, input8);
    			set_input_value(input8, /*busquedaRoles*/ ctx[7]);
    			append_dev(form1, t54);
    			append_dev(form1, div32);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div32, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[30]),
    					listen_dev(input0, "input", /*cargar*/ ctx[11], false, false, false),
    					listen_dev(button0, "click", /*agregarNuevo*/ ctx[18], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[33]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[34]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[35]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[37]),
    					listen_dev(input6, "change", /*input6_change_handler*/ ctx[38]),
    					listen_dev(form0, "submit", prevent_default(/*guardar*/ ctx[14]), false, true, false),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[43])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*busqueda*/ 64) {
    				set_input_value(input0, /*busqueda*/ ctx[6]);
    			}

    			if (dirty[0] & /*cargarRolesUser, list, cargarDetalle*/ 12296) {
    				each_value_5 = /*list*/ ctx[3];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$2(ctx, each_value_5, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_5$2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_5.length;
    			}

    			if (dirty[0] & /*prefijos*/ 1024) {
    				each_value_4 = /*prefijos*/ ctx[10];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$3(ctx, each_value_4, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_4$3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_4.length;
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040) {
    				select_option(select, /*obj*/ ctx[4].prefix);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040) {
    				set_input_value(input2, /*obj*/ ctx[4].name);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040 && input4.value !== /*obj*/ ctx[4].email) {
    				set_input_value(input4, /*obj*/ ctx[4].email);
    			}

    			if (/*userID*/ ctx[5] == "") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(div25, t32);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040 && input5.value !== /*obj*/ ctx[4].phoneNumber) {
    				set_input_value(input5, /*obj*/ ctx[4].phoneNumber);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 1040) {
    				input6.checked = /*obj*/ ctx[4].isDoctor;
    			}

    			if (/*obj*/ ctx[4].isDoctor) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(div24, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*busquedaRoles*/ 128 && input8.value !== /*busquedaRoles*/ ctx[7]) {
    				set_input_value(input8, /*busquedaRoles*/ ctx[7]);
    			}

    			if (dirty[0] & /*filterRoles, agregarRol*/ 33280) {
    				each_value = /*filterRoles*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div32, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_2, detaching);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(form0);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t45);
    			if (detaching) detach_dev(div36);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $axios;
    	let $session;
    	let $activePage;
    	let $errorConexion;
    	let $toast;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(21, $axios = $$value));
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(22, $session = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(23, $activePage = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(24, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(25, $toast = $$value));

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "mantenimiento.usuarios.index");
    	let asistentesAsignado = [];
    	let asistentes = [];
    	let perfiles = [];
    	let roles = [];
    	let rolesUser = [];
    	let list = [];

    	let prefijos = [
    		{ value: "Dr", name: "Dr." },
    		{ value: "Dra", name: "Dra." },
    		{ value: "Lic", name: "Lic." },
    		{ value: "Lida", name: "Lida." },
    		{ value: "Sr", name: "Sr." },
    		{ value: "Sra", name: "Sra." }
    	];

    	let obj = {
    		prefix: "",
    		name: "",
    		email: "",
    		phoneNumber: "",
    		passwordHash: "",
    		ubicacion: "",
    		isDoctor: false,
    		perfilID: null
    	};

    	let userID = "";
    	let busqueda = "";
    	let busquedaRoles = "";
    	let asistenteID = "";

    	onMount(() => {
    		cargar();
    		cargarAsistentes();
    		cargarPerfil();
    		cargarRoles();
    	});

    	function cargar() {
    		$axios.get("/Users?keyword=" + busqueda).then(res => {
    			$$invalidate(3, list = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarDetalle(id) {
    		$$invalidate(5, userID = id);

    		$axios.get("/Users/" + id).then(res => {
    			$$invalidate(5, userID = id);
    			$$invalidate(4, obj = res.data);
    			cargarAsistentesAsignado();
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarPerfil() {
    		$axios.get("/Perfiles/GetAll").then(res => {
    			$$invalidate(2, perfiles = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarAsistentesAsignado() {
    		$axios.get("/Medicos/" + userID + "/Asistentes").then(res => {
    			$$invalidate(0, asistentesAsignado = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarAsistentes() {
    		$axios.get("/Users/assistant/All").then(res => {
    			$$invalidate(1, asistentes = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarRoles() {
    		$axios.get("/Roles").then(res => {
    			$$invalidate(19, roles = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarRolesUser(id) {
    		$$invalidate(5, userID = id);

    		$axios.get("Users/" + userID + "/Roles").then(res => {
    			$$invalidate(20, rolesUser = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function guardar() {
    		if (userID == "") {
    			$axios.post("/Users", obj).then(res => {
    				if (res.data.success) {
    					$toast(5000).fire({
    						icon: "success",
    						title: "Usuario guardado con exito"
    					});

    					jQuery("#modalUsuario").modal("hide");
    					cargar();
    				}
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		} else {
    			$axios.put("/Users/" + userID, obj).then(res => {
    				if (res.data.success) {
    					$toast(5000).fire({
    						icon: "success",
    						title: "Usuario guardado con exito"
    					});

    					jQuery("#modalUsuario").modal("hide");
    					cargar();
    				}
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	function agregarRol(rol, checked) {
    		checked = Boolean(checked);

    		if (checked) {
    			$axios.post("/Users/" + userID + "/RemoveFrom?role=" + rol).then(res => {
    				cargarRolesUser(userID);
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		} else {
    			$axios.post("/Users/" + userID + "/AddTo?role=" + rol).then(res => {
    				cargarRolesUser(userID);
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	function agregarAsistente() {
    		let obj = {
    			AsistenteID: asistenteID,
    			MedicoID: userID
    		};

    		$axios.post("/MedicosAsistentes", obj).then(res => {
    			if (res.data.success) {
    				cargarAsistentesAsignado();
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function eliminarAsistente(item) {
    		let obj = {
    			AsistenteID: item.asistenteID,
    			MedicoID: item.medicoID
    		};

    		let qs = Object.entries(obj).map(e => e.join("=")).join("&");

    		$axios.delete("/MedicosAsistentes?" + qs).then(res => {
    			if (res.data.success) {
    				cargarAsistentesAsignado();
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function agregarNuevo() {
    		$$invalidate(5, userID = "");

    		$$invalidate(4, obj = {
    			prefix: "",
    			name: "",
    			email: "",
    			phoneNumber: "",
    			passwordHash: "",
    			ubicacion: "",
    			isDoctor: false,
    			perfilID: null
    		});
    	}

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Index", $$slots, []);

    	function input0_input_handler() {
    		busqueda = this.value;
    		$$invalidate(6, busqueda);
    	}

    	const click_handler = i => cargarDetalle(i.id);
    	const click_handler_1 = i => cargarRolesUser(i.id);

    	function select_change_handler() {
    		obj.prefix = select_value(this);
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input2_input_handler() {
    		obj.name = this.value;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input4_input_handler() {
    		obj.email = this.value;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input_input_handler() {
    		obj.passwordHash = this.value;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input5_input_handler() {
    		obj.phoneNumber = this.value;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input6_change_handler() {
    		obj.isDoctor = this.checked;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function input_input_handler_1() {
    		obj.ubicacion = this.value;
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function select0_change_handler() {
    		obj.perfilID = select_value(this);
    		$$invalidate(4, obj);
    		$$invalidate(10, prefijos);
    	}

    	function select1_change_handler() {
    		asistenteID = select_value(this);
    		$$invalidate(8, asistenteID);
    		$$invalidate(1, asistentes);
    	}

    	const click_handler_2 = item => eliminarAsistente(item);

    	function input8_input_handler() {
    		busquedaRoles = this.value;
    		$$invalidate(7, busquedaRoles);
    	}

    	function input_change_handler(item) {
    		item.checked = this.checked;
    		((($$invalidate(9, filterRoles), $$invalidate(19, roles)), $$invalidate(20, rolesUser)), $$invalidate(7, busquedaRoles));
    	}

    	const click_handler_3 = item => agregarRol(item.name, item.checked);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		push,
    		activePage,
    		host,
    		axios: axios$2,
    		session,
    		errorConexion,
    		toast,
    		onMount,
    		asistentesAsignado,
    		asistentes,
    		perfiles,
    		roles,
    		rolesUser,
    		list,
    		prefijos,
    		obj,
    		userID,
    		busqueda,
    		busquedaRoles,
    		asistenteID,
    		cargar,
    		cargarDetalle,
    		cargarPerfil,
    		cargarAsistentesAsignado,
    		cargarAsistentes,
    		cargarRoles,
    		cargarRolesUser,
    		guardar,
    		agregarRol,
    		agregarAsistente,
    		eliminarAsistente,
    		agregarNuevo,
    		$axios,
    		$session,
    		$activePage,
    		filterRoles,
    		$errorConexion,
    		$toast
    	});

    	$$self.$inject_state = $$props => {
    		if ("asistentesAsignado" in $$props) $$invalidate(0, asistentesAsignado = $$props.asistentesAsignado);
    		if ("asistentes" in $$props) $$invalidate(1, asistentes = $$props.asistentes);
    		if ("perfiles" in $$props) $$invalidate(2, perfiles = $$props.perfiles);
    		if ("roles" in $$props) $$invalidate(19, roles = $$props.roles);
    		if ("rolesUser" in $$props) $$invalidate(20, rolesUser = $$props.rolesUser);
    		if ("list" in $$props) $$invalidate(3, list = $$props.list);
    		if ("prefijos" in $$props) $$invalidate(10, prefijos = $$props.prefijos);
    		if ("obj" in $$props) $$invalidate(4, obj = $$props.obj);
    		if ("userID" in $$props) $$invalidate(5, userID = $$props.userID);
    		if ("busqueda" in $$props) $$invalidate(6, busqueda = $$props.busqueda);
    		if ("busquedaRoles" in $$props) $$invalidate(7, busquedaRoles = $$props.busquedaRoles);
    		if ("asistenteID" in $$props) $$invalidate(8, asistenteID = $$props.asistenteID);
    		if ("filterRoles" in $$props) $$invalidate(9, filterRoles = $$props.filterRoles);
    	};

    	let filterRoles;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*roles, rolesUser, busquedaRoles*/ 1572992) {
    			 $$invalidate(9, filterRoles = roles.map(x => {
    				return {
    					id: x.id,
    					name: x.name,
    					displayName: x.displayName,
    					checked: rolesUser.some(y => y == x.name)
    				};
    			}).filter(x => x.displayName.toLowerCase().includes(busquedaRoles.toLowerCase())));
    		}
    	};

    	return [
    		asistentesAsignado,
    		asistentes,
    		perfiles,
    		list,
    		obj,
    		userID,
    		busqueda,
    		busquedaRoles,
    		asistenteID,
    		filterRoles,
    		prefijos,
    		cargar,
    		cargarDetalle,
    		cargarRolesUser,
    		guardar,
    		agregarRol,
    		agregarAsistente,
    		eliminarAsistente,
    		agregarNuevo,
    		roles,
    		rolesUser,
    		$axios,
    		$session,
    		$activePage,
    		$errorConexion,
    		$toast,
    		cargarPerfil,
    		cargarAsistentesAsignado,
    		cargarAsistentes,
    		cargarRoles,
    		input0_input_handler,
    		click_handler,
    		click_handler_1,
    		select_change_handler,
    		input2_input_handler,
    		input4_input_handler,
    		input_input_handler,
    		input5_input_handler,
    		input6_change_handler,
    		input_input_handler_1,
    		select0_change_handler,
    		select1_change_handler,
    		click_handler_2,
    		input8_input_handler,
    		input_change_handler,
    		click_handler_3
    	];
    }

    class Index$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\Components\Horario.svelte generated by Svelte v3.23.0 */

    const { console: console_1$7 } = globals;
    const file$9 = "src\\Components\\Horario.svelte";

    // (92:0) {#if !invisible}
    function create_if_block$6(ctx) {
    	let div9;
    	let div8;
    	let div7;
    	let h4;
    	let t0_value = /*horario*/ ctx[0].tanda + "";
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let div6;
    	let div1;
    	let div0;
    	let label0;
    	let t4;
    	let input0;
    	let t5;
    	let div3;
    	let div2;
    	let label1;
    	let t7;
    	let input1;
    	let t8;
    	let div5;
    	let div4;
    	let label2;
    	let t10;
    	let input2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			div6 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Hora de inicio";
    			t4 = space();
    			input0 = element("input");
    			t5 = space();
    			div3 = element("div");
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Hora fin";
    			t7 = space();
    			input1 = element("input");
    			t8 = space();
    			div5 = element("div");
    			div4 = element("div");
    			label2 = element("label");
    			label2.textContent = "Intervalo (Minutos)";
    			t10 = space();
    			input2 = element("input");
    			attr_dev(h4, "class", "alert-heading");
    			add_location(h4, file$9, 96, 8, 2620);
    			add_location(hr, file$9, 97, 8, 2676);
    			attr_dev(label0, "class", "font-secondary");
    			add_location(label0, file$9, 101, 14, 2798);
    			attr_dev(input0, "type", "time");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$9, 102, 14, 2866);
    			attr_dev(div0, "class", "form-group ");
    			add_location(div0, file$9, 100, 12, 2757);
    			attr_dev(div1, "class", "col-lg-3");
    			add_location(div1, file$9, 99, 10, 2721);
    			attr_dev(label1, "class", "font-secondary");
    			add_location(label1, file$9, 111, 14, 3162);
    			attr_dev(input1, "type", "time");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$9, 112, 14, 3224);
    			attr_dev(div2, "class", "form-group ");
    			add_location(div2, file$9, 110, 12, 3121);
    			attr_dev(div3, "class", "col-lg-3");
    			add_location(div3, file$9, 109, 10, 3085);
    			add_location(label2, file$9, 121, 14, 3516);
    			attr_dev(input2, "type", "number");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$9, 122, 14, 3566);
    			attr_dev(div4, "class", "form-group");
    			add_location(div4, file$9, 120, 12, 3476);
    			attr_dev(div5, "class", "col-lg-3");
    			add_location(div5, file$9, 119, 10, 3440);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$9, 98, 8, 2692);
    			attr_dev(div7, "class", "alert alert-secondary");
    			attr_dev(div7, "role", "alert");
    			add_location(div7, file$9, 95, 6, 2562);
    			attr_dev(div8, "class", "col-lg-12 mt-3");
    			add_location(div8, file$9, 94, 4, 2526);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$9, 93, 2, 2503);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, h4);
    			append_dev(h4, t0);
    			append_dev(div7, t1);
    			append_dev(div7, hr);
    			append_dev(div7, t2);
    			append_dev(div7, div6);
    			append_dev(div6, div1);
    			append_dev(div1, div0);
    			append_dev(div0, label0);
    			append_dev(div0, t4);
    			append_dev(div0, input0);
    			set_input_value(input0, /*horario*/ ctx[0].horaInicio);
    			append_dev(div6, t5);
    			append_dev(div6, div3);
    			append_dev(div3, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t7);
    			append_dev(div2, input1);
    			set_input_value(input1, /*horario*/ ctx[0].horaFin);
    			append_dev(div6, t8);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, label2);
    			append_dev(div4, t10);
    			append_dev(div4, input2);
    			set_input_value(input2, /*horario*/ ctx[0].intervalo);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input0, "change", /*cambiarHorario*/ ctx[2], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input1, "change", /*cambiarHorario*/ ctx[2], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[9]),
    					listen_dev(input2, "input", /*cambiarHorario*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*horario*/ 1 && t0_value !== (t0_value = /*horario*/ ctx[0].tanda + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*horario*/ 1) {
    				set_input_value(input0, /*horario*/ ctx[0].horaInicio);
    			}

    			if (dirty & /*horario*/ 1) {
    				set_input_value(input1, /*horario*/ ctx[0].horaFin);
    			}

    			if (dirty & /*horario*/ 1 && to_number(input2.value) !== /*horario*/ ctx[0].intervalo) {
    				set_input_value(input2, /*horario*/ ctx[0].intervalo);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(92:0) {#if !invisible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let if_block_anchor;
    	let if_block = !/*invisible*/ ctx[1] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*invisible*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function validarHora(hora, tanda) {
    	if (tanda == 1) {
    		let time = hora.split(":");
    		let hours = parseInt(time[0]) - 12;
    		return hours.toString().padStart(2, "0") + ":" + time[1];
    	} else {
    		let time = hora.split(":");
    		let hours = parseInt(time[0]) + 12;
    		return hours + ":" + time[1];
    	}
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $axios;
    	let $errorConexion;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(3, $axios = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(4, $errorConexion = $$value));
    	let { horario = {} } = $$props;
    	const dispatch = createEventDispatcher();

    	function mensajeTanda(tanda, texto) {
    		if (tanda == 1) {
    			sweetalert2_all.fire({
    				title: "Información",
    				text: "Hora " + texto + " de la tanda matutina incorrecta!",
    				icon: "info"
    			});
    		} else {
    			sweetalert2_all.fire({
    				title: "Información",
    				text: "Hora " + texto + " de la tanda vespertina incorrecta!",
    				icon: "info"
    			});
    		}
    	}

    	function cambiarHorario(e) {
    		if (horario.tandaID == 1) {
    			if (horario.horaInicio > "11:59") {
    				mensajeTanda(1, "inicio");
    				$$invalidate(0, horario.horaInicio = validarHora(horario.horaInicio, 1), horario);
    				return;
    			}

    			if (horario.horaFin > "11:59") {
    				mensajeTanda(1, "fin");
    				$$invalidate(0, horario.horaFin = validarHora(horario.horaFin, 1), horario);
    				return;
    			}
    		} else {
    			if (horario.horaInicio < "12:00") {
    				mensajeTanda(2, "inicio");
    				$$invalidate(0, horario.horaInicio = validarHora(horario.horaInicio, 2), horario);
    				return;
    			}

    			if (horario.horaFin < "12:00") {
    				mensajeTanda(2, "fin");
    				$$invalidate(0, horario.horaFin = validarHora(horario.horaFin, 2), horario);
    				return;
    			}
    		}

    		let obj = {
    			MedicoID: horario.medicoID,
    			Dia: horario.dia,
    			TandaID: horario.tandaID,
    			HoraInicio: horario.horaInicio,
    			HoraFin: horario.horaFin,
    			Intervalo: horario.intervalo
    		};

    		if (!isNaN(horario.intervalo)) {
    			// let hora = moment(obj.HoraInicio, 'HH:mm');
    			// hora.add(obj.Intervalo, 'minutes');
    			// if (hora.format('HH:mm') > obj.HoraFin) {
    			//   console.log('hora inicio mayor que hora fin')
    			// }
    			$axios.put("/Horarios", obj).then(res => {
    				dispatch("cambioHorario");
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	const writable_props = ["horario"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<Horario> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Horario", $$slots, []);

    	function input0_input_handler() {
    		horario.horaInicio = this.value;
    		$$invalidate(0, horario);
    	}

    	function input1_input_handler() {
    		horario.horaFin = this.value;
    		$$invalidate(0, horario);
    	}

    	function input2_input_handler() {
    		horario.intervalo = to_number(this.value);
    		$$invalidate(0, horario);
    	}

    	$$self.$set = $$props => {
    		if ("horario" in $$props) $$invalidate(0, horario = $$props.horario);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		axios: axios$2,
    		errorConexion,
    		moment,
    		Swal: sweetalert2_all,
    		horario,
    		dispatch,
    		validarHora,
    		mensajeTanda,
    		cambiarHorario,
    		invisible,
    		$axios,
    		$errorConexion
    	});

    	$$self.$inject_state = $$props => {
    		if ("horario" in $$props) $$invalidate(0, horario = $$props.horario);
    		if ("invisible" in $$props) $$invalidate(1, invisible = $$props.invisible);
    	};

    	let invisible;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*horario*/ 1) {
    			 $$invalidate(1, invisible = horario.inactivo);
    		}
    	};

    	return [
    		horario,
    		invisible,
    		cambiarHorario,
    		$axios,
    		$errorConexion,
    		dispatch,
    		mensajeTanda,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class Horario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { horario: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Horario",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get horario() {
    		throw new Error("<Horario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horario(value) {
    		throw new Error("<Horario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Components\Tanda.svelte generated by Svelte v3.23.0 */

    const { console: console_1$8 } = globals;
    const file$a = "src\\Components\\Tanda.svelte";

    function create_fragment$b(ctx) {
    	let label;
    	let input;
    	let input_value_value;
    	let t0;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = /*i*/ ctx[0].nombre + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t0 = space();
    			span0 = element("span");
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", "option");
    			input.value = input_value_value = /*i*/ ctx[0].id;
    			input.checked = /*checked*/ ctx[1];
    			attr_dev(input, "class", "cstm-switch-input");
    			add_location(input, file$a, 77, 2, 2039);
    			attr_dev(span0, "class", "cstm-switch-indicator bg-success ");
    			add_location(span0, file$a, 84, 2, 2186);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$a, 85, 2, 2240);
    			attr_dev(label, "class", "cstm-switch ml-3 mr-3 mb-2");
    			add_location(label, file$a, 76, 0, 1993);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			append_dev(label, t0);
    			append_dev(label, span0);
    			append_dev(label, t1);
    			append_dev(label, span1);
    			append_dev(span1, t2);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*cambiarCheck*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*i*/ 1 && input_value_value !== (input_value_value = /*i*/ ctx[0].id)) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (dirty & /*checked*/ 2) {
    				prop_dev(input, "checked", /*checked*/ ctx[1]);
    			}

    			if (dirty & /*i*/ 1 && t2_value !== (t2_value = /*i*/ ctx[0].nombre + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $axios;
    	let $errorConexion;
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(6, $axios = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(7, $errorConexion = $$value));
    	let { i = {} } = $$props;
    	let { horarios = {} } = $$props;
    	let { dia = {} } = $$props;
    	let { medicoID = {} } = $$props;
    	const dispatch = createEventDispatcher();

    	function cambiarCheck(e) {
    		let hr = {
    			MedicoID: medicoID,
    			Dia: dia,
    			TandaID: i.id,
    			HoraInicio: i.id == 1 ? "08:00" : "12:00",
    			HoraFin: i.id == 1 ? "08:30" : "12:30",
    			Intervalo: 30
    		};

    		if (e.target.checked) {
    			// Si la tanda esta marcada
    			hr = {
    				MedicoID: medicoID,
    				Dia: dia,
    				TandaID: i.id,
    				HoraInicio: i.id == 1 ? "08:00" : "12:00",
    				HoraFin: i.id == 1 ? "08:30" : "12:30",
    				Intervalo: 30,
    				Inactivo: false
    			};

    			if (horarios.some(x => x.dia == dia && x.tandaID == i.id)) {
    				// Si existe horario en ese dia y tanda
    				$axios.put("/Horarios", hr).then(res => {
    					dispatch("cambioHorario");
    				}).catch(err => {
    					console.error(err);
    					$errorConexion();
    				});
    			} else {
    				// Si no existe horario en ese dia y tanda
    				$axios.post("/Horarios", hr).then(res => {
    					dispatch("cambioHorario");
    				}).catch(err => {
    					console.error(err);
    					$errorConexion();
    				});
    			}
    		} else {
    			// Si la tanda se desmarca
    			hr = {
    				MedicoID: medicoID,
    				Dia: dia,
    				TandaID: i.id,
    				HoraInicio: i.id == 1 ? "08:00" : "12:00",
    				HoraFin: i.id == 1 ? "08:30" : "12:30",
    				Intervalo: 30,
    				Inactivo: true
    			};

    			$axios.put("/Horarios", hr).then(res => {
    				dispatch("cambioHorario");
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	const writable_props = ["i", "horarios", "dia", "medicoID"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<Tanda> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Tanda", $$slots, []);

    	$$self.$set = $$props => {
    		if ("i" in $$props) $$invalidate(0, i = $$props.i);
    		if ("horarios" in $$props) $$invalidate(3, horarios = $$props.horarios);
    		if ("dia" in $$props) $$invalidate(4, dia = $$props.dia);
    		if ("medicoID" in $$props) $$invalidate(5, medicoID = $$props.medicoID);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		axios: axios$2,
    		errorConexion,
    		i,
    		horarios,
    		dia,
    		medicoID,
    		dispatch,
    		cambiarCheck,
    		checked,
    		$axios,
    		$errorConexion
    	});

    	$$self.$inject_state = $$props => {
    		if ("i" in $$props) $$invalidate(0, i = $$props.i);
    		if ("horarios" in $$props) $$invalidate(3, horarios = $$props.horarios);
    		if ("dia" in $$props) $$invalidate(4, dia = $$props.dia);
    		if ("medicoID" in $$props) $$invalidate(5, medicoID = $$props.medicoID);
    		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
    	};

    	let checked;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*horarios, dia, i*/ 25) {
    			 $$invalidate(1, checked = horarios.some(x => x.dia == dia && x.tandaID == i.id && !x.inactivo));
    		}
    	};

    	return [i, checked, cambiarCheck, horarios, dia, medicoID];
    }

    class Tanda extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { i: 0, horarios: 3, dia: 4, medicoID: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tanda",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get i() {
    		throw new Error("<Tanda>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set i(value) {
    		throw new Error("<Tanda>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horarios() {
    		throw new Error("<Tanda>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horarios(value) {
    		throw new Error("<Tanda>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dia() {
    		throw new Error("<Tanda>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dia(value) {
    		throw new Error("<Tanda>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medicoID() {
    		throw new Error("<Tanda>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medicoID(value) {
    		throw new Error("<Tanda>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Components\DiaSemana.svelte generated by Svelte v3.23.0 */
    const file$b = "src\\Components\\DiaSemana.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (44:6) {#each tandas as i}
    function create_each_block_1$5(ctx) {
    	let current;

    	const tanda = new Tanda({
    			props: {
    				i: /*i*/ ctx[11],
    				horarios: /*horarios*/ ctx[2],
    				dia: /*item*/ ctx[0].dia,
    				medicoID: /*medicoID*/ ctx[3]
    			},
    			$$inline: true
    		});

    	tanda.$on("cambioHorario", /*actualizar*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(tanda.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tanda, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tanda_changes = {};
    			if (dirty & /*tandas*/ 2) tanda_changes.i = /*i*/ ctx[11];
    			if (dirty & /*horarios*/ 4) tanda_changes.horarios = /*horarios*/ ctx[2];
    			if (dirty & /*item*/ 1) tanda_changes.dia = /*item*/ ctx[0].dia;
    			if (dirty & /*medicoID*/ 8) tanda_changes.medicoID = /*medicoID*/ ctx[3];
    			tanda.$set(tanda_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tanda.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tanda.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tanda, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(44:6) {#each tandas as i}",
    		ctx
    	});

    	return block;
    }

    // (49:4) {#each horariosFiltrados as horario}
    function create_each_block$5(ctx) {
    	let current;

    	const horario = new Horario({
    			props: { horario: /*horario*/ ctx[8] },
    			$$inline: true
    		});

    	horario.$on("cambioHorario", /*actualizar*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(horario.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(horario, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const horario_changes = {};
    			if (dirty & /*horariosFiltrados*/ 16) horario_changes.horario = /*horario*/ ctx[8];
    			horario.$set(horario_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(horario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(horario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(horario, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(49:4) {#each horariosFiltrados as horario}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div4;
    	let div1;
    	let h5;
    	let div0;
    	let input;
    	let input_id_value;
    	let t0;
    	let label;
    	let t1_value = /*item*/ ctx[0].nombre + "";
    	let t1;
    	let label_for_value;
    	let t2;
    	let div3;
    	let div2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*tandas*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*horariosFiltrados*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			h5 = element("h5");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = text(t1_value);
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "custom-control-input");
    			attr_dev(input, "id", input_id_value = /*item*/ ctx[0].dia);
    			input.disabled = true;
    			add_location(input, file$b, 31, 8, 770);
    			attr_dev(label, "class", "custom-control-label");
    			attr_dev(label, "for", label_for_value = /*item*/ ctx[0].dia);
    			add_location(label, file$b, 37, 8, 938);
    			attr_dev(div0, "class", "custom-control custom-checkbox");
    			set_style(div0, "margin-left", "15px");
    			set_style(div0, "padding-left", "0");
    			add_location(div0, file$b, 28, 6, 654);
    			attr_dev(h5, "class", "m-b-0");
    			add_location(h5, file$b, 27, 4, 628);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$b, 26, 2, 597);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$b, 42, 4, 1078);
    			attr_dev(div3, "class", "card-body");
    			add_location(div3, file$b, 41, 2, 1049);
    			attr_dev(div4, "class", "card m-b-30 card-vnc svelte-1qxynea");
    			add_location(div4, file$b, 25, 0, 559);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, h5);
    			append_dev(h5, div0);
    			append_dev(div0, input);
    			input.checked = /*item*/ ctx[0].check;
    			append_dev(div0, t0);
    			append_dev(div0, label);
    			append_dev(label, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(div3, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*item*/ 1 && input_id_value !== (input_id_value = /*item*/ ctx[0].dia)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*item*/ 1) {
    				input.checked = /*item*/ ctx[0].check;
    			}

    			if ((!current || dirty & /*item*/ 1) && t1_value !== (t1_value = /*item*/ ctx[0].nombre + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*item*/ 1 && label_for_value !== (label_for_value = /*item*/ ctx[0].dia)) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*tandas, horarios, item, medicoID, actualizar*/ 47) {
    				each_value_1 = /*tandas*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$5(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*horariosFiltrados, actualizar*/ 48) {
    				each_value = /*horariosFiltrados*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { item = {} } = $$props;
    	let { tandas = {} } = $$props;
    	let { horarios = {} } = $$props;
    	let { medicoID = {} } = $$props;
    	const dispatch = createEventDispatcher();

    	const actualizar = function () {
    		dispatch("cambioHorario");
    	};

    	const writable_props = ["item", "tandas", "horarios", "medicoID"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DiaSemana> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DiaSemana", $$slots, []);

    	function input_change_handler() {
    		item.check = this.checked;
    		$$invalidate(0, item);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("tandas" in $$props) $$invalidate(1, tandas = $$props.tandas);
    		if ("horarios" in $$props) $$invalidate(2, horarios = $$props.horarios);
    		if ("medicoID" in $$props) $$invalidate(3, medicoID = $$props.medicoID);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Horario,
    		Tanda,
    		item,
    		tandas,
    		horarios,
    		medicoID,
    		dispatch,
    		actualizar,
    		horariosFiltrados
    	});

    	$$self.$inject_state = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("tandas" in $$props) $$invalidate(1, tandas = $$props.tandas);
    		if ("horarios" in $$props) $$invalidate(2, horarios = $$props.horarios);
    		if ("medicoID" in $$props) $$invalidate(3, medicoID = $$props.medicoID);
    		if ("horariosFiltrados" in $$props) $$invalidate(4, horariosFiltrados = $$props.horariosFiltrados);
    	};

    	let horariosFiltrados;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*horarios, item*/ 5) {
    			 $$invalidate(4, horariosFiltrados = horarios.filter(x => x.dia == item.dia));
    		}
    	};

    	return [
    		item,
    		tandas,
    		horarios,
    		medicoID,
    		horariosFiltrados,
    		actualizar,
    		dispatch,
    		input_change_handler
    	];
    }

    class DiaSemana extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			item: 0,
    			tandas: 1,
    			horarios: 2,
    			medicoID: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DiaSemana",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get item() {
    		throw new Error("<DiaSemana>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<DiaSemana>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tandas() {
    		throw new Error("<DiaSemana>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tandas(value) {
    		throw new Error("<DiaSemana>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horarios() {
    		throw new Error("<DiaSemana>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horarios(value) {
    		throw new Error("<DiaSemana>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medicoID() {
    		throw new Error("<DiaSemana>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medicoID(value) {
    		throw new Error("<DiaSemana>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Medico\Perfil.svelte generated by Svelte v3.23.0 */

    const { console: console_1$9 } = globals;
    const file$c = "src\\Pages\\Medico\\Perfil.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[59] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[56] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[56] = list[i];
    	return child_ctx;
    }

    // (418:22) {#each tandas as i}
    function create_each_block_5$3(ctx) {
    	let option;
    	let t_value = /*i*/ ctx[56].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*i*/ ctx[56].id;
    			option.value = option.__value;
    			add_location(option, file$c, 418, 22, 12703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tandas*/ 64 && t_value !== (t_value = /*i*/ ctx[56].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*tandas*/ 64 && option_value_value !== (option_value_value = /*i*/ ctx[56].id)) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$3.name,
    		type: "each",
    		source: "(418:22) {#each tandas as i}",
    		ctx
    	});

    	return block;
    }

    // (425:14) {#if horasDisponibles.length <= 0}
    function create_if_block_2$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay disponibilidad con este horario";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$c, 425, 14, 12943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(425:14) {#if horasDisponibles.length <= 0}",
    		ctx
    	});

    	return block;
    }

    // (432:16) {#each horasDisponibles as item}
    function create_each_block_4$4(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*item*/ ctx[51].hora + "";
    	let t0;
    	let t1;
    	let div2;
    	let button;
    	let i;
    	let t2;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button = element("button");
    			i = element("i");
    			t2 = text("\r\n                      Crear cita");
    			t3 = space();
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$c, 434, 20, 13314);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$c, 433, 18, 13278);
    			attr_dev(i, "class", "mdi mdi-calendar-plus");
    			add_location(i, file$c, 440, 22, 13587);
    			attr_dev(button, "class", "btn btn-outline-success btn-sm");
    			add_location(button, file$c, 437, 20, 13438);
    			attr_dev(div2, "class", "ml-auto");
    			add_location(div2, file$c, 436, 18, 13395);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$c, 432, 16, 13203);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(button, i);
    			append_dev(button, t2);
    			append_dev(div3, t3);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*crearCita*/ ctx[18](/*item*/ ctx[51].time))) /*crearCita*/ ctx[18](/*item*/ ctx[51].time).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*horasDisponibles*/ 128 && t0_value !== (t0_value = /*item*/ ctx[51].hora + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$4.name,
    		type: "each",
    		source: "(432:16) {#each horasDisponibles as item}",
    		ctx
    	});

    	return block;
    }

    // (492:14) {#if citas.length == 0}
    function create_if_block_1$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay citas programadas para este dia";
    			attr_dev(div, "class", "alert alert-success");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$c, 492, 14, 15530);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(492:14) {#if citas.length == 0}",
    		ctx
    	});

    	return block;
    }

    // (508:24) {#each i.horas as h}
    function create_each_block_3$5(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t0_value = /*h*/ ctx[59].nombrePaciente + "";
    	let t0;
    	let t1;
    	let div1;
    	let span0;
    	let t2_value = /*h*/ ctx[59].hora + "";
    	let t2;
    	let t3;
    	let span1;
    	let t4_value = /*h*/ ctx[59].observaciones + "";
    	let t4;
    	let t5;
    	let t6;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			span0 = element("span");
    			t2 = text(t2_value);
    			t3 = text("\r\n                              -\r\n                              ");
    			span1 = element("span");
    			t4 = text(t4_value);
    			t5 = text(" (Observaciones)");
    			t6 = space();
    			attr_dev(div0, "class", "name text-primary");
    			add_location(div0, file$c, 510, 28, 16275);
    			add_location(span0, file$c, 514, 30, 16478);
    			add_location(span1, file$c, 516, 30, 16564);
    			attr_dev(div1, "class", "text-muted");
    			add_location(div1, file$c, 513, 28, 16422);
    			attr_dev(div2, "class", "");
    			add_location(div2, file$c, 509, 26, 16231);
    			attr_dev(div3, "class", "list-group-item d-flex align-items-center svelte-1nu1nbu");
    			add_location(div3, file$c, 508, 24, 16148);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, span1);
    			append_dev(span1, t4);
    			append_dev(span1, t5);
    			append_dev(div3, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*citas*/ 256 && t0_value !== (t0_value = /*h*/ ctx[59].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citas*/ 256 && t2_value !== (t2_value = /*h*/ ctx[59].hora + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*citas*/ 256 && t4_value !== (t4_value = /*h*/ ctx[59].observaciones + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$5.name,
    		type: "each",
    		source: "(508:24) {#each i.horas as h}",
    		ctx
    	});

    	return block;
    }

    // (499:16) {#each citas as i}
    function create_each_block_2$5(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let h5;
    	let t0_value = /*i*/ ctx[56].fecha + "";
    	let t0;
    	let t1;
    	let div2;
    	let div1;
    	let t2;
    	let each_value_3 = /*i*/ ctx[56].horas;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$5(get_each_context_3$5(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			attr_dev(h5, "class", "m-b-0");
    			add_location(h5, file$c, 502, 22, 15911);
    			attr_dev(div0, "class", "card-header");
    			add_location(div0, file$c, 501, 20, 15862);
    			attr_dev(div1, "class", "list-group list ");
    			add_location(div1, file$c, 506, 22, 16046);
    			attr_dev(div2, "class", "card-body");
    			add_location(div2, file$c, 504, 20, 15993);
    			attr_dev(div3, "class", "card m-b-20 card-vnc svelte-1nu1nbu");
    			add_location(div3, file$c, 500, 18, 15806);
    			attr_dev(div4, "class", "col-lg-6");
    			add_location(div4, file$c, 499, 16, 15764);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div4, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*citas*/ 256 && t0_value !== (t0_value = /*i*/ ctx[56].fecha + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*citas*/ 256) {
    				each_value_3 = /*i*/ ctx[56].horas;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$5(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$5.name,
    		type: "each",
    		source: "(499:16) {#each citas as i}",
    		ctx
    	});

    	return block;
    }

    // (533:10) {#if user.is('assistant') && cambioHorarioPermitido || user.isAny(['admin', 'operator'])}
    function create_if_block$7(ctx) {
    	let article;
    	let div0;
    	let h5;
    	let i;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let each_value_1 = /*diasSemana*/ ctx[12];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			article = element("article");
    			div0 = element("div");
    			h5 = element("h5");
    			i = element("i");
    			t0 = text("\r\n                Horario del especialista");
    			t1 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(i, "class", "mdi mdi-calendar-text");
    			add_location(i, file$c, 536, 16, 17207);
    			attr_dev(h5, "class", "m-b-0");
    			add_location(h5, file$c, 535, 14, 17171);
    			attr_dev(div0, "class", "card-header");
    			add_location(div0, file$c, 534, 12, 17130);
    			attr_dev(div1, "class", "card-body");
    			add_location(div1, file$c, 540, 12, 17339);
    			attr_dev(article, "class", "card m-b-30 horarioEspecialista");
    			add_location(article, file$c, 533, 10, 17067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			append_dev(article, div0);
    			append_dev(div0, h5);
    			append_dev(h5, i);
    			append_dev(h5, t0);
    			append_dev(article, t1);
    			append_dev(article, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*diasSemana, tandas, horarios, id, cargarHorarios, buscarDisponibilidadHorario*/ 217184) {
    				each_value_1 = /*diasSemana*/ ctx[12];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(533:10) {#if user.is('assistant') && cambioHorarioPermitido || user.isAny(['admin', 'operator'])}",
    		ctx
    	});

    	return block;
    }

    // (542:14) {#each diasSemana as item}
    function create_each_block_1$6(ctx) {
    	let current;

    	const diasemana = new DiaSemana({
    			props: {
    				item: /*item*/ ctx[51],
    				tandas: /*tandas*/ ctx[6],
    				horarios: /*horarios*/ ctx[5],
    				medicoID: /*id*/ ctx[14]
    			},
    			$$inline: true
    		});

    	diasemana.$on("cambioHorario", /*cargarHorarios*/ ctx[16]);
    	diasemana.$on("cambioHorario", /*buscarDisponibilidadHorario*/ ctx[17]);

    	const block = {
    		c: function create() {
    			create_component(diasemana.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(diasemana, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const diasemana_changes = {};
    			if (dirty[0] & /*diasSemana*/ 4096) diasemana_changes.item = /*item*/ ctx[51];
    			if (dirty[0] & /*tandas*/ 64) diasemana_changes.tandas = /*tandas*/ ctx[6];
    			if (dirty[0] & /*horarios*/ 32) diasemana_changes.horarios = /*horarios*/ ctx[5];
    			diasemana.$set(diasemana_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(diasemana.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(diasemana.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(diasemana, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(542:14) {#each diasSemana as item}",
    		ctx
    	});

    	return block;
    }

    // (587:18) {#each prefijos as item}
    function create_each_block$6(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[51].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[51].value;
    			option.value = option.__value;
    			add_location(option, file$c, 587, 20, 18982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(587:18) {#each prefijos as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div33;
    	let h50;
    	let t3;
    	let div32;
    	let div12;
    	let div11;
    	let div0;
    	let t4;
    	let div10;
    	let div3;
    	let div2;
    	let div1;
    	let img;
    	let img_src_value;
    	let t5;
    	let h30;
    	let t6_value = /*detail*/ ctx[0].prefix + "";
    	let t6;
    	let t7;
    	let t8_value = /*detail*/ ctx[0].name + "";
    	let t8;
    	let t9;
    	let div4;
    	let t10_value = (/*detail*/ ctx[0].perfil || "") + "";
    	let t10;
    	let t11;
    	let p0;
    	let t12_value = /*detail*/ ctx[0].email + "";
    	let t12;
    	let t13;
    	let p1;
    	let t14_value = /*detail*/ ctx[0].phoneNumber + "";
    	let t14;
    	let t15;
    	let div9;
    	let div6;
    	let a0;
    	let h31;
    	let t16;
    	let div5;
    	let t18;
    	let div8;
    	let a1;
    	let h32;
    	let t19;
    	let div7;
    	let t21;
    	let div24;
    	let div23;
    	let div15;
    	let h51;
    	let i0;
    	let t22;
    	let t23;
    	let div14;
    	let div13;
    	let button0;
    	let i1;
    	let t24;
    	let t25;
    	let button1;
    	let t27;
    	let div22;
    	let div20;
    	let div17;
    	let div16;
    	let label0;
    	let t29;
    	let input0;
    	let t30;
    	let div19;
    	let div18;
    	let label1;
    	let t32;
    	let select0;
    	let option0;
    	let t34;
    	let t35;
    	let div21;
    	let t36;
    	let div31;
    	let div30;
    	let div27;
    	let h52;
    	let i2;
    	let t37;
    	let t38;
    	let div26;
    	let div25;
    	let input1;
    	let t39;
    	let button2;
    	let t41;
    	let button3;
    	let t43;
    	let button4;
    	let t45;
    	let div29;
    	let t46;
    	let div28;
    	let t47;
    	let show_if = /*user*/ ctx[13].is("assistant") && /*cambioHorarioPermitido*/ ctx[11] || /*user*/ ctx[13].isAny(["admin", "operator"]);
    	let t48;
    	let form;
    	let div50;
    	let div49;
    	let div48;
    	let div34;
    	let h53;
    	let t50;
    	let button5;
    	let span0;
    	let t52;
    	let div46;
    	let input2;
    	let t53;
    	let div36;
    	let div35;
    	let label2;
    	let t55;
    	let select1;
    	let option1;
    	let t57;
    	let div38;
    	let div37;
    	let label3;
    	let t59;
    	let input3;
    	let t60;
    	let div41;
    	let div39;
    	let label4;
    	let t62;
    	let input4;
    	let t63;
    	let div40;
    	let label5;
    	let t65;
    	let input5;
    	let t66;
    	let div45;
    	let div42;
    	let label6;
    	let t68;
    	let input6;
    	let t69;
    	let div43;
    	let label7;
    	let t71;
    	let input7;
    	let t72;
    	let div44;
    	let select2;
    	let option2;
    	let option3;
    	let t74;
    	let span7;
    	let span5;
    	let span4;
    	let span2;
    	let span1;
    	let t76;
    	let span3;
    	let b;
    	let t77;
    	let span6;
    	let t78;
    	let br;
    	let t79;
    	let div47;
    	let button6;
    	let t81;
    	let button7;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value_5 = /*tandas*/ ctx[6];
    	validate_each_argument(each_value_5);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_3[i] = create_each_block_5$3(get_each_context_5$3(ctx, each_value_5, i));
    	}

    	let if_block0 = /*horasDisponibles*/ ctx[7].length <= 0 && create_if_block_2$3(ctx);
    	let each_value_4 = /*horasDisponibles*/ ctx[7];
    	validate_each_argument(each_value_4);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_2[i] = create_each_block_4$4(get_each_context_4$4(ctx, each_value_4, i));
    	}

    	let if_block1 = /*citas*/ ctx[8].length == 0 && create_if_block_1$4(ctx);
    	let each_value_2 = /*citas*/ ctx[8];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i));
    	}

    	let if_block2 = show_if && create_if_block$7(ctx);
    	let each_value = /*prefijos*/ ctx[15];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div33 = element("div");
    			h50 = element("h5");
    			h50.textContent = "Perfil Medico";
    			t3 = space();
    			div32 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div0 = element("div");
    			t4 = space();
    			div10 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			img = element("img");
    			t5 = space();
    			h30 = element("h3");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			div4 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			p0 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			p1 = element("p");
    			t14 = text(t14_value);
    			t15 = space();
    			div9 = element("div");
    			div6 = element("div");
    			a0 = element("a");
    			h31 = element("h3");
    			t16 = space();
    			div5 = element("div");
    			div5.textContent = "Horario";
    			t18 = space();
    			div8 = element("div");
    			a1 = element("a");
    			h32 = element("h3");
    			t19 = space();
    			div7 = element("div");
    			div7.textContent = "Editar Perfil";
    			t21 = space();
    			div24 = element("div");
    			div23 = element("div");
    			div15 = element("div");
    			h51 = element("h5");
    			i0 = element("i");
    			t22 = text("\r\n                Disponibilidad");
    			t23 = space();
    			div14 = element("div");
    			div13 = element("div");
    			button0 = element("button");
    			i1 = element("i");
    			t24 = text("\r\n                    Hoy");
    			t25 = space();
    			button1 = element("button");
    			button1.textContent = "Mañana";
    			t27 = space();
    			div22 = element("div");
    			div20 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			label0 = element("label");
    			label0.textContent = "Fecha";
    			t29 = space();
    			input0 = element("input");
    			t30 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label1 = element("label");
    			label1.textContent = "Tanda";
    			t32 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t34 = space();
    			if (if_block0) if_block0.c();
    			t35 = space();
    			div21 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t36 = space();
    			div31 = element("div");
    			div30 = element("div");
    			div27 = element("div");
    			h52 = element("h5");
    			i2 = element("i");
    			t37 = text("\r\n                Citas programadas");
    			t38 = space();
    			div26 = element("div");
    			div25 = element("div");
    			input1 = element("input");
    			t39 = space();
    			button2 = element("button");
    			button2.textContent = "Hoy";
    			t41 = space();
    			button3 = element("button");
    			button3.textContent = "Mañana";
    			t43 = space();
    			button4 = element("button");
    			button4.textContent = "Semana";
    			t45 = space();
    			div29 = element("div");
    			if (if_block1) if_block1.c();
    			t46 = space();
    			div28 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t47 = space();
    			if (if_block2) if_block2.c();
    			t48 = space();
    			form = element("form");
    			div50 = element("div");
    			div49 = element("div");
    			div48 = element("div");
    			div34 = element("div");
    			h53 = element("h5");
    			h53.textContent = "Usuario";
    			t50 = space();
    			button5 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t52 = space();
    			div46 = element("div");
    			input2 = element("input");
    			t53 = space();
    			div36 = element("div");
    			div35 = element("div");
    			label2 = element("label");
    			label2.textContent = "Prefijo";
    			t55 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "- Seleccionar -";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t57 = space();
    			div38 = element("div");
    			div37 = element("div");
    			label3 = element("label");
    			label3.textContent = "Nombre Completo";
    			t59 = space();
    			input3 = element("input");
    			t60 = space();
    			div41 = element("div");
    			div39 = element("div");
    			label4 = element("label");
    			label4.textContent = "Usuario";
    			t62 = space();
    			input4 = element("input");
    			t63 = space();
    			div40 = element("div");
    			label5 = element("label");
    			label5.textContent = "Email";
    			t65 = space();
    			input5 = element("input");
    			t66 = space();
    			div45 = element("div");
    			div42 = element("div");
    			label6 = element("label");
    			label6.textContent = "Telefono";
    			t68 = space();
    			input6 = element("input");
    			t69 = space();
    			div43 = element("div");
    			label7 = element("label");
    			label7.textContent = "exequatur";
    			t71 = space();
    			input7 = element("input");
    			t72 = space();
    			div44 = element("div");
    			select2 = element("select");
    			option2 = element("option");
    			option3 = element("option");
    			option3.textContent = "Psiquiatría";
    			t74 = space();
    			span7 = element("span");
    			span5 = element("span");
    			span4 = element("span");
    			span2 = element("span");
    			span1 = element("span");
    			span1.textContent = "- Departamento -";
    			t76 = space();
    			span3 = element("span");
    			b = element("b");
    			t77 = space();
    			span6 = element("span");
    			t78 = space();
    			br = element("br");
    			t79 = space();
    			div47 = element("div");
    			button6 = element("button");
    			button6.textContent = "Cerrar";
    			t81 = space();
    			button7 = element("button");
    			button7.textContent = "Guardar";
    			attr_dev(h50, "class", "pt-2 pb-2");
    			add_location(h50, file$c, 325, 6, 8701);
    			attr_dev(div0, "class", "card-header");
    			add_location(div0, file$c, 329, 12, 8864);
    			attr_dev(img, "class", "avatar-img rounded-circle");
    			if (img.src !== (img_src_value = "assets/img/users/user-5.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "name");
    			add_location(img, file$c, 334, 20, 9078);
    			attr_dev(div1, "class", "avatar avatar-xl avatar-online");
    			add_location(div1, file$c, 333, 18, 9012);
    			add_location(div2, file$c, 332, 16, 8987);
    			attr_dev(h30, "class", "p-t-10 searchBy-name");
    			add_location(h30, file$c, 340, 16, 9301);
    			attr_dev(div3, "class", "text-center");
    			add_location(div3, file$c, 331, 14, 8944);
    			attr_dev(div4, "class", "text-muted text-center m-b-10");
    			add_location(div4, file$c, 342, 14, 9406);
    			attr_dev(p0, "class", "text-muted text-center");
    			set_style(p0, "margin-bottom", "0");
    			add_location(p0, file$c, 345, 14, 9526);
    			attr_dev(p1, "class", "text-muted text-center");
    			add_location(p1, file$c, 348, 14, 9654);
    			attr_dev(h31, "class", "mdi mdi-timetable");
    			add_location(h31, file$c, 361, 20, 10211);
    			attr_dev(div5, "class", "text-overline");
    			add_location(div5, file$c, 362, 20, 10269);
    			attr_dev(a0, "href", "#!");
    			add_location(a0, file$c, 351, 18, 9819);
    			attr_dev(div6, "class", "col");
    			add_location(div6, file$c, 350, 16, 9782);
    			attr_dev(h32, "class", "mdi mdi-account-edit");
    			add_location(h32, file$c, 368, 20, 10482);
    			attr_dev(div7, "class", "text-overline");
    			add_location(div7, file$c, 369, 20, 10543);
    			attr_dev(a1, "href", "#/");
    			add_location(a1, file$c, 367, 18, 10414);
    			attr_dev(div8, "class", "col");
    			add_location(div8, file$c, 366, 16, 10377);
    			attr_dev(div9, "class", "row text-center p-b-10");
    			add_location(div9, file$c, 349, 14, 9728);
    			attr_dev(div10, "class", "card-body");
    			add_location(div10, file$c, 330, 12, 8905);
    			attr_dev(div11, "class", "card m-b-30");
    			add_location(div11, file$c, 328, 10, 8825);
    			attr_dev(div12, "class", "col-sm-12 col-lg-4");
    			add_location(div12, file$c, 327, 8, 8781);
    			attr_dev(i0, "class", "mdi mdi-calendar-search");
    			add_location(i0, file$c, 382, 16, 10897);
    			attr_dev(h51, "class", "m-b-0");
    			add_location(h51, file$c, 381, 14, 10861);
    			attr_dev(i1, "class", "mdi mdi-calendar");
    			add_location(i1, file$c, 390, 20, 11368);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn shadow-none btn-sm svelte-1nu1nbu");
    			toggle_class(button0, "btn-primary", /*btnFechaDisponibilidad*/ ctx[9] == "h");
    			toggle_class(button0, "btn-write", /*btnFechaDisponibilidad*/ ctx[9] != "h");
    			add_location(button0, file$c, 387, 18, 11131);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn shadow-none btn-sm svelte-1nu1nbu");
    			toggle_class(button1, "btn-primary", /*btnFechaDisponibilidad*/ ctx[9] == "m");
    			toggle_class(button1, "btn-write", !/*btnFechaDisponibilidad*/ ctx[9] != "m");
    			add_location(button1, file$c, 393, 18, 11472);
    			attr_dev(div13, "class", "btn-group");
    			attr_dev(div13, "role", "group");
    			attr_dev(div13, "aria-label", "Basic example");
    			add_location(div13, file$c, 386, 16, 11048);
    			attr_dev(div14, "class", "card-controls");
    			add_location(div14, file$c, 385, 14, 11003);
    			attr_dev(div15, "class", "card-header");
    			add_location(div15, file$c, 380, 12, 10820);
    			attr_dev(label0, "for", "inputAddress");
    			add_location(label0, file$c, 406, 20, 11991);
    			attr_dev(input0, "type", "date");
    			attr_dev(input0, "class", "form-control form-control-sm");
    			add_location(input0, file$c, 407, 20, 12052);
    			attr_dev(div16, "class", "form-group");
    			add_location(div16, file$c, 405, 18, 11945);
    			attr_dev(div17, "class", "col-lg-6");
    			add_location(div17, file$c, 404, 16, 11903);
    			attr_dev(label1, "class", "font-secondary");
    			add_location(label1, file$c, 413, 20, 12347);
    			option0.__value = "0";
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			add_location(option0, file$c, 416, 22, 12576);
    			attr_dev(select0, "class", "form-control form-control-sm js-select2");
    			if (/*tandaID*/ ctx[4] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[41].call(select0));
    			add_location(select0, file$c, 414, 20, 12412);
    			attr_dev(div18, "class", "form-group ");
    			add_location(div18, file$c, 412, 18, 12300);
    			attr_dev(div19, "class", "col-lg-6");
    			add_location(div19, file$c, 411, 16, 12258);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$c, 403, 14, 11868);
    			attr_dev(div21, "class", "list-group list");
    			add_location(div21, file$c, 430, 14, 13106);
    			attr_dev(div22, "class", "card-body");
    			add_location(div22, file$c, 401, 12, 11827);
    			attr_dev(div23, "class", "card m-b-30");
    			add_location(div23, file$c, 379, 10, 10781);
    			attr_dev(div24, "class", "col-sm-12 col-md-12 col-lg-8");
    			add_location(div24, file$c, 378, 8, 10727);
    			attr_dev(i2, "class", "mdi mdi-calendar-multiselect");
    			add_location(i2, file$c, 457, 16, 14007);
    			attr_dev(h52, "class", "m-b-0");
    			add_location(h52, file$c, 456, 14, 13971);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control form-control-sm");
    			add_location(input1, file$c, 463, 18, 14251);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn shadow-none btn-sm svelte-1nu1nbu");
    			toggle_class(button2, "btn-primary", /*btnFechaCita*/ ctx[10] == "h");
    			toggle_class(button2, "btn-write", /*btnFechaCita*/ ctx[10] != "h");
    			add_location(button2, file$c, 465, 18, 14415);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn shadow-none btn-sm svelte-1nu1nbu");
    			toggle_class(button3, "btn-primary", /*btnFechaCita*/ ctx[10] == "m");
    			toggle_class(button3, "btn-write", /*btnFechaCita*/ ctx[10] != "m");
    			add_location(button3, file$c, 472, 18, 14738);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "btn shadow-none btn-sm svelte-1nu1nbu");
    			toggle_class(button4, "btn-primary", /*btnFechaCita*/ ctx[10] == "s");
    			toggle_class(button4, "btn-write", /*btnFechaCita*/ ctx[10] != "s");
    			add_location(button4, file$c, 479, 18, 15064);
    			attr_dev(div25, "class", "btn-group");
    			attr_dev(div25, "role", "group");
    			attr_dev(div25, "aria-label", "Basic example");
    			add_location(div25, file$c, 462, 16, 14168);
    			attr_dev(div26, "class", "card-controls");
    			add_location(div26, file$c, 460, 14, 14121);
    			attr_dev(div27, "class", "card-header");
    			add_location(div27, file$c, 455, 12, 13930);
    			attr_dev(div28, "class", "row");
    			add_location(div28, file$c, 497, 14, 15693);
    			attr_dev(div29, "class", "card-body");
    			add_location(div29, file$c, 490, 12, 15452);
    			attr_dev(div30, "class", "card m-b-30");
    			add_location(div30, file$c, 454, 10, 13891);
    			attr_dev(div31, "class", "col-lg-12");
    			add_location(div31, file$c, 453, 8, 13856);
    			attr_dev(div32, "class", "row list");
    			add_location(div32, file$c, 326, 6, 8749);
    			attr_dev(div33, "class", "container mt-3");
    			add_location(div33, file$c, 324, 4, 8665);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$c, 323, 2, 8628);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$c, 321, 0, 8585);
    			attr_dev(h53, "class", "modal-title");
    			attr_dev(h53, "id", "modalUsuarioLabel");
    			add_location(h53, file$c, 566, 10, 18133);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$c, 572, 12, 18346);
    			attr_dev(button5, "type", "button");
    			attr_dev(button5, "class", "close");
    			attr_dev(button5, "data-dismiss", "modal");
    			attr_dev(button5, "aria-label", "Close");
    			add_location(button5, file$c, 567, 10, 18204);
    			attr_dev(div34, "class", "modal-header");
    			add_location(div34, file$c, 565, 8, 18095);
    			attr_dev(input2, "type", "hidden");
    			attr_dev(input2, "name", "IdUser");
    			input2.value = "0";
    			add_location(input2, file$c, 577, 12, 18523);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$c, 580, 16, 18674);
    			option1.__value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$c, 585, 18, 18875);
    			attr_dev(select1, "class", "form-control");
    			attr_dev(select1, "name", "prefijo");
    			select1.required = true;
    			if (/*obj*/ ctx[1].prefix === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[47].call(select1));
    			add_location(select1, file$c, 581, 16, 18721);
    			attr_dev(div35, "class", "form-group col-md-12");
    			add_location(div35, file$c, 579, 14, 18622);
    			attr_dev(div36, "class", "form-row");
    			add_location(div36, file$c, 578, 12, 18584);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$c, 594, 16, 19229);
    			attr_dev(input3, "type", "name");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "placeholder", "Ing. John Doe");
    			attr_dev(input3, "name", "Name");
    			attr_dev(input3, "maxlength", "200");
    			input3.required = true;
    			add_location(input3, file$c, 595, 16, 19284);
    			attr_dev(div37, "class", "form-group col-md-12");
    			add_location(div37, file$c, 593, 14, 19177);
    			attr_dev(div38, "class", "form-row");
    			add_location(div38, file$c, 592, 12, 19139);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$c, 607, 16, 19715);
    			attr_dev(input4, "type", "email");
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "autocomplete", "off");
    			attr_dev(input4, "name", "UserName");
    			attr_dev(input4, "id", "");
    			attr_dev(input4, "maxlength", "100");
    			add_location(input4, file$c, 608, 16, 19762);
    			attr_dev(div39, "class", "form-group col-md-12");
    			set_style(div39, "display", "none");
    			add_location(div39, file$c, 606, 14, 19640);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$c, 617, 16, 20066);
    			attr_dev(input5, "type", "email");
    			input5.required = true;
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "placeholder", "usuario@correo.com");
    			attr_dev(input5, "autocomplete", "off");
    			attr_dev(input5, "name", "Email");
    			attr_dev(input5, "id", "txtCorreo");
    			attr_dev(input5, "maxlength", "100");
    			add_location(input5, file$c, 618, 16, 20111);
    			attr_dev(div40, "class", "form-group col-md-12");
    			add_location(div40, file$c, 616, 14, 20014);
    			attr_dev(div41, "class", "form-row");
    			add_location(div41, file$c, 605, 12, 19602);
    			attr_dev(label6, "for", "");
    			add_location(label6, file$c, 633, 16, 20601);
    			attr_dev(input6, "type", "text");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "data-mask", "(000) 000-0000");
    			attr_dev(input6, "data-mask-clearifnotmatch", "true");
    			attr_dev(input6, "autocomplete", "off");
    			attr_dev(input6, "maxlength", "14");
    			attr_dev(input6, "placeholder", "(809) 000-0000");
    			add_location(input6, file$c, 634, 16, 20649);
    			attr_dev(div42, "class", "form-group col-md-12");
    			add_location(div42, file$c, 632, 14, 20549);
    			attr_dev(label7, "for", "");
    			add_location(label7, file$c, 646, 16, 21109);
    			attr_dev(input7, "type", "text");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "utocomplete", "off");
    			attr_dev(input7, "name", "Exequatur");
    			attr_dev(input7, "id", "txtTelefono");
    			add_location(input7, file$c, 647, 16, 21158);
    			attr_dev(div43, "class", "form-group col-md-12");
    			set_style(div43, "display", "none");
    			add_location(div43, file$c, 645, 14, 21034);
    			option2.__value = "";
    			option2.value = option2.__value;
    			add_location(option2, file$c, 662, 18, 21745);
    			option3.__value = "1";
    			option3.value = option3.__value;
    			add_location(option3, file$c, 663, 18, 21784);
    			attr_dev(select2, "name", "IdDepartamento");
    			attr_dev(select2, "class", "js-select2 select2-hidden-accessible");
    			attr_dev(select2, "id", "sltDepartamentos");
    			set_style(select2, "width", "100%");
    			attr_dev(select2, "aria-hidden", "true");
    			attr_dev(select2, "tabindex", "-1");
    			add_location(select2, file$c, 655, 16, 21460);
    			attr_dev(span1, "class", "select2-selection__placeholder");
    			add_location(span1, file$c, 679, 24, 22610);
    			attr_dev(span2, "class", "select2-selection__rendered");
    			attr_dev(span2, "id", "select2-sltDepartamentos-container");
    			attr_dev(span2, "role", "textbox");
    			attr_dev(span2, "aria-readonly", "true");
    			add_location(span2, file$c, 675, 22, 22391);
    			attr_dev(b, "role", "presentation");
    			add_location(b, file$c, 684, 24, 22872);
    			attr_dev(span3, "class", "select2-selection__arrow");
    			attr_dev(span3, "role", "presentation");
    			add_location(span3, file$c, 683, 22, 22787);
    			attr_dev(span4, "class", "select2-selection select2-selection--single");
    			attr_dev(span4, "role", "combobox");
    			attr_dev(span4, "aria-haspopup", "true");
    			attr_dev(span4, "aria-expanded", "false");
    			attr_dev(span4, "tabindex", "0");
    			attr_dev(span4, "aria-labelledby", "select2-sltDepartamentos-container");
    			add_location(span4, file$c, 669, 20, 22069);
    			attr_dev(span5, "class", "selection");
    			add_location(span5, file$c, 668, 18, 22023);
    			attr_dev(span6, "class", "dropdown-wrapper");
    			attr_dev(span6, "aria-hidden", "true");
    			add_location(span6, file$c, 688, 18, 23004);
    			attr_dev(span7, "class", "select2 select2-container select2-container--default");
    			attr_dev(span7, "dir", "ltr");
    			set_style(span7, "width", "100%");
    			add_location(span7, file$c, 665, 16, 21867);
    			attr_dev(div44, "class", "form-group col-md-12");
    			set_style(div44, "display", "none");
    			add_location(div44, file$c, 654, 14, 21385);
    			attr_dev(div45, "class", "form-row");
    			add_location(div45, file$c, 631, 12, 20511);
    			add_location(br, file$c, 692, 12, 23137);
    			attr_dev(div46, "class", "modal-body");
    			set_style(div46, "height", "100%", 1);
    			set_style(div46, "top", "0");
    			set_style(div46, "overflow", "auto");
    			add_location(div46, file$c, 575, 8, 18426);
    			attr_dev(button6, "type", "button");
    			attr_dev(button6, "class", "btn btn-secondary");
    			attr_dev(button6, "data-dismiss", "modal");
    			add_location(button6, file$c, 695, 12, 23213);
    			attr_dev(button7, "type", "submit");
    			attr_dev(button7, "class", "btn btn-success");
    			add_location(button7, file$c, 700, 12, 23371);
    			attr_dev(div47, "class", "modal-footer");
    			add_location(div47, file$c, 694, 10, 23173);
    			attr_dev(div48, "class", "modal-content");
    			add_location(div48, file$c, 564, 6, 18058);
    			attr_dev(div49, "class", "modal-dialog");
    			attr_dev(div49, "role", "document");
    			add_location(div49, file$c, 563, 4, 18008);
    			attr_dev(div50, "class", "modal fade modal-slide-right");
    			attr_dev(div50, "id", "modalUsuario");
    			attr_dev(div50, "tabindex", "-1");
    			attr_dev(div50, "role", "dialog");
    			attr_dev(div50, "aria-labelledby", "modalUsuarioLabel");
    			set_style(div50, "display", "none");
    			set_style(div50, "padding-right", "16px");
    			attr_dev(div50, "aria-modal", "true");
    			add_location(div50, file$c, 556, 2, 17786);
    			attr_dev(form, "id", "frmUsuario");
    			add_location(form, file$c, 555, 0, 17725);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div33);
    			append_dev(div33, h50);
    			append_dev(div33, t3);
    			append_dev(div33, div32);
    			append_dev(div32, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div0);
    			append_dev(div11, t4);
    			append_dev(div11, div10);
    			append_dev(div10, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, img);
    			append_dev(div3, t5);
    			append_dev(div3, h30);
    			append_dev(h30, t6);
    			append_dev(h30, t7);
    			append_dev(h30, t8);
    			append_dev(div10, t9);
    			append_dev(div10, div4);
    			append_dev(div4, t10);
    			append_dev(div10, t11);
    			append_dev(div10, p0);
    			append_dev(p0, t12);
    			append_dev(div10, t13);
    			append_dev(div10, p1);
    			append_dev(p1, t14);
    			append_dev(div10, t15);
    			append_dev(div10, div9);
    			append_dev(div9, div6);
    			append_dev(div6, a0);
    			append_dev(a0, h31);
    			append_dev(a0, t16);
    			append_dev(a0, div5);
    			append_dev(div9, t18);
    			append_dev(div9, div8);
    			append_dev(div8, a1);
    			append_dev(a1, h32);
    			append_dev(a1, t19);
    			append_dev(a1, div7);
    			append_dev(div32, t21);
    			append_dev(div32, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div15);
    			append_dev(div15, h51);
    			append_dev(h51, i0);
    			append_dev(h51, t22);
    			append_dev(div15, t23);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, button0);
    			append_dev(button0, i1);
    			append_dev(button0, t24);
    			append_dev(div13, t25);
    			append_dev(div13, button1);
    			append_dev(div23, t27);
    			append_dev(div23, div22);
    			append_dev(div22, div20);
    			append_dev(div20, div17);
    			append_dev(div17, div16);
    			append_dev(div16, label0);
    			append_dev(div16, t29);
    			append_dev(div16, input0);
    			set_input_value(input0, /*fecha*/ ctx[2]);
    			append_dev(div20, t30);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label1);
    			append_dev(div18, t32);
    			append_dev(div18, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select0, null);
    			}

    			select_option(select0, /*tandaID*/ ctx[4]);
    			append_dev(div22, t34);
    			if (if_block0) if_block0.m(div22, null);
    			append_dev(div22, t35);
    			append_dev(div22, div21);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div21, null);
    			}

    			append_dev(div32, t36);
    			append_dev(div32, div31);
    			append_dev(div31, div30);
    			append_dev(div30, div27);
    			append_dev(div27, h52);
    			append_dev(h52, i2);
    			append_dev(h52, t37);
    			append_dev(div27, t38);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, input1);
    			set_input_value(input1, /*fechaBusquedaCita*/ ctx[3]);
    			append_dev(div25, t39);
    			append_dev(div25, button2);
    			append_dev(div25, t41);
    			append_dev(div25, button3);
    			append_dev(div25, t43);
    			append_dev(div25, button4);
    			append_dev(div30, t45);
    			append_dev(div30, div29);
    			if (if_block1) if_block1.m(div29, null);
    			append_dev(div29, t46);
    			append_dev(div29, div28);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div28, null);
    			}

    			append_dev(div31, t47);
    			if (if_block2) if_block2.m(div31, null);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div50);
    			append_dev(div50, div49);
    			append_dev(div49, div48);
    			append_dev(div48, div34);
    			append_dev(div34, h53);
    			append_dev(div34, t50);
    			append_dev(div34, button5);
    			append_dev(button5, span0);
    			append_dev(div48, t52);
    			append_dev(div48, div46);
    			append_dev(div46, input2);
    			append_dev(div46, t53);
    			append_dev(div46, div36);
    			append_dev(div36, div35);
    			append_dev(div35, label2);
    			append_dev(div35, t55);
    			append_dev(div35, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			select_option(select1, /*obj*/ ctx[1].prefix);
    			append_dev(div46, t57);
    			append_dev(div46, div38);
    			append_dev(div38, div37);
    			append_dev(div37, label3);
    			append_dev(div37, t59);
    			append_dev(div37, input3);
    			set_input_value(input3, /*obj*/ ctx[1].name);
    			append_dev(div46, t60);
    			append_dev(div46, div41);
    			append_dev(div41, div39);
    			append_dev(div39, label4);
    			append_dev(div39, t62);
    			append_dev(div39, input4);
    			append_dev(div41, t63);
    			append_dev(div41, div40);
    			append_dev(div40, label5);
    			append_dev(div40, t65);
    			append_dev(div40, input5);
    			set_input_value(input5, /*obj*/ ctx[1].email);
    			append_dev(div46, t66);
    			append_dev(div46, div45);
    			append_dev(div45, div42);
    			append_dev(div42, label6);
    			append_dev(div42, t68);
    			append_dev(div42, input6);
    			set_input_value(input6, /*obj*/ ctx[1].phoneNumber);
    			append_dev(div45, t69);
    			append_dev(div45, div43);
    			append_dev(div43, label7);
    			append_dev(div43, t71);
    			append_dev(div43, input7);
    			append_dev(div45, t72);
    			append_dev(div45, div44);
    			append_dev(div44, select2);
    			append_dev(select2, option2);
    			append_dev(select2, option3);
    			append_dev(div44, t74);
    			append_dev(div44, span7);
    			append_dev(span7, span5);
    			append_dev(span5, span4);
    			append_dev(span4, span2);
    			append_dev(span2, span1);
    			append_dev(span4, t76);
    			append_dev(span4, span3);
    			append_dev(span3, b);
    			append_dev(span7, t77);
    			append_dev(span7, span6);
    			append_dev(div46, t78);
    			append_dev(div46, br);
    			append_dev(div48, t79);
    			append_dev(div48, div47);
    			append_dev(div47, button6);
    			append_dev(div47, t81);
    			append_dev(div47, button7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", prevent_default(/*click_handler*/ ctx[39]), false, true, false),
    					listen_dev(a1, "click", prevent_default(/*editar*/ ctx[22]), false, true, false),
    					listen_dev(button0, "click", /*diaDeHoy*/ ctx[20], false, false, false),
    					listen_dev(button1, "click", /*diaSiguiente*/ ctx[19], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[40]),
    					listen_dev(input0, "input", /*buscarDisponibilidadHorario*/ ctx[17], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[41]),
    					listen_dev(select0, "change", /*buscarDisponibilidadHorario*/ ctx[17], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[42]),
    					listen_dev(input1, "change", /*change_handler*/ ctx[43], false, false, false),
    					listen_dev(button2, "click", /*click_handler_1*/ ctx[44], false, false, false),
    					listen_dev(button3, "click", /*click_handler_2*/ ctx[45], false, false, false),
    					listen_dev(button4, "click", /*click_handler_3*/ ctx[46], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[47]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[48]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[49]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[50]),
    					listen_dev(form, "submit", prevent_default(/*guardar*/ ctx[23]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*detail*/ 1) && t6_value !== (t6_value = /*detail*/ ctx[0].prefix + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*detail*/ 1) && t8_value !== (t8_value = /*detail*/ ctx[0].name + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty[0] & /*detail*/ 1) && t10_value !== (t10_value = (/*detail*/ ctx[0].perfil || "") + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty[0] & /*detail*/ 1) && t12_value !== (t12_value = /*detail*/ ctx[0].email + "")) set_data_dev(t12, t12_value);
    			if ((!current || dirty[0] & /*detail*/ 1) && t14_value !== (t14_value = /*detail*/ ctx[0].phoneNumber + "")) set_data_dev(t14, t14_value);

    			if (dirty[0] & /*btnFechaDisponibilidad*/ 512) {
    				toggle_class(button0, "btn-primary", /*btnFechaDisponibilidad*/ ctx[9] == "h");
    			}

    			if (dirty[0] & /*btnFechaDisponibilidad*/ 512) {
    				toggle_class(button0, "btn-write", /*btnFechaDisponibilidad*/ ctx[9] != "h");
    			}

    			if (dirty[0] & /*btnFechaDisponibilidad*/ 512) {
    				toggle_class(button1, "btn-primary", /*btnFechaDisponibilidad*/ ctx[9] == "m");
    			}

    			if (dirty[0] & /*btnFechaDisponibilidad*/ 512) {
    				toggle_class(button1, "btn-write", !/*btnFechaDisponibilidad*/ ctx[9] != "m");
    			}

    			if (dirty[0] & /*fecha*/ 4) {
    				set_input_value(input0, /*fecha*/ ctx[2]);
    			}

    			if (dirty[0] & /*tandas*/ 64) {
    				each_value_5 = /*tandas*/ ctx[6];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$3(ctx, each_value_5, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_5$3(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_5.length;
    			}

    			if (dirty[0] & /*tandaID, tandas*/ 80) {
    				select_option(select0, /*tandaID*/ ctx[4]);
    			}

    			if (/*horasDisponibles*/ ctx[7].length <= 0) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					if_block0.m(div22, t35);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*crearCita, horasDisponibles*/ 262272) {
    				each_value_4 = /*horasDisponibles*/ ctx[7];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$4(ctx, each_value_4, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_4$4(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div21, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_4.length;
    			}

    			if (dirty[0] & /*fechaBusquedaCita*/ 8) {
    				set_input_value(input1, /*fechaBusquedaCita*/ ctx[3]);
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button2, "btn-primary", /*btnFechaCita*/ ctx[10] == "h");
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button2, "btn-write", /*btnFechaCita*/ ctx[10] != "h");
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button3, "btn-primary", /*btnFechaCita*/ ctx[10] == "m");
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button3, "btn-write", /*btnFechaCita*/ ctx[10] != "m");
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button4, "btn-primary", /*btnFechaCita*/ ctx[10] == "s");
    			}

    			if (dirty[0] & /*btnFechaCita*/ 1024) {
    				toggle_class(button4, "btn-write", /*btnFechaCita*/ ctx[10] != "s");
    			}

    			if (/*citas*/ ctx[8].length == 0) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					if_block1.m(div29, t46);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*citas*/ 256) {
    				each_value_2 = /*citas*/ ctx[8];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$5(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$5(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div28, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*cambioHorarioPermitido*/ 2048) show_if = /*user*/ ctx[13].is("assistant") && /*cambioHorarioPermitido*/ ctx[11] || /*user*/ ctx[13].isAny(["admin", "operator"]);

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*cambioHorarioPermitido*/ 2048) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$7(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div31, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*prefijos*/ 32768) {
    				each_value = /*prefijos*/ ctx[15];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*obj, prefijos*/ 32770) {
    				select_option(select1, /*obj*/ ctx[1].prefix);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 32770) {
    				set_input_value(input3, /*obj*/ ctx[1].name);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 32770 && input5.value !== /*obj*/ ctx[1].email) {
    				set_input_value(input5, /*obj*/ ctx[1].email);
    			}

    			if (dirty[0] & /*obj, prefijos*/ 32770 && input6.value !== /*obj*/ ctx[1].phoneNumber) {
    				set_input_value(input6, /*obj*/ ctx[1].phoneNumber);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks_3, detaching);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks_2, detaching);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks_1, detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(form);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $session;
    	let $axios;
    	let $activePage;
    	let $dataCita;
    	let $errorConexion;
    	let $toast;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(27, $session = $$value));
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(28, $axios = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(29, $activePage = $$value));
    	validate_store(dataCita, "dataCita");
    	component_subscribe($$self, dataCita, $$value => $$invalidate(30, $dataCita = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(31, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(32, $toast = $$value));
    	let user = new UserManager($session.authorizationHeader.Authorization);

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "mantenimiento.peril");
    	let { params = {} } = $$props;
    	let id = params.id;
    	let data = $dataCita;

    	let detail = {
    		medicoID: "",
    		name: "",
    		email: "",
    		perfil: "",
    		phoneNumber: ""
    	};

    	let obj = {
    		medicoID: "",
    		name: "",
    		email: "",
    		perfilID: 0,
    		phoneNumber: ""
    	};

    	let prefijos = [
    		{ value: "Dr", name: "Dr." },
    		{ value: "Dra", name: "Dra." },
    		{ value: "Lic", name: "Lic." },
    		{ value: "Lida", name: "Lida." },
    		{ value: "Sr", name: "Sr." },
    		{ value: "Sra", name: "Sra." }
    	];

    	let fecha = "";
    	let fechaBusquedaCita = "";
    	let tandaID = 0;
    	let perfiles = [];
    	let horarios = [];
    	let tandas = [];
    	let horasDisponibles = [];
    	let citas = [];
    	let citasDB = [];
    	let btnFechaDisponibilidad = "h";
    	let btnFechaCita = "";
    	let cambioHorarioPermitido = false;

    	let diasSemana = [
    		{ check: false, dia: 1, nombre: "Lunes" },
    		{ check: false, dia: 2, nombre: "Martes" },
    		{
    			check: false,
    			dia: 3,
    			nombre: "Miercoles"
    		},
    		{ check: false, dia: 4, nombre: "Jueves" },
    		{ check: false, dia: 5, nombre: "Viernes" },
    		{ check: false, dia: 6, nombre: "Sabado" },
    		{ check: false, dia: 7, nombre: "Domingo" }
    	];

    	onMount(() => {
    		$$invalidate(10, btnFechaCita = "s");

    		if ($dataCita.fechaCita == "" || $dataCita.fechaCita == undefined) {
    			$$invalidate(2, fecha = moment().format("YYYY-MM-DD"));
    			$$invalidate(4, tandaID = 1);
    		} else {
    			$$invalidate(2, fecha = $dataCita.fechaCita);
    			$$invalidate(4, tandaID = $dataCita.tandaID);
    		}

    		cargarMedicosDelAsistente();
    		cargarDetalle();
    		buscarDisponibilidadHorario();
    		cargarHorarios();
    		cargarTandas();
    		cargarCitas();
    		cargarPerfiles();
    	});

    	function cargarMedicosDelAsistente() {
    		$axios.get("/MedicosAsistentes/" + user.nameid + "/Medicos").then(res => {
    			$$invalidate(11, cambioHorarioPermitido = res.data.some(x => x.medicoID == id));
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarDetalle() {
    		$axios.get("/Medicos/" + id).then(res => {
    			$$invalidate(0, detail = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarTandas() {
    		$axios.get("/Tandas/GetAll").then(res => {
    			$$invalidate(6, tandas = res.data);
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarHorarios() {
    		$axios.get("/Medicos/Horarios/" + id).then(res => {
    			$$invalidate(5, horarios = res.data);

    			$$invalidate(12, diasSemana = diasSemana.map(e => {
    				return {
    					check: horarios.some(i => i.dia == e.dia && !i.inactivo),
    					dia: e.dia,
    					nombre: e.nombre
    				};
    			}));
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarCitas() {
    		$axios.get("/Medicos/Citas/" + id).then(res => {
    			let datos = res.data.map(x => {
    				return {
    					fecha: moment(x.fecha).format("LL"),
    					hora: moment(x.fecha).format("LT"),
    					observaciones: x.observaciones,
    					nombrePaciente: x.nombrePaciente
    				};
    			});

    			let diasUnicos = [
    				...new Set(datos.map(e => {
    						return e.fecha;
    					}))
    			];

    			diasUnicos.sort();

    			citasDB = diasUnicos.map(e => {
    				let horas = datos.filter(i => i.fecha == e).map(e => {
    					return {
    						hora: moment(e.hora, "LT"),
    						nombrePaciente: e.nombrePaciente,
    						observaciones: e.observaciones
    					};
    				});

    				return {
    					fecha: e,
    					horas: horas.sort((e, i) => e.hora - i.hora).map(x => {
    						return {
    							hora: moment(x.hora).format("LT"),
    							nombrePaciente: x.nombrePaciente,
    							observaciones: x.observaciones
    						};
    					})
    				};
    			});

    			$$invalidate(8, citas = citasDB);
    			buscarCitas("s");
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function cargarPerfiles() {
    		$axios.get("/Perfiles/GetAll").then(res => {
    			perfiles = res.data;
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function buscarDisponibilidadHorario() {
    		if (fecha == "" || tandaID <= 0) {
    			$$invalidate(7, horasDisponibles = []);
    			return;
    		}

    		if (fecha == moment().format("YYYY-MM-DD")) {
    			$$invalidate(9, btnFechaDisponibilidad = "h");
    		} else if (fecha == moment().add(moment.duration(1, "d")).format("YYYY-MM-DD")) {
    			$$invalidate(9, btnFechaDisponibilidad = "m");
    		} else {
    			$$invalidate(9, btnFechaDisponibilidad = "");
    		}

    		let params = "date=" + fecha + "&" + "tandiId=" + tandaID;

    		$axios.get("/Medicos/HorasDisponibles/" + id + "?" + params).then(res => {
    			$$invalidate(7, horasDisponibles = res.data.map(e => {
    				return {
    					time: e,
    					hora: moment(e, "LT").format("LT")
    				};
    			}));
    		}).catch(err => {
    			$$invalidate(7, horasDisponibles = []);
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function crearCita(hora) {
    		set_store_value(dataCita, $dataCita = {
    			fechaCita: fecha,
    			tandaID,
    			hora,
    			medicoId: id
    		});

    		push("/Cita/Crear/");
    	}

    	function diaSiguiente(params) {
    		$$invalidate(2, fecha = moment().add(moment.duration(1, "d")).format("YYYY-MM-DD"));
    		$$invalidate(9, btnFechaDisponibilidad = "m");
    		buscarDisponibilidadHorario();
    	}

    	function diaDeHoy(params) {
    		$$invalidate(2, fecha = moment().format("YYYY-MM-DD"));
    		$$invalidate(9, btnFechaDisponibilidad = "h");
    		buscarDisponibilidadHorario();
    	}

    	function buscarCitas(tipo) {
    		let hoy = moment();
    		$$invalidate(10, btnFechaCita = tipo);

    		if (tipo == "h") {
    			$$invalidate(3, fechaBusquedaCita = hoy.format("YYYY-MM-DD"));
    			$$invalidate(8, citas = citasDB.filter(e => e.fecha == hoy.format("LL")));
    		} else if (tipo == "m") {
    			hoy.add(moment.duration(1, "d"));
    			$$invalidate(3, fechaBusquedaCita = hoy.format("YYYY-MM-DD"));
    			$$invalidate(8, citas = citasDB.filter(e => e.fecha == hoy.format("LL")));
    		} else if (tipo == "s") {
    			$$invalidate(3, fechaBusquedaCita = "");
    			$$invalidate(8, citas = citasDB.filter(e => moment(e.fecha).format("W") == hoy.format("W")));
    		} else {
    			if (fechaBusquedaCita == hoy.format("YYYY-MM-DD")) {
    				$$invalidate(10, btnFechaCita = "h");
    			} else if (fechaBusquedaCita == hoy.add(moment.duration(1, "d")).format("YYYY-MM-DD")) {
    				$$invalidate(10, btnFechaCita = "m");
    			} else if (moment(fechaBusquedaCita).format("W") == hoy.format("W")) {
    				$$invalidate(10, btnFechaCita = "s");
    			} else {
    				$$invalidate(10, btnFechaCita = "");
    			}

    			$$invalidate(8, citas = citasDB.filter(e => e.fecha == moment(fechaBusquedaCita).format("LL")));
    		}
    	}

    	function editar() {
    		$axios.get("/Users/" + id).then(res => {
    			$$invalidate(1, obj = res.data);
    			jQuery("#modalUsuario").modal("show");
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function guardar() {
    		$axios.put("/Users/" + id, obj).then(res => {
    			if (res.data.success) {
    				$toast(5000).fire({
    					icon: "success",
    					title: "Medico actualizado con exito"
    				});

    				jQuery("#modalUsuario").modal("hide");
    				cargarDetalle();
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<Perfil> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Perfil", $$slots, []);

    	const click_handler = () => {
    		document.querySelector(".horarioEspecialista").scrollIntoView({ behavior: "smooth", block: "center" });
    	};

    	function input0_input_handler() {
    		fecha = this.value;
    		$$invalidate(2, fecha);
    	}

    	function select0_change_handler() {
    		tandaID = select_value(this);
    		$$invalidate(4, tandaID);
    		$$invalidate(6, tandas);
    	}

    	function input1_input_handler() {
    		fechaBusquedaCita = this.value;
    		$$invalidate(3, fechaBusquedaCita);
    	}

    	const change_handler = () => buscarCitas("f");
    	const click_handler_1 = () => buscarCitas("h");
    	const click_handler_2 = () => buscarCitas("m");
    	const click_handler_3 = () => buscarCitas("s");

    	function select1_change_handler() {
    		obj.prefix = select_value(this);
    		$$invalidate(1, obj);
    		$$invalidate(15, prefijos);
    	}

    	function input3_input_handler() {
    		obj.name = this.value;
    		$$invalidate(1, obj);
    		$$invalidate(15, prefijos);
    	}

    	function input5_input_handler() {
    		obj.email = this.value;
    		$$invalidate(1, obj);
    		$$invalidate(15, prefijos);
    	}

    	function input6_input_handler() {
    		obj.phoneNumber = this.value;
    		$$invalidate(1, obj);
    		$$invalidate(15, prefijos);
    	}

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(24, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		DiaSemana,
    		push,
    		activePage,
    		dataCita,
    		axios: axios$2,
    		session,
    		errorConexion,
    		toast,
    		UserManager,
    		onMount,
    		moment,
    		user,
    		params,
    		id,
    		data,
    		detail,
    		obj,
    		prefijos,
    		fecha,
    		fechaBusquedaCita,
    		tandaID,
    		perfiles,
    		horarios,
    		tandas,
    		horasDisponibles,
    		citas,
    		citasDB,
    		btnFechaDisponibilidad,
    		btnFechaCita,
    		cambioHorarioPermitido,
    		diasSemana,
    		cargarMedicosDelAsistente,
    		cargarDetalle,
    		cargarTandas,
    		cargarHorarios,
    		cargarCitas,
    		cargarPerfiles,
    		buscarDisponibilidadHorario,
    		crearCita,
    		diaSiguiente,
    		diaDeHoy,
    		buscarCitas,
    		editar,
    		guardar,
    		$session,
    		$axios,
    		$activePage,
    		$dataCita,
    		$errorConexion,
    		$toast
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) $$invalidate(13, user = $$props.user);
    		if ("params" in $$props) $$invalidate(24, params = $$props.params);
    		if ("id" in $$props) $$invalidate(14, id = $$props.id);
    		if ("data" in $$props) data = $$props.data;
    		if ("detail" in $$props) $$invalidate(0, detail = $$props.detail);
    		if ("obj" in $$props) $$invalidate(1, obj = $$props.obj);
    		if ("prefijos" in $$props) $$invalidate(15, prefijos = $$props.prefijos);
    		if ("fecha" in $$props) $$invalidate(2, fecha = $$props.fecha);
    		if ("fechaBusquedaCita" in $$props) $$invalidate(3, fechaBusquedaCita = $$props.fechaBusquedaCita);
    		if ("tandaID" in $$props) $$invalidate(4, tandaID = $$props.tandaID);
    		if ("perfiles" in $$props) perfiles = $$props.perfiles;
    		if ("horarios" in $$props) $$invalidate(5, horarios = $$props.horarios);
    		if ("tandas" in $$props) $$invalidate(6, tandas = $$props.tandas);
    		if ("horasDisponibles" in $$props) $$invalidate(7, horasDisponibles = $$props.horasDisponibles);
    		if ("citas" in $$props) $$invalidate(8, citas = $$props.citas);
    		if ("citasDB" in $$props) citasDB = $$props.citasDB;
    		if ("btnFechaDisponibilidad" in $$props) $$invalidate(9, btnFechaDisponibilidad = $$props.btnFechaDisponibilidad);
    		if ("btnFechaCita" in $$props) $$invalidate(10, btnFechaCita = $$props.btnFechaCita);
    		if ("cambioHorarioPermitido" in $$props) $$invalidate(11, cambioHorarioPermitido = $$props.cambioHorarioPermitido);
    		if ("diasSemana" in $$props) $$invalidate(12, diasSemana = $$props.diasSemana);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		detail,
    		obj,
    		fecha,
    		fechaBusquedaCita,
    		tandaID,
    		horarios,
    		tandas,
    		horasDisponibles,
    		citas,
    		btnFechaDisponibilidad,
    		btnFechaCita,
    		cambioHorarioPermitido,
    		diasSemana,
    		user,
    		id,
    		prefijos,
    		cargarHorarios,
    		buscarDisponibilidadHorario,
    		crearCita,
    		diaSiguiente,
    		diaDeHoy,
    		buscarCitas,
    		editar,
    		guardar,
    		params,
    		perfiles,
    		citasDB,
    		$session,
    		$axios,
    		$activePage,
    		$dataCita,
    		$errorConexion,
    		$toast,
    		data,
    		cargarMedicosDelAsistente,
    		cargarDetalle,
    		cargarTandas,
    		cargarCitas,
    		cargarPerfiles,
    		click_handler,
    		input0_input_handler,
    		select0_change_handler,
    		input1_input_handler,
    		change_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		select1_change_handler,
    		input3_input_handler,
    		input5_input_handler,
    		input6_input_handler
    	];
    }

    class Perfil extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { params: 24 }, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Perfil",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get params() {
    		throw new Error("<Perfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Perfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Medico\EspacioTrabajo.svelte generated by Svelte v3.23.0 */

    const { Object: Object_1$2, console: console_1$a } = globals;
    const file$d = "src\\Pages\\Medico\\EspacioTrabajo.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (191:16) {#each citas as item}
    function create_each_block$7(ctx) {
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let span0;
    	let t0_value = /*item*/ ctx[19].nombrePaciente + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let t3_value = (/*item*/ ctx[19].cedula || "") + "";
    	let t3;
    	let t4;
    	let div1;
    	let t5_value = /*item*/ ctx[19].observaciones + "";
    	let t5;
    	let t6;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[17](/*item*/ ctx[19], ...args);
    	}

    	function dblclick_handler(...args) {
    		return /*dblclick_handler*/ ctx[18](/*item*/ ctx[19], ...args);
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text("\r\n                        »\r\n                        ");
    			span1 = element("span");
    			t2 = text("Ced.: ");
    			t3 = text(t3_value);
    			t4 = space();
    			div1 = element("div");
    			t5 = text(t5_value);
    			t6 = space();
    			set_style(span0, "font-weight", "bold");
    			add_location(span0, file$d, 202, 24, 6435);
    			add_location(span1, file$d, 204, 24, 6549);
    			attr_dev(div0, "class", "name");
    			add_location(div0, file$d, 201, 22, 6391);
    			attr_dev(div1, "class", "text-muted svelte-17vubv2");
    			add_location(div1, file$d, 206, 22, 6641);
    			attr_dev(div2, "class", "");
    			add_location(div2, file$d, 200, 20, 6353);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$d, 199, 18, 6314);
    			attr_dev(div4, "class", "list-group-item d-flex align-items-center\r\n                  link-pacientes svelte-1p1f2vm active-select svelte-17vubv2");
    			set_style(div4, "cursor", "pointer");
    			toggle_class(div4, "activo", /*envioPacienteActual*/ ctx[2] == /*item*/ ctx[19].pacienteID);
    			toggle_class(div4, "active-select", /*pacienteSeleccionado*/ ctx[3] == /*item*/ ctx[19].pacienteID);
    			add_location(div4, file$d, 191, 16, 5802);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			append_dev(span1, t3);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, t5);
    			append_dev(div4, t6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div4, "click", click_handler, false, false, false),
    					listen_dev(div4, "dblclick", dblclick_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*citas*/ 16 && t0_value !== (t0_value = /*item*/ ctx[19].nombrePaciente + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*citas*/ 16 && t3_value !== (t3_value = (/*item*/ ctx[19].cedula || "") + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*citas*/ 16 && t5_value !== (t5_value = /*item*/ ctx[19].observaciones + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*envioPacienteActual, citas*/ 20) {
    				toggle_class(div4, "activo", /*envioPacienteActual*/ ctx[2] == /*item*/ ctx[19].pacienteID);
    			}

    			if (dirty & /*pacienteSeleccionado, citas*/ 24) {
    				toggle_class(div4, "active-select", /*pacienteSeleccionado*/ ctx[3] == /*item*/ ctx[19].pacienteID);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(191:16) {#each citas as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let t0;
    	let main;
    	let t1;
    	let section;
    	let div23;
    	let div22;
    	let div0;
    	let button;
    	let i;
    	let t2;
    	let t3;
    	let div5;
    	let div4;
    	let div1;
    	let h50;
    	let t5;
    	let div3;
    	let div2;
    	let t6;
    	let div21;
    	let div20;
    	let div6;
    	let h51;
    	let t8;
    	let div19;
    	let form;
    	let input0;
    	let t9;
    	let div18;
    	let div7;
    	let label0;
    	let t11;
    	let input1;
    	let input1_value_value;
    	let t12;
    	let div8;
    	let label1;
    	let t14;
    	let input2;
    	let input2_value_value;
    	let t15;
    	let div9;
    	let label2;
    	let t17;
    	let input3;
    	let input3_value_value;
    	let t18;
    	let div10;
    	let label3;
    	let t20;
    	let input4;
    	let input4_value_value;
    	let t21;
    	let div11;
    	let label4;
    	let t23;
    	let input5;
    	let input5_value_value;
    	let t24;
    	let div12;
    	let label5;
    	let t26;
    	let input6;
    	let input6_value_value;
    	let t27;
    	let div13;
    	let label6;
    	let t29;
    	let input7;
    	let input7_value_value;
    	let t30;
    	let div14;
    	let label7;
    	let t32;
    	let input8;
    	let input8_value_value;
    	let t33;
    	let div15;
    	let label8;
    	let t35;
    	let input9;
    	let input9_value_value;
    	let t36;
    	let div16;
    	let label9;
    	let t38;
    	let textarea0;
    	let textarea0_value_value;
    	let t39;
    	let div17;
    	let label10;
    	let t41;
    	let textarea1;
    	let textarea1_value_value;
    	let t42;
    	let br;
    	let current;
    	let mounted;
    	let dispose;
    	const aside = new Aside({ $$inline: true });
    	const header = new Header({ $$inline: true });
    	let each_value = /*citas*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div23 = element("div");
    			div22 = element("div");
    			div0 = element("div");
    			button = element("button");
    			i = element("i");
    			t2 = text("\r\n            Terminar cita");
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			h50 = element("h5");
    			h50.textContent = "Lista de citas";
    			t5 = space();
    			div3 = element("div");
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div6 = element("div");
    			h51 = element("h5");
    			h51.textContent = "Paciente actual";
    			t8 = space();
    			div19 = element("div");
    			form = element("form");
    			input0 = element("input");
    			t9 = space();
    			div18 = element("div");
    			div7 = element("div");
    			label0 = element("label");
    			label0.textContent = "Nombre";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			div8 = element("div");
    			label1 = element("label");
    			label1.textContent = "Apellido";
    			t14 = space();
    			input2 = element("input");
    			t15 = space();
    			div9 = element("div");
    			label2 = element("label");
    			label2.textContent = "Cedula";
    			t17 = space();
    			input3 = element("input");
    			t18 = space();
    			div10 = element("div");
    			label3 = element("label");
    			label3.textContent = "Telefono";
    			t20 = space();
    			input4 = element("input");
    			t21 = space();
    			div11 = element("div");
    			label4 = element("label");
    			label4.textContent = "Correo electronico";
    			t23 = space();
    			input5 = element("input");
    			t24 = space();
    			div12 = element("div");
    			label5 = element("label");
    			label5.textContent = "Aseguradora";
    			t26 = space();
    			input6 = element("input");
    			t27 = space();
    			div13 = element("div");
    			label6 = element("label");
    			label6.textContent = "No. Seguro";
    			t29 = space();
    			input7 = element("input");
    			t30 = space();
    			div14 = element("div");
    			label7 = element("label");
    			label7.textContent = "Pais";
    			t32 = space();
    			input8 = element("input");
    			t33 = space();
    			div15 = element("div");
    			label8 = element("label");
    			label8.textContent = "Provincia";
    			t35 = space();
    			input9 = element("input");
    			t36 = space();
    			div16 = element("div");
    			label9 = element("label");
    			label9.textContent = "Direccion";
    			t38 = space();
    			textarea0 = element("textarea");
    			t39 = space();
    			div17 = element("div");
    			label10 = element("label");
    			label10.textContent = "Observaciones";
    			t41 = space();
    			textarea1 = element("textarea");
    			t42 = space();
    			br = element("br");
    			attr_dev(i, "class", "mdi mdi-check-all");
    			add_location(i, file$d, 179, 12, 5362);
    			attr_dev(button, "class", "btn btn-success");
    			toggle_class(button, "d-none", /*envioPacienteActual*/ ctx[2] == "" || /*citaPacienteActual*/ ctx[0] == undefined);
    			add_location(button, file$d, 177, 10, 5202);
    			attr_dev(div0, "class", "col-lg-12 mb-3");
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$d, 172, 8, 4964);
    			attr_dev(h50, "class", "m-b-0");
    			add_location(h50, file$d, 186, 14, 5605);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$d, 185, 12, 5564);
    			attr_dev(div2, "class", "list-group list ");
    			add_location(div2, file$d, 189, 14, 5715);
    			attr_dev(div3, "class", "card-body");
    			add_location(div3, file$d, 188, 12, 5676);
    			attr_dev(div4, "class", "card m-b-20 card-vnc svelte-1e95eny");
    			add_location(div4, file$d, 184, 10, 5501);
    			attr_dev(div5, "class", "col-lg-5");
    			add_location(div5, file$d, 183, 8, 5467);
    			attr_dev(h51, "class", "m-b-0");
    			add_location(h51, file$d, 219, 14, 6996);
    			attr_dev(div6, "class", "card-header");
    			add_location(div6, file$d, 218, 12, 6955);
    			attr_dev(input0, "type", "hidden");
    			attr_dev(input0, "name", "IdUser");
    			input0.value = "0";
    			add_location(input0, file$d, 223, 16, 7149);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$d, 226, 20, 7306);
    			input1.value = input1_value_value = /*paciente*/ ctx[1].nombre || "";
    			attr_dev(input1, "type", "name");
    			attr_dev(input1, "class", "form-control");
    			input1.readOnly = true;
    			attr_dev(input1, "name", "Name");
    			attr_dev(input1, "maxlength", "200");
    			add_location(input1, file$d, 227, 20, 7356);
    			attr_dev(div7, "class", "form-group col-md-6");
    			add_location(div7, file$d, 225, 18, 7251);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$d, 236, 20, 7704);
    			input2.value = input2_value_value = /*paciente*/ ctx[1].apellidos || "";
    			attr_dev(input2, "type", "name");
    			attr_dev(input2, "class", "form-control");
    			input2.readOnly = true;
    			attr_dev(input2, "name", "Name");
    			attr_dev(input2, "maxlength", "200");
    			add_location(input2, file$d, 237, 20, 7756);
    			attr_dev(div8, "class", "form-group col-md-6");
    			add_location(div8, file$d, 235, 18, 7649);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$d, 247, 20, 8109);
    			attr_dev(input3, "type", "name");
    			attr_dev(input3, "class", "form-control");
    			input3.readOnly = true;
    			input3.value = input3_value_value = /*paciente*/ ctx[1].cedula || "";
    			attr_dev(input3, "maxlength", "200");
    			add_location(input3, file$d, 248, 20, 8159);
    			attr_dev(div9, "class", "form-group col-md-6");
    			add_location(div9, file$d, 246, 18, 8054);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$d, 257, 20, 8474);
    			input4.value = input4_value_value = /*paciente*/ ctx[1].telefono || "";
    			attr_dev(input4, "type", "tel");
    			attr_dev(input4, "class", "form-control");
    			input4.readOnly = true;
    			attr_dev(input4, "name", "Name");
    			attr_dev(input4, "maxlength", "200");
    			add_location(input4, file$d, 258, 20, 8526);
    			attr_dev(div10, "class", "form-group col-md-6");
    			add_location(div10, file$d, 256, 18, 8419);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$d, 268, 20, 8878);
    			attr_dev(input5, "type", "email");
    			attr_dev(input5, "class", "form-control");
    			input5.readOnly = true;
    			input5.value = input5_value_value = /*paciente*/ ctx[1].correo || "";
    			attr_dev(input5, "maxlength", "200");
    			add_location(input5, file$d, 269, 20, 8940);
    			attr_dev(div11, "class", "form-group col-md-12");
    			add_location(div11, file$d, 267, 18, 8822);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$d, 278, 20, 9256);
    			input6.value = input6_value_value = /*paciente*/ ctx[1].nombreAseguradora || "";
    			attr_dev(input6, "type", "email");
    			attr_dev(input6, "class", "form-control");
    			input6.readOnly = true;
    			attr_dev(input6, "maxlength", "200");
    			add_location(input6, file$d, 279, 20, 9311);
    			attr_dev(div12, "class", "form-group col-md-6");
    			add_location(div12, file$d, 277, 18, 9201);
    			attr_dev(label6, "for", "");
    			add_location(label6, file$d, 288, 20, 9638);
    			attr_dev(input7, "type", "text");
    			attr_dev(input7, "class", "form-control");
    			input7.readOnly = true;
    			attr_dev(input7, "maxlength", "200");
    			input7.value = input7_value_value = /*paciente*/ ctx[1].noAfiliado || "";
    			add_location(input7, file$d, 289, 20, 9692);
    			attr_dev(div13, "class", "form-group col-md-6");
    			add_location(div13, file$d, 287, 18, 9583);
    			attr_dev(label7, "for", "");
    			add_location(label7, file$d, 298, 20, 10011);
    			attr_dev(input8, "type", "email");
    			attr_dev(input8, "class", "form-control");
    			input8.readOnly = true;
    			input8.value = input8_value_value = /*paciente*/ ctx[1].nacionalidad || "";
    			attr_dev(input8, "maxlength", "200");
    			add_location(input8, file$d, 299, 20, 10059);
    			attr_dev(div14, "class", "form-group col-md-6");
    			add_location(div14, file$d, 297, 18, 9956);
    			attr_dev(label8, "for", "");
    			add_location(label8, file$d, 308, 20, 10381);
    			attr_dev(input9, "type", "email");
    			attr_dev(input9, "class", "form-control");
    			input9.readOnly = true;
    			attr_dev(input9, "maxlength", "200");
    			input9.value = input9_value_value = /*paciente*/ ctx[1].provincia || "";
    			add_location(input9, file$d, 309, 20, 10434);
    			attr_dev(div15, "class", "form-group col-md-6");
    			add_location(div15, file$d, 307, 18, 10326);
    			attr_dev(label9, "for", "");
    			add_location(label9, file$d, 318, 20, 10754);
    			attr_dev(textarea0, "class", "form-control");
    			attr_dev(textarea0, "rows", "2");
    			textarea0.readOnly = true;
    			textarea0.value = textarea0_value_value = /*paciente*/ ctx[1].direccion || "";
    			add_location(textarea0, file$d, 319, 20, 10807);
    			attr_dev(div16, "class", "form-group col-md-12");
    			add_location(div16, file$d, 317, 18, 10698);
    			attr_dev(label10, "for", "");
    			add_location(label10, file$d, 327, 20, 11087);
    			textarea1.value = textarea1_value_value = /*paciente*/ ctx[1].observaciones || "";
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "rows", "3");
    			attr_dev(textarea1, "name", "Observaciones");
    			add_location(textarea1, file$d, 328, 20, 11144);
    			attr_dev(div17, "class", "form-group col-md-12");
    			add_location(div17, file$d, 326, 18, 11031);
    			add_location(br, file$d, 334, 18, 11382);
    			attr_dev(div18, "class", "row");
    			add_location(div18, file$d, 224, 16, 7214);
    			attr_dev(form, "id", "frmPaciente");
    			add_location(form, file$d, 222, 14, 7108);
    			attr_dev(div19, "class", "card-body ");
    			add_location(div19, file$d, 221, 12, 7068);
    			attr_dev(div20, "class", "card m-b-30");
    			add_location(div20, file$d, 217, 10, 6916);
    			attr_dev(div21, "class", "col-lg-7");
    			add_location(div21, file$d, 216, 8, 6882);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$d, 171, 6, 4937);
    			attr_dev(div23, "class", "container mt-3");
    			add_location(div23, file$d, 170, 4, 4901);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$d, 169, 2, 4864);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$d, 167, 0, 4821);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div0);
    			append_dev(div0, button);
    			append_dev(button, i);
    			append_dev(button, t2);
    			append_dev(div22, t3);
    			append_dev(div22, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h50);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div22, t6);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div6);
    			append_dev(div6, h51);
    			append_dev(div20, t8);
    			append_dev(div20, div19);
    			append_dev(div19, form);
    			append_dev(form, input0);
    			append_dev(form, t9);
    			append_dev(form, div18);
    			append_dev(div18, div7);
    			append_dev(div7, label0);
    			append_dev(div7, t11);
    			append_dev(div7, input1);
    			append_dev(div18, t12);
    			append_dev(div18, div8);
    			append_dev(div8, label1);
    			append_dev(div8, t14);
    			append_dev(div8, input2);
    			append_dev(div18, t15);
    			append_dev(div18, div9);
    			append_dev(div9, label2);
    			append_dev(div9, t17);
    			append_dev(div9, input3);
    			append_dev(div18, t18);
    			append_dev(div18, div10);
    			append_dev(div10, label3);
    			append_dev(div10, t20);
    			append_dev(div10, input4);
    			append_dev(div18, t21);
    			append_dev(div18, div11);
    			append_dev(div11, label4);
    			append_dev(div11, t23);
    			append_dev(div11, input5);
    			append_dev(div18, t24);
    			append_dev(div18, div12);
    			append_dev(div12, label5);
    			append_dev(div12, t26);
    			append_dev(div12, input6);
    			append_dev(div18, t27);
    			append_dev(div18, div13);
    			append_dev(div13, label6);
    			append_dev(div13, t29);
    			append_dev(div13, input7);
    			append_dev(div18, t30);
    			append_dev(div18, div14);
    			append_dev(div14, label7);
    			append_dev(div14, t32);
    			append_dev(div14, input8);
    			append_dev(div18, t33);
    			append_dev(div18, div15);
    			append_dev(div15, label8);
    			append_dev(div15, t35);
    			append_dev(div15, input9);
    			append_dev(div18, t36);
    			append_dev(div18, div16);
    			append_dev(div16, label9);
    			append_dev(div16, t38);
    			append_dev(div16, textarea0);
    			append_dev(div18, t39);
    			append_dev(div18, div17);
    			append_dev(div17, label10);
    			append_dev(div17, t41);
    			append_dev(div17, textarea1);
    			append_dev(div18, t42);
    			append_dev(div18, br);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*terminarCita*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*envioPacienteActual, citaPacienteActual, undefined*/ 5) {
    				toggle_class(button, "d-none", /*envioPacienteActual*/ ctx[2] == "" || /*citaPacienteActual*/ ctx[0] == undefined);
    			}

    			if (dirty & /*envioPacienteActual, citas, pacienteSeleccionado, getPaciente, cambiarDePaciente*/ 188) {
    				each_value = /*citas*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*paciente*/ 2 && input1_value_value !== (input1_value_value = /*paciente*/ ctx[1].nombre || "")) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input2_value_value !== (input2_value_value = /*paciente*/ ctx[1].apellidos || "")) {
    				prop_dev(input2, "value", input2_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input3_value_value !== (input3_value_value = /*paciente*/ ctx[1].cedula || "")) {
    				prop_dev(input3, "value", input3_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input4_value_value !== (input4_value_value = /*paciente*/ ctx[1].telefono || "")) {
    				prop_dev(input4, "value", input4_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input5_value_value !== (input5_value_value = /*paciente*/ ctx[1].correo || "") && input5.value !== input5_value_value) {
    				prop_dev(input5, "value", input5_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input6_value_value !== (input6_value_value = /*paciente*/ ctx[1].nombreAseguradora || "") && input6.value !== input6_value_value) {
    				prop_dev(input6, "value", input6_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input7_value_value !== (input7_value_value = /*paciente*/ ctx[1].noAfiliado || "") && input7.value !== input7_value_value) {
    				prop_dev(input7, "value", input7_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input8_value_value !== (input8_value_value = /*paciente*/ ctx[1].nacionalidad || "") && input8.value !== input8_value_value) {
    				prop_dev(input8, "value", input8_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && input9_value_value !== (input9_value_value = /*paciente*/ ctx[1].provincia || "") && input9.value !== input9_value_value) {
    				prop_dev(input9, "value", input9_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && textarea0_value_value !== (textarea0_value_value = /*paciente*/ ctx[1].direccion || "")) {
    				prop_dev(textarea0, "value", textarea0_value_value);
    			}

    			if (!current || dirty & /*paciente*/ 2 && textarea1_value_value !== (textarea1_value_value = /*paciente*/ ctx[1].observaciones || "")) {
    				prop_dev(textarea1, "value", textarea1_value_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $session;
    	let $axios;
    	let $activePage;
    	let $connection;
    	let $errorConexion;
    	let $toast;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(9, $session = $$value));
    	validate_store(axios$2, "axios");
    	component_subscribe($$self, axios$2, $$value => $$invalidate(10, $axios = $$value));
    	validate_store(activePage, "activePage");
    	component_subscribe($$self, activePage, $$value => $$invalidate(11, $activePage = $$value));
    	validate_store(connection, "connection");
    	component_subscribe($$self, connection, $$value => $$invalidate(12, $connection = $$value));
    	validate_store(errorConexion, "errorConexion");
    	component_subscribe($$self, errorConexion, $$value => $$invalidate(13, $errorConexion = $$value));
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(14, $toast = $$value));
    	let user = {};
    	user = new UserManager($session.authorizationHeader.Authorization);

    	set_store_value(
    		axios$2,
    		$axios.defaults.headers.common = {
    			Authorization: $session.authorizationHeader.Authorization
    		},
    		$axios
    	);

    	set_store_value(activePage, $activePage = "espacioMedico");
    	let citaPacienteActual = {};
    	let paciente = {};
    	let envioPacienteActual = "";
    	let pacienteSeleccionado = "";
    	let citas = [];

    	onMount(() => {
    		cargarPacientesActivos();
    		buscarPacientePendiente();
    	});

    	$connection.on("RecibirPaciente", (pacienteID, tipo) => {
    		cargarPacientesActivos();

    		if (tipo == "asignar") {
    			$$invalidate(2, envioPacienteActual = pacienteID || "");
    			getPaciente(envioPacienteActual, "asistente");
    		}
    	});

    	function cargarPacientesActivos() {
    		$axios.get("/Medicos/" + user.nameid + "/PacientesActivos").then(res => {
    			$$invalidate(4, citas = res.data.filter(e => moment(e.fecha).format("YYYY-MM-DD") == moment().format("YYYY-MM-DD")));
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function getPaciente(id, via) {
    		if (id == "") {
    			return;
    		}

    		$axios.get("/Pacientes/" + id).then(res => {
    			if (via == "asistente" || via == "carga") {
    				$$invalidate(0, citaPacienteActual = citas.find(x => x.pacienteID == envioPacienteActual));

    				if (citas.some(x => x.pacienteID == envioPacienteActual)) {
    					$$invalidate(1, paciente = res.data);
    					$$invalidate(3, pacienteSeleccionado = paciente.id);
    				}
    			}

    			if (via == "seleccion") {
    				$$invalidate(1, paciente = res.data);
    				$$invalidate(3, pacienteSeleccionado = paciente.id);
    			}
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	function terminarCita() {
    		if (Object.entries(citaPacienteActual).length > 0 && citaPacienteActual != undefined) {
    			$$invalidate(0, citaPacienteActual.inactivo = true, citaPacienteActual);
    			$$invalidate(0, citaPacienteActual.estadoID = 3, citaPacienteActual);

    			$axios.put("/Citas/" + citaPacienteActual.id, citaPacienteActual).then(res => {
    				if (res.data.success) {
    					$$invalidate(0, citaPacienteActual = {});
    					$$invalidate(1, paciente = {});
    					$$invalidate(2, envioPacienteActual = "");
    					cargarPacientesActivos();
    					$connection.invoke("EnviarAvisoDelPaciente", user.nameid, "").catch(err => console.error(err));
    				}
    			}).catch(err => {
    				console.error(err);
    				$errorConexion();
    			});
    		}
    	}

    	function cambiarDePaciente(id) {
    		sweetalert2_all.fire({
    			title: "Cambio de paciente",
    			text: "Estas seguro que deseas cambiar de paciente?",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			cancelButtonText: "No",
    			confirmButtonText: "Si"
    		}).then(result => {
    			if (result.isConfirmed) {
    				$axios.post("/Medicos/" + user.nameid + "/AsignarPaciente?pacienteId=" + id).then(res => {
    					if (!res.data.errors) {
    						$$invalidate(2, envioPacienteActual = id);
    						$$invalidate(0, citaPacienteActual = citas.find(x => x.pacienteID == id));
    						$connection.invoke("EnviarAvisoDelPaciente", user.nameid, id).catch(err => console.error(err));

    						$toast(5000).fire({
    							icon: "success",
    							title: "Cambio realizado con exito"
    						});
    					} else {
    						sweetalert2_all.fire({
    							title: "Error",
    							text: "Problema al cambiar paciente",
    							icon: "error"
    						});
    					}
    				}).catch(err => {
    					console.error(err);
    					$errorConexion();
    				});
    			}
    		});
    	}

    	function buscarPacientePendiente() {
    		$axios.get("/Medicos/" + user.nameid + "/PacientePendiente").then(res => {
    			$$invalidate(2, envioPacienteActual = res.data.data);
    			getPaciente(envioPacienteActual, "carga");
    		}).catch(err => {
    			console.error(err);
    			$errorConexion();
    		});
    	}

    	const writable_props = [];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<EspacioTrabajo> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EspacioTrabajo", $$slots, []);

    	const click_handler = item => {
    		getPaciente(item.pacienteID, "seleccion");
    	};

    	const dblclick_handler = item => cambiarDePaciente(item.pacienteID);

    	$$self.$capture_state = () => ({
    		Aside,
    		Header,
    		connection,
    		activePage,
    		session,
    		axios: axios$2,
    		errorConexion,
    		toast,
    		UserManager,
    		onMount,
    		push,
    		moment,
    		Swal: sweetalert2_all,
    		user,
    		citaPacienteActual,
    		paciente,
    		envioPacienteActual,
    		pacienteSeleccionado,
    		citas,
    		cargarPacientesActivos,
    		getPaciente,
    		terminarCita,
    		cambiarDePaciente,
    		buscarPacientePendiente,
    		$session,
    		$axios,
    		$activePage,
    		$connection,
    		$errorConexion,
    		$toast
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) user = $$props.user;
    		if ("citaPacienteActual" in $$props) $$invalidate(0, citaPacienteActual = $$props.citaPacienteActual);
    		if ("paciente" in $$props) $$invalidate(1, paciente = $$props.paciente);
    		if ("envioPacienteActual" in $$props) $$invalidate(2, envioPacienteActual = $$props.envioPacienteActual);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(3, pacienteSeleccionado = $$props.pacienteSeleccionado);
    		if ("citas" in $$props) $$invalidate(4, citas = $$props.citas);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		citaPacienteActual,
    		paciente,
    		envioPacienteActual,
    		pacienteSeleccionado,
    		citas,
    		getPaciente,
    		terminarCita,
    		cambiarDePaciente,
    		user,
    		$session,
    		$axios,
    		$activePage,
    		$connection,
    		$errorConexion,
    		$toast,
    		cargarPacientesActivos,
    		buscarPacientePendiente,
    		click_handler,
    		dblclick_handler
    	];
    }

    class EspacioTrabajo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EspacioTrabajo",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\Pages\Home\Error404.svelte generated by Svelte v3.23.0 */

    const file$e = "src\\Pages\\Home\\Error404.svelte";

    function create_fragment$f(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Error 404";
    			add_location(h1, file$e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Error404> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Error404", $$slots, []);
    	return [];
    }

    class Error404 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Error404",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\Pages\Home\Unauthorized.svelte generated by Svelte v3.23.0 */

    const file$f = "src\\Pages\\Home\\Unauthorized.svelte";

    function create_fragment$g(ctx) {
    	let h2;
    	let t1;
    	let a;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Unathorized 401";
    			t1 = space();
    			a = element("a");
    			a.textContent = "Ir a inicio";
    			attr_dev(h2, "class", "ml-2 mt-2");
    			add_location(h2, file$f, 0, 0, 0);
    			attr_dev(a, "class", "ml-2 mt-2");
    			attr_dev(a, "href", "#/");
    			add_location(a, file$f, 2, 0, 46);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Unauthorized> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Unauthorized", $$slots, []);
    	return [];
    }

    class Unauthorized extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Unauthorized",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    let $session = null;
    session.subscribe(x => $session = x);
    let user = new UserManager(localStorage.getItem('access_token'));

    const routes = {
        '/': wrap({
            component: Index,
            conditions: [() => $session.isValid]
        }),
        "/Home/Index": wrap({
            component: Index,
            conditions: [() => $session.isValid]
        }),
        "/Home/Login": wrap({
            asyncComponent: () => Login,
            conditions: [
                (detail) => {
                    if (!$session.isValid) {
                        return true;
                    } else {
                        detail.userData = "i";
                        return false;
                    }
                },
            ]
        }),
        "/Usuario/Index": wrap({
            asyncComponent: () => Index$2,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.is('admin')) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Asistente/Index": wrap({
            asyncComponent: () => Index$1,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['assistant', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Asistente/CitasProgramadas": wrap({
            asyncComponent: () => CitasProgramadas,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['assistant', 'operator', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Cita/Gestionar": wrap({
            asyncComponent: () => Gestion,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['assistant', 'operator', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Cita/Crear": wrap({
            asyncComponent: () => Crear,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['assistant', 'operator', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Medico/Perfil/:id": wrap({
            asyncComponent: () => Perfil,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['assistant', 'operator', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Medico/EspacioTrabajo": wrap({
            asyncComponent: () => EspacioTrabajo,
            conditions: [
                (detail) => {
                    if ($session.isValid) {
                        return true;
                    } else {
                        detail.userData = "s";
                        return false;
                    }
                },
                (detail) => {
                    user.asign(localStorage.getItem('access_token'));
                    if (user.isAny(['doctor', 'admin'])) {
                        return true
                    } else {
                        detail.userData = "r";
                        return false
                    }
                }
            ]
        }),
        "/Home/Unauthorized": wrap({
            asyncComponent: () => Unauthorized,
            conditions: [() => $session.isValid]
        }),
        "*": wrap({
            asyncComponent: () => Error404
        })
    };

    /* src\App.svelte generated by Svelte v3.23.0 */

    const { console: console_1$b } = globals;

    function create_fragment$h(ctx) {
    	let current;
    	const router = new Router({ props: { routes }, $$inline: true });
    	router.$on("routeLoaded", event);
    	router.$on("conditionsFailed", /*conditionsFailed_handler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function event(e) {
    	jQuery("body").removeClass("sidebar-open");
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $session;
    	let $connection;
    	validate_store(session, "session");
    	component_subscribe($$self, session, $$value => $$invalidate(0, $session = $$value));
    	validate_store(connection, "connection");
    	component_subscribe($$self, connection, $$value => $$invalidate(1, $connection = $$value));

    	onMount(() => {
    		if ($session.isValid) {
    			$connection.start().catch(e => console.error(e));
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);

    	const conditionsFailed_handler = e => {
    		if (e.detail.userData == "r") {
    			push("/Home/Unauthorized");
    		} else if (e.detail.userData == "i") {
    			push("/");
    		} else {
    			push("/Home/Login");
    		}
    	};

    	$$self.$capture_state = () => ({
    		Home: Index,
    		Router,
    		push,
    		connection,
    		session,
    		routes,
    		onMount,
    		event,
    		$session,
    		$connection
    	});

    	return [$session, $connection, conditionsFailed_handler];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    const app = new App({
    	target: document.querySelector("#app"),
    	props: {}
    });

    return app;

}(moment));
//# sourceMappingURL=bundle.js.map
